====================
FILE: data_loader.js
====================
/** @file data_loader.js @description 外部データ（CSV/TSV）の非同期取得とマスタデータの構築を担当 @dependency cats.js, gacha_series.js */

/**
 * [gatya.tsv Data Structure Memo]
 * * ■ 基本構造
 * ・1-10列目 (Idx 0-9): 年月日・時刻情報
 * Idx 0: 開始年月日 (YYYYMMDD)
 * Idx 1: 開始時刻 (HHMM)
 * Idx 2: 終了年月日 (YYYYMMDD)
 * Idx 3: 終了時刻 (HHMM)
 * Idx 8: レアロールズ対象フラグ (1以外は除外)
 * * ・11列目以降 (Idx 10~): ガチャ情報ブロック (15列/ブロック の繰り返し)
 * ブロック開始インデックスを i (10, 25, 40...) とすると:
 * i+0  : ガチャID (Gacha ID)
 * i+6  : レアレート (Rare Rate)
 * i+8  : 激レアレート (Super Rare Rate)
 * i+10 : 超激レアレート (Uber Rare Rate)
 * i+11 : 超激レア確定フラグ (Guaranteed Flag, 1=確定)
 * i+12 : 伝説レアレート (Legend Rare Rate)
 * i+14 : 日本語説明文 (Description)
 */

// グローバル変数 (データ保持用)
let gachaMasterData = { cats: {}, gachas: {} };
let loadedTsvContent = null; // スケジュールデータ (gatya.tsv)

// 全データのロードと構築を行うメイン関数
async function loadAllData() {
    console.log("Loading data...");
    // 1. キャラクターデータ (cats.js) の処理
    processCatsData();

    // 2. マスタデータ (CSV/TSV) の取得と構築
    try {
        const [csvRes, tsvRes, gatyaRes] = await Promise.all([
            fetch('GatyaDataSetR1.csv'),
            fetch('GatyaData_Option_SetR.tsv'),
            fetch('gatya.tsv') // スケジュールデータもここで取得
        ]);
        if (!csvRes.ok) throw new Error("GatyaDataSetR1.csv fetch failed");
        if (!tsvRes.ok) throw new Error("GatyaData_Option_SetR.tsv fetch failed");
        
        const csvText = await csvRes.text();
        const tsvText = await tsvRes.text();
        let gatyaTsvText = null;
        
        if (gatyaRes.ok) {
            gatyaTsvText = await gatyaRes.text();
            loadedTsvContent = gatyaTsvText;
            console.log("gatya.tsv loaded successfully.");
        } else {
            console.warn("gatya.tsv not found.");
        }

        // マスタデータの構築
        const gachasMaster = buildGachaMaster(gachaMasterData.cats, csvText, tsvText);
        // gatya.tsv から正確なレート情報を反映
        if (gatyaTsvText) {
            applyTsvRates(gachasMaster, gatyaTsvText);
        }

        gachaMasterData.gachas = gachasMaster;
        
        console.log("Master Data Built:", Object.keys(gachasMaster).length, "gachas loaded.");
        return true;
    } catch (e) {
        console.error("Critical Data Load Error:", e);
        return false;
    }
}

// cats.js のデータを gachaMasterData.cats に変換
function processCatsData() {
    const fallbackCats = [{id:31, name:"ネコぼさつ", rarity:3}];
    let catsData = (typeof cats !== 'undefined') ? cats : fallbackCats;
    const rarityMap = { 0: "nomal", 1: "ex", 2: "rare", 3: "super", 4: "uber", 5: "legend" };
    const catsMaster = {};
    
    for (const cat of catsData) {
        catsMaster[cat.id] = { ...cat, rarity: rarityMap[cat.rarity] || "rare" };
    }
    gachaMasterData.cats = catsMaster;
}

// マスタデータ構築ロジック (CSV行番号 = ID)
function buildGachaMaster(catsMaster, csvText, tsvText) {
    const gachasMaster = {};
    // 1. CSVを行ごとに分割 (1行目=ID:0, 2行目=ID:1...)
    const gachaPools = csvText.split(/\r?\n/);
    // 2. Option TSVをパースして GatyaSetID -> seriesID のマップを作成
    const tsvLines = tsvText.split(/\r?\n/);
    const headers = tsvLines[0].split('\t').map(h => h.trim());
    const idIdx = headers.indexOf('GatyaSetID');
    const seriesIdx = headers.indexOf('seriesID');

    const gachaSeriesMap = {};
    if (idIdx !== -1 && seriesIdx !== -1) {
        for (let i = 1; i < tsvLines.length; i++) {
            const line = tsvLines[i];
            if (!line.trim()) continue;
            const cols = line.split('\t');
            const gID = parseInt(cols[idIdx]);
            const sID = parseInt(cols[seriesIdx]);
            if (!isNaN(gID) && !isNaN(sID)) {
                gachaSeriesMap[gID] = sID;
            }
        }
    }

    // gacha_series.js のデータ
    let seriesList = (typeof gacha_series !== 'undefined') ? gacha_series : [];

    // 3. 全結合して gachasMaster を構築
    gachaPools.forEach((line, index) => {
        if (!line.trim()) return;

        // CSVの行番号(index) = ガチャID
        const gachaID = index;
        const poolCats = line.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));

        const seriesID = gachaSeriesMap[gachaID];

        // デフォルト情報
        let seriesInfo = { 
            name: `Gacha ID: ${gachaID}`, 
            rare: 0, supa: 0, uber: 0, legend: 0, sort: 999 
        };
        
        // gacha_series.js から名前とレートを引く
        if (seriesID !== undefined) {
            const found = seriesList.find(s => s.series_id === seriesID);
            if (found) {
                seriesInfo = found;
            }
        }

        // キャラクタープール構築
        const pool = { rare: [], super: [], uber: [], legend: [], nomal: [], ex: [] };
        for (const catId of poolCats) {
            const catInfo = catsMaster[catId];
            if (catInfo && pool[catInfo.rarity] !== undefined) {
                pool[catInfo.rarity].push({ id: catInfo.id, name: catInfo.name });
            }
        }

        gachasMaster[gachaID] = {
            id: gachaID.toString(),
            name: seriesInfo.name, // ガチャ名称
            rarity_rates: { 
                rare: seriesInfo.rare || 0, 
                super: seriesInfo.supa || 0,
                uber: seriesInfo.uber || 0, 
                legend: seriesInfo.legend || 0 
            },
            pool: pool,
            sort: seriesInfo.sort || 999,
            series_id: seriesID,
            guaranteed: false // デフォルトはfalse
        };
    });

    return gachasMaster;
}

// gatya.tsv からレート情報と確定情報を抽出してマスタデータに適用する
function applyTsvRates(gachasMaster, tsvContent) {
    const lines = tsvContent.split('\n');
    lines.forEach(line => {
        if (line.trim().startsWith('[') || !line.trim()) return;
        const cols = line.split('\t');
        if (cols.length < 15) return;

        // 9列目(Idx 8)が「1」以外の行は除外
        if (cols[8] !== '1') return;

        for (let i = 10; i < cols.length; i += 15) {
            if (i + 14 >= cols.length) break;

            const gachaId = parseInt(cols[i]);
            if (isNaN(gachaId) || gachaId < 0) continue;

            const isGuaranteed = cols[i + 11] === '1';
            // 確定フラグがある場合はID末尾に'g'を付けた別エントリとして保持する
            const storageId = isGuaranteed ? `${gachaId}g` : `${gachaId}`;

            const rateRare = parseInt(cols[i + 6]) || 0;
            const rateSupa = parseInt(cols[i + 8]) || 0;
            const rateUber = parseInt(cols[i + 10]) || 0;
            const rateLegend = parseInt(cols[i + 12]) || 0;

            if (gachasMaster[gachaId]) {
                // 元のデータをコピーして新しい設定を適用
                gachasMaster[storageId] = JSON.parse(JSON.stringify(gachasMaster[gachaId]));
                gachasMaster[storageId].id = storageId.toString();
                gachasMaster[storageId].rarity_rates = {
                    rare: rateRare,
                    super: rateSupa,
                    uber: rateUber,
                    legend: rateLegend
                };
                gachasMaster[storageId].guaranteed = isGuaranteed;
                
                // 確定名称の付与
                if (isGuaranteed && !gachasMaster[storageId].name.includes("確定")) {
                    gachasMaster[storageId].name += " [確定]";
                }
            }
        }
    });
}

====================
FILE: gacha_selector.js
====================
/** @file gacha_selector.js @description ガチャ選択用プルダウンのオプション項目生成を担当 @dependency data_loader.js, schedule_logic.js */

function getGachaSelectorOptions(selectedId) {
    const now = new Date();
    const formatInt = (d) => {
        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        return parseInt(`${y}${m}${day}`, 10);
    };
    const yesterdayDate = new Date(now);
    yesterdayDate.setDate(yesterdayDate.getDate() - 1);
    const yesterdayInt = formatInt(yesterdayDate);

    const toShortDate = (str) => {
        if(!str || str.length < 8) return str;
        return `${parseInt(str.substring(4,6))}/${parseInt(str.substring(6,8))}`;
    };

    let scheduleRaw = [];
    if (loadedTsvContent && typeof parseGachaTSV === 'function') {
        scheduleRaw = parseGachaTSV(loadedTsvContent);
    }
    
    const usedIds = new Set();
    const allOptions = [];

    // Group 1: スケジュール (終了日 >= 昨日)
    let scheduledItems = [];
    scheduleRaw.forEach(item => {
        if(!gachaMasterData.gachas[item.id]) return;

        const masterName = gachaMasterData.gachas[item.id].name;
        const checkStr = (masterName + item.tsvName).replace(/\s/g, "");
        const isSpecial = checkStr.includes("プラチナ") || checkStr.includes("レジェンド");

        const e = parseInt(item.rawEnd, 10);

        // 表示条件: 特殊ガチャ または 終了日が昨日以降
        if (isSpecial || e >= yesterdayInt) {
            scheduledItems.push({
                id: item.id,
                name: masterName,
                tsvName: item.tsvName || item.name,
                rawStart: item.rawStart,
                rawEnd: item.rawEnd,
                s: parseInt(item.rawStart, 10),
                isSpecial: isSpecial,
                isGuaranteed: item.guaranteed // 確定フラグを引き継ぐ
            });
        }
    });

    scheduledItems.sort((a, b) => {
        if (a.isSpecial !== b.isSpecial) return a.isSpecial ? 1 : -1;
        return a.s - b.s;
    });

    scheduledItems.forEach(item => {
        if (usedIds.has(item.id.toString())) return;
        
        // 確定フラグがある場合、名称に [確定] を付与 (既に含まれていれば二重付与しない)
        let displayName = item.name;
        if (item.isGuaranteed && !displayName.includes("確定")) {
            displayName += " [確定]";
        }

        // 変更前: const baseName = `${displayName} (${item.id})`;
        // 変更前: let label = item.isSpecial ? ... : ...;

        // 変更後: IDを日付の直後に配置して見切れを防止
        // view_table.jsのヘッダー表示（スペースで改行）に合わせて、"日付(ID) ガチャ名" の形式にする
        let datePart = item.isSpecial 
            ? `${toShortDate(item.rawStart)}~`
            : `${toShortDate(item.rawStart)}~${toShortDate(item.rawEnd)}`;
        
        // 日付とIDの間を詰めることで、view_table.js側で「日付(ID)」の塊として認識させ、改行後にガチャ名を表示させる
        let label = `${datePart}(${item.id}) ${displayName}`;
        
        allOptions.push({ value: item.id, label: label });
        usedIds.add(item.id.toString());
    });

    // Group 2: シリーズ最新 (G1で表示済みはスキップ)
    const seriesMaxMap = new Map();
    Object.values(gachaMasterData.gachas).forEach(g => {
        if (usedIds.has(g.id)) return;
        if (g.series_id !== undefined && g.sort < 800) {
            const current = seriesMaxMap.get(g.series_id);
            if (!current || parseInt(g.id) > parseInt(current.id)) {
                seriesMaxMap.set(g.series_id, g);
            }
        }
    });

    const seriesList = Array.from(seriesMaxMap.values());
    seriesList.sort((a, b) => a.sort - b.sort);

    seriesList.forEach(g => {
        allOptions.push({ value: g.id, label: `${g.name} (${g.id})` });
        usedIds.add(g.id);
    });

    // Group 3: その他
    const othersList = [];
    Object.values(gachaMasterData.gachas).forEach(g => {
        if (usedIds.has(g.id)) return;
        othersList.push(g);
    });

    othersList.sort((a, b) => parseInt(b.id) - parseInt(a.id));

    othersList.forEach(g => {
        allOptions.push({ value: g.id, label: `${g.id} ${g.name}` });
        usedIds.add(g.id);
    });

    if (selectedId && !usedIds.has(selectedId)) {
        const missing = gachaMasterData.gachas[selectedId];
        if (missing) {
            allOptions.push({ value: selectedId, label: `${selectedId} ${missing.name} (選択中)` });
        }
    }

    return allOptions;
}

====================
FILE: gacha_series.js
====================
/** @file gacha_series.js @description 各ガチャシリーズのメタデータ（名称、デフォルトレート、ソート順）の定義 @dependency なし */

/**
 * Sortの区分について
 * 100～199：ネコ祭
 * 200～299：バスターズ
 * 300～399：常設
 * 400～499：季節
 * 500～599：４セレクション
 * 600～699：コラボ
 * 700～799：新年その他
 * 800～899：過去分
 */

const gacha_series = [
    {"series_id":0,"name":"ネコルガ族", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":300},
    {"series_id":1,"name":"ダイナマイツ", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":301},
    {"series_id":2,"name":"バサラーズ", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":302},
    {"series_id":3,"name":"ギャラクシーギャルズ", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":303},
    {"series_id":4,"name":"ドラゴンエンペラーズ", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":304},
    {"series_id":5,"name":"レッドバスターズ", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":200},
    {"series_id":6,"name":"ウルトラソウルズ", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":305},
    {"series_id":7,"name":"ダークヒーローズ", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":306},
    {"series_id":8,"name":"ハロウィン", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":400},
    {"series_id":9,"name":"クリスマスギャルズ", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":401},
    {"series_id":10,"name":"忘年会", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":801},
    {"series_id":11,"name":"ゆるドラシル", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":802},
    {"series_id":12,"name":"メタルスラッグディフェンス", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":803},
    {"series_id":13,"name":"メルクストーリア", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":600},
    {"series_id":14,"name":"生きろ！マンボウ！", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":601},
    {"series_id":15,"name":"消滅都市", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":602},
    {"series_id":16,"name":"新年", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":700},
    {"series_id":17,"name":"ケリ姫スイーツ", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":603},
    {"series_id":18,"name":"ギガントゼウス", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":307},
    {"series_id":19,"name":"超ネコ祭", "rare":6470, "supa":2600, "uber":900, "legend":30,"sort":100},
    {"series_id":20,"name":"サマーガールズ", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":804},
    {"series_id":21,"name":"プラチナガチャ", "rare":0, "supa":0, "uber":10000, "legend":0,"sort":102},
    {"series_id":22,"name":"エアバスターズ", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":201},
    {"series_id":23,"name":"魔法少女まどか☆マギカ", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":604},
    {"series_id":24,"name":"アイアンウォーズ", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":308},
    {"series_id":25,"name":"クラッシュフィーバー", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":805},
    {"series_id":26,"name":"イースターカーニバル", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":402},
    {"series_id":27,"name":"極ネコ祭", "rare":6470, "supa":2600, "uber":900, "legend":30,"sort":101},
    {"series_id":28,"name":"ギャルズモンスターズ", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":309},
    {"series_id":29,"name":"ぐでたま", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":806},
    {"series_id":30,"name":"ウルトラセレクション", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":807},
    {"series_id":31,"name":"ミラクルセレクション", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":808},
    {"series_id":32,"name":"メタルバスターズ", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":202},
    {"series_id":33,"name":"エレメンタルピクシーズ", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":310},
    {"series_id":34,"name":"劇場版 Fate stay night", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":605},
    {"series_id":35,"name":"超選抜祭", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":701},
    {"series_id":36,"name":"実況パワフルプロ野球", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":809},
    {"series_id":37,"name":"エヴァンゲリオン", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":606},
    {"series_id":38,"name":"ビックリマン", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":607},
    {"series_id":39,"name":"極選抜祭", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":702},
    {"series_id":40,"name":"ストリートファイターV", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":810},
    {"series_id":41,"name":"エクセレントセレクション", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":811},
    {"series_id":42,"name":"超極ネコ祭", "rare":6470, "supa":2500, "uber":1000, "legend":30,"sort":104},
    {"series_id":43,"name":"初音ミク", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":608},
    {"series_id":44,"name":"エヴァンゲリオン2nd", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":609},
    {"series_id":45,"name":"波動バスターズ", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":203},
    {"series_id":46,"name":"レジェンドガチャ", "rare":0, "supa":0, "uber":9500, "legend":500,"sort":103},
    {"series_id":47,"name":"超国王祭", "rare":6770, "supa":2500, "uber":700, "legend":30,"sort":105},
    {"series_id":48,"name":"バレンタインギャルズ", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":403},
    {"series_id":49,"name":"らんま1/2", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":610},
    {"series_id":50,"name":"女王祭", "rare":6940, "supa":2500, "uber":500, "legend":60,"sort":106},
    {"series_id":51,"name":"くにおくん熱血大運動会", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":812},
    {"series_id":52,"name":"ホワイトデー", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":404},
    {"series_id":53,"name":"ジューンブライド", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":405},
    {"series_id":54,"name":"ストリートファイター BLUE TEAM", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":611},
    {"series_id":55,"name":"ストリートファイター RED TEAM", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":612},
    {"series_id":56,"name":"超生命体バスターズ", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":204},
    {"series_id":57,"name":"くにお熱血大運動会 赤組", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":703},
    {"series_id":58,"name":"りき熱血大運動会 白組", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":704},
    {"series_id":59,"name":"バスターズ祭", "rare":6800, "supa":2500, "uber":700, "legend":0,"sort":107},
    {"series_id":60,"name":"メタルスラッグアタック", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":613},
    {"series_id":61,"name":"9000万DL記念選抜", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":813},
    {"series_id":62,"name":"神魔之塔", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":814},
    {"series_id":63,"name":"るろうに剣心", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":614},
    {"series_id":64,"name":"サマーガールズ サンシャイン", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":406},
    {"series_id":65,"name":"サマーガールズ ブルーオーシャン", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":407},
    {"series_id":66,"name":"ウルトラ4セレクション", "rare":6770, "supa":2500, "uber":700, "legend":30,"sort":500},
    {"series_id":67,"name":"ミラクル4セレクション", "rare":6770, "supa":2500, "uber":700, "legend":30,"sort":501},
    {"series_id":68,"name":"エクセレント4セレクション", "rare":6770, "supa":2500, "uber":700, "legend":30,"sort":502},
    {"series_id":69,"name":"1億チケットガチャ", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":815},
    {"series_id":70,"name":"億DL記念選抜", "rare":6930, "supa":2500, "uber":500, "legend":70,"sort":108},
    {"series_id":71,"name":"アウトレット", "rare":6800, "supa":2500, "uber":700, "legend":0,"sort":705},
    {"series_id":72,"name":"範馬刃牙", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":615},
    {"series_id":73,"name":"ソニック", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":616},
    {"series_id":75,"name":"仮2026新年超極1(956add8)", "rare":6470, "supa":2500, "uber":1000, "legend":30,"sort":101},
    {"series_id":76,"name":"仮2026新年超極2", "rare":6470, "supa":2500, "uber":1000, "legend":30,"sort":101},
    {"series_id":77,"name":"仮2026新年超極3", "rare":6470, "supa":2500, "uber":1000, "legend":30,"sort":101},
    {"series_id":78,"name":"仮2026新年超極4", "rare":6470, "supa":2500, "uber":1000, "legend":30,"sort":101}

];

====================
FILE: index.html
====================
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.3, maximum-scale=3.0, user-scalable=yes">
    <title>R_Rolls</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <style>
        @media (max-width: 768px) {
            html, body { height: 100%; margin: 0; padding: 0 !important; overflow: hidden; }
            .container { height: 100%; display: flex; flex-direction: column; padding: 4px; box-sizing: border-box; }
            .header-row, .controls, .description-box, #result, .forecast-summary-container { flex-shrink: 0; }
            .header-row { flex-direction: row !important; flex-wrap: nowrap !important; overflow-x: auto; align-items: center; padding-bottom: 5px; border-bottom: 1px solid #eee; margin-bottom: 5px; white-space: nowrap; }
            h1 { font-size: 16px !important; margin-right: 5px; }
            .header-actions { display: flex; gap: 3px; flex-wrap: wrap; }
            .header-actions button, .header-actions span { font-size: 10px !important; padding: 2px 6px !important; height: 24px; line-height: 20px; }
            #rolls-table-container { flex-grow: 1; max-height: none !important; margin-bottom: 0 !important; overflow-y: auto; border-bottom: none; }
            #schedule-container { flex-grow: 1; overflow-y: auto; padding-bottom: 0; }
            .schedule-scroll-wrapper { max-height: none !important; }
        }
        .header-actions button { padding: 4px 8px; font-size: 12px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-row">
            <h1>R_Rolls</h1>
            <div class="header-actions">
                <span id="seed-input-trigger" class="text-btn" onclick="toggleSeedInput()">SEED</span>
                <span class="separator">|</span>
                <span id="toggle-find-info-btn" class="text-btn" onclick="toggleFindInfo()">Find</span>
                <span class="separator">|</span>
                <span id="mode-toggle-btn" class="text-btn" onclick="toggleAppMode()">Sim</span>
                <span class="separator">|</span>
                <span id="toggle-schedule-btn" class="text-btn" onclick="toggleSchedule()">skd</span>
                <span class="separator">|</span>
                <span id="toggle-description" class="text-btn" onclick="toggleDescription()">概要</span>
            </div>
        </div>

        <div id="description-content" class="description-box hidden" style="font-size: 0.85em; line-height: 1.6;"></div>

        <div id="main-controls" class="controls" style="display: flex; flex-wrap: wrap; align-items: center; gap: 10px; padding: 5px; margin-bottom: 5px;">
            <div id="seed-input-container" class="control-group hidden" style="margin-bottom: 0; display: flex; align-items: center; gap: 5px;">
                <label for="seed" style="font-size:0.9em;">Seed:</label>
                <input type="number" id="seed" placeholder="Seed" value="12345" style="width:100px; font-size:0.9em;" onkeydown="if(event.key==='Enter') applySeedInput()">
                <button onclick="applySeedInput()" style="padding: 1px 6px; font-size: 11px;">OK</button>
                <button onclick="copySeedToClipboard()" class="secondary" style="padding: 1px 6px; font-size: 11px;">Copy</button>
                <button onclick="cancelSeedInput()" class="secondary" style="padding: 1px 6px; font-size: 11px;">×</button>
            </div>
            <div class="control-group hidden" id="sim-control-wrapper" style="margin-bottom: 0; display: flex; align-items: center; flex-wrap: wrap; width: 100%;">
                <div style="display: flex; align-items: center; width: 100%; gap: 5px; flex-wrap: wrap;">
                    <label for="sim-config" style="font-size:0.9em;">ルート:</label>
                    <input type="text" id="sim-config" placeholder="e.g. 1006 4 942 11g" onchange="updateUrlParams(); resetAndGenerateTable();" style="flex-grow: 1; min-width: 150px;">
                    <button onclick="backSimConfig()" style="font-size: 11px; min-width: 40px;">Back</button>
                    <button onclick="clearSimConfig()" style="font-size: 11px;">Clear</button>
                    <label style="font-size: 0.8em; margin-left: 5px;">MaxPlat:</label>
                    <input type="number" id="sim-max-plat" value="0" min="0" max="5" style="width: 35px; font-size: 0.9em; padding: 1px 2px;">
                    <label style="font-size: 0.8em; margin-left: 2px;">MaxG:</label>
                    <input type="number" id="sim-max-guar" value="0" min="0" max="5" style="width: 35px; font-size: 0.9em; padding: 1px 2px;">
                    <button id="toggle-txt-btn" onclick="toggleTxtMode()" style="font-size: 11px;">Txt</button>
                    <button id="copy-txt-btn" onclick="copyTxtToClipboard()" class="hidden" style="margin-left: 2px; font-size: 11px;">Copy</button>
                </div>
                <div id="sim-error-msg" style="width: 100%; text-align: left; margin-top: 3px; margin-left: 45px; min-height: 1em;"></div>
            </div>
        </div>
        <div id="result" class="result-box hidden" style="font-size: 10px; margin-bottom: 2px;"></div>
        <div id="rolls-table-container"></div>
        <div id="schedule-container" class="hidden"></div>
    </div>
    
    <script src="cats.js"></script>
    <script src="gacha_series.js"></script>
    <script src="limited_cats.js"></script>

    <script src="logic_xorshift.js"></script>
    <script src="logic_rarity.js"></script>
    <script src="logic_duplicate.js"></script>
    <script src="logic_reroll.js"></script>
    <script src="logic_roll_core.js"></script>
    <script src="logic_uber.js"></script>
    <script src="logic_sequential.js"></script>

    <script src="sim_config_helpers.js"></script>
    <script src="sim_utils.js"></script>
    <script src="sim_engine_core.js?v=2"></script>
    <script src="sim_engine_config.js"></script>
    <script src="sim_engine_search.js"></script>
    <!-- <script src="sim_engine.js"></script> -->
    <script src="sim_ui_logic.js"></script>
    <script src="schedule_logic.js"></script>
    <script src="view_schedule_utils.js"></script>
    <script src="view_schedule_gantt.js"></script>
    <script src="view_schedule_table.js"></script>
    <script src="view_schedule_editor.js"></script>
    <script src="data_loader.js"></script>
    <script src="url_manager.js"></script>
    <script src="gacha_selector.js"></script>
    
    <script src="view_forecast_logic.js"></script>
    <script src="view_forecast_render.js"></script>
    <script src="view_forecast_actions.js"></script>
    <script src="view_forecast_core.js"></script>

    <script src="view_master.js"></script>
    <script src="view_analysis.js"></script>
    <script src="view_header.js"></script>
    <script src="view_cell_renderer.js"></script>
    <script src="view_table_data.js"></script>
    <script src="view_table_highlight.js"></script>
    <script src="view_table_dom.js"></script>
    <script src="view_table_headers.js"></script>
    <script src="view_table_renderer.js"></script>
    <script src="view_table_events.js"></script>
    <script src="view_table_debug.js"></script>
    <script src="view_table.js"></script>
    <script src="view_description.js"></script>
    <script src="ui_globals.js"></script>
    <script src="ui_schedule_handler.js"></script>
    <script src="ui_schedule_editor_handler.js"></script>
    <script src="ui_modal_service.js"></script>
    <script src="ui_target_view.js"></script>
    <script src="ui_target_search_view.js"></script>
    <script src="ui_target_search_logic.js"></script>
    <script src="ui_target_manager.js"></script>
    <script src="ui_table_handler.js"></script>
    <script src="ui_mode_logic.js"></script>
    <script src="ui_seed_logic.js"></script>
    <script src="ui_refresh_logic.js"></script>
    <script src="ui_display_logic.js"></script>
    <script src="ui_cell_event.js"></script>
    <script src="main.js"></script>
</body>
</html>

====================
FILE: limited_cats.js
====================
/** @file limited_cats.js @description 限定キャラクター（祭限定など）のIDリスト管理 @dependency なし */

const limitedCats = [283,286,318,333,378,380,397,435,441,484,529,543,559,585,586,609,612,641,657,690,705,758,779,783,787,810,837];
const AnniversaryLimited = [435,484,758,783,810,837];

//837は、2026新年超極_新規の予測のため手動で入力したもののためアップデートされた際には削除すること

====================
FILE: logic.js
====================

====================
FILE: logic_duplicate.js
====================
/** @file logic_duplicate.js @description レア被り判定ロジック */
function checkDuplicateStatus(currentCharId, lastDrawInfo) {
    if (!lastDrawInfo) return { targetToAvoid: null, isConsecutiveRerollTarget: false };

    const idAboveOriginal = lastDrawInfo.originalIdAbove ? String(lastDrawInfo.originalIdAbove) : null;
    const idSourceFinal = lastDrawInfo.finalIdSource ? String(lastDrawInfo.finalIdSource) : null;

    // ルートの連続性（遷移元）を最優先でチェック
    if (idSourceFinal && currentCharId === idSourceFinal) {
        const isR = idAboveOriginal && currentCharId !== idAboveOriginal;
        return { targetToAvoid: idSourceFinal, isConsecutiveRerollTarget: isR };
    }

    // 物理的な直上との一致をチェック
    if (idAboveOriginal && currentCharId === idAboveOriginal) {
        return { targetToAvoid: idAboveOriginal, isConsecutiveRerollTarget: false };
    }

    return { targetToAvoid: null, isConsecutiveRerollTarget: false };
}

====================
FILE: logic_rarity.js
====================
/** @file logic_rarity.js @description レアリティ判定ロジック */
function determineRarity(seed, rates) {
    const rarityRoll = seed % 10000;
    const defaultRates = { rare: 6970, super: 2500, uber: 500, legend: 30 };
    const r = rates || defaultRates;

    if (rarityRoll < r.rare) return 'rare';
    if (rarityRoll < r.rare + r.super) return 'super';
    if (rarityRoll < r.rare + r.super + r.uber) return 'uber';
    if (rarityRoll < r.rare + r.super + r.uber + r.legend) return 'legend';
    return 'rare';
}

====================
FILE: logic_reroll.js
====================
/** @file logic_reroll.js @description 再抽選実行ロジック（スロット除外・多重再抽選対応版） */
function executeReroll(startIndex, duplicateSlotIndex, characterPool, seeds, charIdToAvoid) {
    let character = null;
    let rerollProcess = { attempts: [] };
    let rerollAttempt = 0;

    // プールにキャラが1体しかいない場合は再抽選不可
    if (characterPool.length <= 1) {
        return { character: null, seedsConsumed: 2, rerollProcess: null };
    }

    while (true) {
        const rerollSeedIndex = startIndex + 2 + rerollAttempt;
        
        // 再抽選用のシードが存在するかチェック
        if (rerollSeedIndex >= seeds.length) {
            // これ以上再抽選できない場合は、被りを許容して終了（消費SEEDは通常分のみ）
            return { character: null, seedsConsumed: 2, rerollProcess: rerollProcess };
        }

        const totalChars = characterPool.length;
        const rerollSeed = seeds[rerollSeedIndex];
        
        // (キャラ総数 - 1) を法として剰余を計算
        const tempSlot = rerollSeed % (totalChars - 1);
        
        // 一時的なプールのスロットを、元のプールのスロットにマッピングする
        const finalSlot = tempSlot < duplicateSlotIndex ? tempSlot : tempSlot + 1;
        
        character = characterPool[finalSlot];

        // デバッグ用の情報を記録
        rerollProcess.attempts.push({
            rerollSeedIndex: rerollSeedIndex,
            rerollSeed: rerollSeed,
            tempPoolSize: totalChars - 1,
            tempSlot: tempSlot,
            finalSlot: finalSlot,
            foundCharId: character.id
        });

        // 被りIDと異なるキャラが出たらループ終了
        if (String(character.id) !== String(charIdToAvoid)) {
            break;
        }

        // 被っていた場合は次のSEEDで再試行
        rerollAttempt++;
    }

    // 消費したSEED数 = 通常抽選(2) + 再抽選試行回数(rerollAttempt + 1)
    const seedsConsumed = 2 + rerollAttempt + 1;

    return { character, seedsConsumed, rerollProcess };
}

====================
FILE: logic_roll_core.js
====================
/** @file logic_roll_core.js @description ガチャ抽選メイン統合ロジック */
function rollWithSeedConsumptionFixed(startIndex, gachaConfig, seeds, lastDrawInfo) {
    if (startIndex + 1 >= seeds.length) {
        return { seedsConsumed: 0, finalChar: { name: "データ不足", id: null } };
    }

    const s0_seed = seeds[startIndex];
    const s1_seed = seeds[startIndex + 1];

    const currentRarity = determineRarity(s0_seed, gachaConfig.rarity_rates);
    const characterPool = gachaConfig.pool[currentRarity] || [];

    if (characterPool.length === 0) {
        return { seedsConsumed: 2, finalChar: { name: "該当なし", id: null }, rarity: currentRarity };
    }

    const totalChars = characterPool.length;
    const charIndex = s1_seed % totalChars;
    const originalChar = characterPool[charIndex];
    
    let character = originalChar;
    let seedsConsumed = 2;
    let isRerolled = false;
    let isConsecutiveRerollTarget = false;
    let rerollProcess = null;

    if (currentRarity === 'rare') {
        const status = checkDuplicateStatus(String(character.id), lastDrawInfo);
        if (status.targetToAvoid !== null) {
            isRerolled = true;
            isConsecutiveRerollTarget = status.isConsecutiveRerollTarget;
            const res = executeReroll(startIndex, charIndex, characterPool, seeds, status.targetToAvoid);
            if (res.character) {
                character = res.character;
                seedsConsumed = res.seedsConsumed;
                rerollProcess = res.rerollProcess;
            }
        }
    }

    return { 
        originalChar, finalChar: character, isRerolled, isConsecutiveRerollTarget,
        rarity: currentRarity, charId: character.id, seedsConsumed, 
        debug: {
            startIndex, s0: s0_seed, rarityRoll: s0_seed % 10000, rarity: currentRarity,
            s1: s1_seed, totalChars, charIndex, originalChar,
            isRerolled, isConsecutiveRerollTarget, rerollProcess, finalChar: character, consumed: seedsConsumed
        }
    };
}

====================
FILE: logic_sequential.js
====================
/** @file logic_sequential.js @description 連続抽選シミュレーション */
function calculateSequentialGuaranteed(startSeedIndex, gachaConfig, allSeeds, initialLastDraw, normalRollsCount = 10, forceNoRerollFirst = false) {
    let seedCursor = startSeedIndex;
    let currentLastDraw = forceNoRerollFirst ? null : initialLastDraw;
    const debugLog = [];
    const normalRollsResults = [];

    for (let i = 0; i < normalRollsCount; i++) {
        const rr = rollWithSeedConsumptionFixed(seedCursor, gachaConfig, allSeeds, currentLastDraw);
        if (rr.seedsConsumed === 0) break;

        debugLog.push({ step: `Roll ${i + 1}${i === 0 && forceNoRerollFirst ? ' (Avoided)' : ''}`, ...rr.debug });
        normalRollsResults.push(rr);
        
        seedCursor += rr.seedsConsumed;
        currentLastDraw = { 
            originalIdAbove: rr.charId, 
            finalIdSource: rr.charId, 
            rarity: rr.rarity, 
            charId: rr.charId 
        };
    }

    const gr = rollGuaranteedUber(seedCursor, gachaConfig, allSeeds);
    debugLog.push({ step: `Guaranteed Uber`, ...gr.debug });

    return { 
        name: gr.finalChar.name, charId: gr.charId, nextRollStartSeedIndex: seedCursor + 1, 
        normalRollsResults, debugLog, isAvoidedRoute: forceNoRerollFirst 
    };
}

====================
FILE: logic_uber.js
====================
/** @file logic_uber.js @description 確定枠抽選ロジック */
function rollGuaranteedUber(startIndex, gachaConfig, seeds) {
    if (startIndex >= seeds.length) {
        return { seedsConsumed: 1, finalChar: { name: "データ不足", id: null } };
    }
    const pool = gachaConfig.pool['uber'] || [];
    if (pool.length === 0) {
        return { seedsConsumed: 1, finalChar: { name: "該当なし", id: null } };
    }
    
    const seedValue = seeds[startIndex];
    const charIndex = seedValue % pool.length;
    const character = pool[charIndex];

    return { 
        seedsConsumed: 1, 
        finalChar: character, 
        charId: character.id,
        debug: { startIndex, seedValue, totalChars: pool.length, charIndex, finalChar: character }
    };
}

====================
FILE: logic_xorshift.js
====================
/** @file logic_xorshift.js @description 乱数生成（Xorshift32） */
class Xorshift32 {
    constructor(seed) {
        this.seed = (seed >>> 0) || 1;
    }
    next() {
        let x = this.seed;
        x ^= (x << 13);
        x ^= (x >>> 17);
        x ^= (x << 15);
        this.seed = x >>> 0;
        return this.seed;
    }
}

====================
FILE: main.js
====================
/** @file main.js @description アプリのエントリーポイント（初期化フロー統合版） */

/**
 * ==============================================================================
 * [R_Rolls] システム構成マップ (Refactored)
 * ==============================================================================
 * main.js --------------------> アプリ初期化
 * |
 * +-- view_description.js ----> 概要モードのHTML注入
 * +-- data_loader.js ---------> マスタデータ読み込み
 * +-- url_manager.js ---------> URLパラメータ解析
 * +-- ui_mode_logic.js --------> デフォルトガチャ設定
 * +-- ui_schedule_handler.js --> スケジュールUI準備
 * +-- ui_mode_logic.js --------> 初回描画実行 (onModeChange)
 * ==============================================================================
 */

window.onload = async function() {
    console.log("Initializing R_Rolls...");

    // 1. 概要モード（使い方ガイド）の初期化
    // データ読み込み中にユーザーが読めるよう、最優先で実行します
    if (typeof initDescriptionView === 'function') {
        try {
            initDescriptionView();
            console.log("Description view initialized.");
        } catch (e) {
            console.error("Description View Error:", e);
        }
    } else {
        console.warn("view_description.js is not loaded yet.");
    }

    // 2. 外部データの読み込み (data_loader.js)
    // CSV/TSV等の重いデータを非同期で取得します
    try {
        const success = await loadAllData();
        if (!success) {
            console.error("Data loading failed.");
            alert("データの読み込みに失敗しました。ページを再読み込みしてください。");
            return;
        }
        console.log("Master data loaded successfully.");
    } catch (e) {
        console.error("Fatal Data Error:", e);
        return;
    }

    // 3. アプリケーション状態の初期化
    // URLからの設定復元、デフォルトガチャの配置などを行います
    try {
        // URLパラメータの処理 (url_manager.js)
        if (typeof processUrlParams === 'function') {
            processUrlParams();
        }

        // デフォルトガチャの初期化 (ui_mode_logic.js)
        if (typeof initializeDefaultGachas === 'function') {
            initializeDefaultGachas();
        }

        // スケジュールUIの準備 (ui_schedule_handler.js)
        if (typeof setupScheduleUI === 'function') {
            setupScheduleUI();
        }

        // 4. 初回描画の実行
        // 全ての準備が整った後、画面を更新します
        if (typeof onModeChange === 'function') {
            onModeChange();
        }

        console.log("Application fully initialized.");

    } catch (e) {
        console.error("Initialization Flow Error:", e);
    }
};

/**
 * 補助：ブラウザのコンソールで状態を確認するためのデバッグ用関数
 */
window.getAppStatus = function() {
    return {
        seed: document.getElementById('seed')?.value,
        rolls: typeof currentRolls !== 'undefined' ? currentRolls : null,
        mode: typeof isSimulationMode !== 'undefined' ? (isSimulationMode ? "Sim" : "View") : "Unknown",
        gachas: typeof tableGachaIds !== 'undefined' ? tableGachaIds : []
    };
};

====================
FILE: schedule_logic.js
====================
/** @file schedule_logic.js @description gatya.tsvの解析、日付・時刻計算のユーティリティを担当 @dependency なし */

// YYYYMMDD -> M/D (年は無視、20300101は「永続」)
function formatDateJP(dateStr) {
    if (!dateStr || dateStr.length < 8) return dateStr;
    if (dateStr === '20300101') {
        return '永続';
    }
    const m = parseInt(dateStr.substring(4, 6), 10);
    const d = parseInt(dateStr.substring(6, 8), 10);
    return `${m}/${d}`;
}

// HHMM -> HH:MM
function formatTime(timeStr) {
    if (!timeStr) return "00:00";
    let s = timeStr.toString().padStart(4, '0');
    return `${s.substring(0, 2)}:${s.substring(2, 4)}`;
}

// YYYYMMDD -> Dateオブジェクト (00:00:00)
function parseDateStr(dateStr) {
    if (!dateStr || dateStr.length < 8) return new Date();
    const y = parseInt(dateStr.substring(0, 4), 10);
    const m = parseInt(dateStr.substring(4, 6), 10) - 1;
    const d = parseInt(dateStr.substring(6, 8), 10);
    return new Date(y, m, d);
}

// YYYYMMDD, HHMM -> Dateオブジェクト
function parseDateTime(dateStr, timeStr) {
    const d = parseDateStr(dateStr);
    if (timeStr) {
        let s = timeStr.toString().padStart(4, '0');
        const h = parseInt(s.substring(0, 2), 10);
        const min = parseInt(s.substring(2, 4), 10);
        d.setHours(h, min, 0, 0);
    }
    return d;
}

// Date -> YYYYMMDD 数値
function getDateInt(dateObj) {
    const y = dateObj.getFullYear();
    const m = String(dateObj.getMonth() + 1).padStart(2, '0');
    const d = String(dateObj.getDate()).padStart(2, '0');
    return parseInt(`${y}${m}${d}`, 10);
}

// Date -> M/D 文字列
function getShortDateStr(dateObj) {
    return `${dateObj.getMonth() + 1}/${dateObj.getDate()}`;
}

// プラチナ・レジェンド判定
function isPlatinumOrLegend(item) {
    const name = (item.seriesName + (item.tsvName || "")).replace(/\s/g, "");
    return name.includes("プラチナガチャ") || name.includes("レジェンドガチャ");
}

// TSVデータのパース処理
function parseGachaTSV(tsv) {
    const lines = tsv.split('\n');
    const schedule = [];
    lines.forEach(line => {
        if (line.trim().startsWith('[') || !line.trim()) return;
        const cols = line.split('\t');
        if (cols.length < 10) return;
        if (cols[8] !== '1') return;

        const startDateStr = cols[0]; 
        const startTimeStr = cols[1]; 
        const endDateStr   = cols[2]; 
        const endTimeStr   = cols[3]; 

        let validBlockIndex = -1;
        for (let i = 10; i < cols.length; i += 15) {
            const descIndex = i + 14;
            if (descIndex >= cols.length) break;
            const desc = cols[descIndex];
            if (desc && desc !== '0' && /[^\x01-\x7E]/.test(desc)) {
                validBlockIndex = i;
                break; 
            }
        }
        if (validBlockIndex === -1) {
            if (cols[10] && cols[10] !== '-1') {
                validBlockIndex = 10;
            } else {
                return;
            }
        }

        const base = validBlockIndex;
        const gachaId = cols[base];
        const rateRare = cols[base + 6];
        const rateSupa = cols[base + 8]; 
        const rateUber = cols[base + 10]; 
        const guarFlag = cols[base + 11];
        const rateLegend = cols[base + 12]; 
        const detail = cols[base + 14];
        const guaranteed = (guarFlag === '1' || parseInt(guarFlag) > 0);

        let seriesName = "";
        let tsvName = detail || "";
        if (typeof gachaMasterData !== 'undefined' && gachaMasterData.gachas[gachaId]) {
            seriesName = gachaMasterData.gachas[gachaId].name;
        } else {
            seriesName = `ID:${gachaId}`;
        }

        schedule.push({
            id: gachaId,
            start: startDateStr,
            end: endDateStr,
            rawStart: startDateStr,
            rawEnd: endDateStr,
            startTime: startTimeStr,
            endTime: endTimeStr,
            seriesName: seriesName,
            tsvName: tsvName,
            rare: rateRare,
            supa: rateSupa,
            uber: rateUber,
            legend: rateLegend,
            guaranteed: guaranteed
        });
    });

    // --- 重複期間の自動短縮ロジック（ID一致なら確定・非確定問わず適用） ---
    for (let i = 0; i < schedule.length; i++) {
        const itemA = schedule[i];
        const startA = parseInt(itemA.start);
        const endA = parseInt(itemA.end);

        // 同じIDで、自分より「後に開始」し、かつ自分の「終了前」に開始される別枠を探す
        const itemB = schedule.find(target => 
            target !== itemA &&
            target.id === itemA.id && 
            parseInt(target.start) > startA && 
            parseInt(target.start) < endA
        );

        if (itemB) {
            // 後続枠の開始タイミングに合わせて、前の枠を終了させる
            itemA.end = itemB.start;
            itemA.rawEnd = itemB.rawStart;
            itemA.endTime = itemB.startTime;
        }
    }

    schedule.sort((a, b) => parseInt(a.start) - parseInt(b.start));
    return schedule;
}

function findDefaultGachaState(data) {
    const now = new Date();
    let candidates = data.filter(item => {
        if (isPlatinumOrLegend(item)) return false;
        const endDt = parseDateTime(item.rawEnd, item.endTime);
        return endDt >= now;
    });
    candidates.sort((a, b) => {
        const startA = parseDateTime(a.rawStart, a.startTime);
        const startB = parseDateTime(b.rawStart, b.startTime);
        return startA - startB;
    });
    if (candidates.length === 0) return null;
    const target = candidates[0];
    const recommendedRollType = target.guaranteed ? '11g' : '11';
    return {
        gacha: target,
        gachaId: target.id,
        rollType: recommendedRollType
    };
}

====================
FILE: sim_config_helpers.js
====================
/** @file sim_config_helpers.js @description Config文字列の解析・生成ヘルパー */

/** Config文字列をオブジェクト配列に変換 */
function parseSimConfig(configStr) {
    if (!configStr || configStr.trim() === "") return [];
    
    const parts = configStr.split("-");
    const segments = [];

    // Process in pairs
    for (let i = 0; i < parts.length; i += 2) {
        if (i + 1 < parts.length) {
            const id = parts[i];
            const val = parts[i+1];

            if (!id || !val) continue;

            const gMatch = val.match(/[gfs]$/);
            const rolls = parseInt(val, 10);

            if (isNaN(rolls)) continue;

            segments.push({
                id: id,
                rolls: rolls,
                g: !!gMatch,
                suffix: gMatch ? gMatch[0] : ""
            });
        }
    }
    return segments;
}

/** オブジェクト配列をConfig文字列に変換 */
function stringifySimConfig(segments) {
    if (!segments || segments.length === 0) return "";
    
    const parts = segments.flatMap(s => {
        const id = String(s.id).replace(/[gfs]$/, '');
        let rollStr = String(s.rolls);
        if (s.g) {
            rollStr += (s.suffix || 'g');
        }
        return [id, rollStr];
    });

    return parts.join("-");
}

/** 最後のロール回数を1増やす [cite: 236-239] */
function incrementLastRoll(configStr) {
    if (!configStr) return null;
    const configs = parseSimConfig(configStr);
    if (configs.length > 0) {
        const last = configs[configs.length - 1];
        if (!last.g) { 
            last.rolls += 1;
        } else {
            configs.push({ id: last.id, rolls: 1, g: false });
        }
    }
    return stringifySimConfig(configs);
}

/** 最後のロールを1減らす、またはセグメントを削除 [cite: 240-243] */
function decrementLastRollOrRemoveSegment(configStr) {
    if (!configStr) return null;
    const configs = parseSimConfig(configStr);
    if (configs.length > 0) {
        const last = configs[configs.length - 1];
        if (last.rolls > 1 && !last.g) {
            last.rolls -= 1;
        } else {
            configs.pop();
        }
    }
    return stringifySimConfig(configs);
}

/** 最後のConfigセグメントを削除 [cite: 244-245] */
function removeLastConfigSegment(configStr) {
    if (!configStr) return "";
    const configs = parseSimConfig(configStr);
    if (configs.length > 0) {
        configs.pop();
    }
    return stringifySimConfig(configs);
}

/** 確定枠設定の生成 [cite: 246-250] */
function generateGuaranteedConfig(configStr, gachaId) {
    if (!configStr) return null;
    const parsed = parseSimConfig(configStr);
    if (parsed.length === 0) return null;
    
    const lastPart = parsed.pop();
    if (!lastPart.g && lastPart.rolls > 0) { 
        const newRollsForLastPart = Math.max(0, lastPart.rolls - 1);
        if (newRollsForLastPart > 0) {
            lastPart.rolls = newRollsForLastPart;
            parsed.push(lastPart);
        }
        parsed.push({ id: gachaId, rolls: 11, g: true });
        return stringifySimConfig(parsed);
    }
    return null;
}

====================
FILE: sim_engine.js
====================
/** @file sim_engine.js @description 経路探索の統合制御・インターフェース */

/**
 * 経路探索エントリポイント
 * 指定されたセル（targetSeedIndex）までの最短または最適な経路を計算します。
 */
function calculateRouteToCell(targetSeedIndex, targetGachaId, visibleGachaIds, currentConfigStr, finalActionOverride = null, primaryTargetId = null) {
    const simSeeds = generateSeedsForSim(targetSeedIndex);
    // 現在のルート設定を考慮した、有効な開始地点を計算
    const { startIdx, initialLastDraw, baseConfigStr } = calculateInitialState(currentConfigStr, targetSeedIndex, simSeeds);
    
    // 現在テーブルに表示されている（利用可能な）ガチャ設定のリストを作成
    const usableConfigs = visibleGachaIds.map(idStr => {
        const id = idStr.replace(/[gfs]$/, '');
        const config = gachaMasterData.gachas[id] || null;
        if (config) config._fullId = idStr;
        return config;
    }).filter(c => c !== null);
    
    if (usableConfigs.length === 0) return null;

    // UIのMax設定（プラチナチケット・確定枠の使用回数上限）を取得
    const maxPlat = parseInt(document.getElementById('sim-max-plat')?.value || 0, 10);
    const maxGuar = parseInt(document.getElementById('sim-max-guar')?.value || 0, 10);
    
    // ビームサーチの実行（段階的に制限を緩和して探索）
    let route = findPathBeamSearch(startIdx, targetSeedIndex, targetGachaId, usableConfigs, simSeeds, initialLastDraw, primaryTargetId, 0, 0);
    if (!route && maxGuar > 0) route = findPathBeamSearch(startIdx, targetSeedIndex, targetGachaId, usableConfigs, simSeeds, initialLastDraw, primaryTargetId, 0, maxGuar);
    if (!route && maxPlat > 0) route = findPathBeamSearch(startIdx, targetSeedIndex, targetGachaId, usableConfigs, simSeeds, initialLastDraw, primaryTargetId, maxPlat, maxGuar);
    
    if (route) {
        // 探索成功時、目的のセルでのアクションを追加して経路を完結させる
        if (finalActionOverride) {
            route.push(finalActionOverride);
        } else {
            // 通常セルの場合は1回引くアクション。表示上の整合性のために fullId を保持
            const baseId = targetGachaId.replace(/[gfs]$/, "");
            route.push({ id: baseId, rolls: 1, fullId: targetGachaId, g: false });
        }
        // 固定済みルートと新ルートを結合し、重複を圧縮して返す
        return (baseConfigStr ? baseConfigStr + " " : "") + compressRoute(route);
    }
    return null;
}

/**
 * 探索用の乱数シード配列を生成
 */
function generateSeedsForSim(targetSeedIndex) {
    const seedEl = document.getElementById('seed');
    const initialSeed = parseInt(seedEl ? seedEl.value : 12345);
    const rng = new Xorshift32(initialSeed);
    const tempSeeds = [];
    // 探索ターゲットよりも余裕を持たせた長さのシード配列を確保
    const limit = Math.max(targetSeedIndex, 1000) + 500;
    for (let i = 0; i < limit; i++) tempSeeds.push(rng.next());
    return tempSeeds;
}

/**
 * 現在のルート入力値（sim-config）から、探索を開始すべき正確なインデックスと直前状態を算出
 */
function calculateInitialState(currentConfigStr, targetSeedIndex, simSeeds) {
    let startIdx = 0, initialLastDraw = null, validConfigParts = [];
    if (currentConfigStr && currentConfigStr.trim() !== "") {
        const existingConfigs = parseSimConfig(currentConfigStr);
        let tempIdx = 0, tempLastDraw = null;
        for (const segment of existingConfigs) {
            // 単一セグメントをシミュレートして到達地点を確認
            const res = simulateSingleSegment(segment, tempIdx, tempLastDraw, simSeeds);
            // 目的のセルを追い越してしまう設定は無視（クリックしたセルへ再計算するため）
            if (res.nextIndex > targetSeedIndex) break;
            
            validConfigParts.push(segment);
            tempIdx = res.nextIndex; 
            tempLastDraw = res.lastDraw;
            
            // 既に目的地に到達している場合はそこで停止
            if (tempIdx === targetSeedIndex) break;
        }
        startIdx = tempIdx; 
        initialLastDraw = tempLastDraw;
    }
    // 圧縮された既存ルートの文字列と、そこからの開始状態を返す
    return { startIdx, initialLastDraw, baseConfigStr: stringifySimConfig(validConfigParts) };
}

====================
FILE: sim_engine_config.js
====================
/** @file sim_engine_config.js @description 経路探索の統合制御（ターゲット精度・トラック同期補正版） */

/**
 * 経路探索エントリポイント
 * 指定されたセル（targetSeedIndex）まで、トラック（A/B）を違えずに到達する最短経路を計算します。
 */
function calculateRouteToCell(targetSeedIndex, targetGachaId, visibleGachaIds, currentConfigStr, finalActionOverride = null, primaryTargetId = null) {
    // 1. 必要なSEED数を正確に見積もる
    // レア被り（消費+1）が連続しても不足しないよう、ターゲットの約1.5倍以上のバッファを確保
    const estimatedNeededSeeds = Math.max(targetSeedIndex, 1000) + 500;
    const simSeeds = generateSeedsForSim(estimatedNeededSeeds);

    // 2. 現在の入力から「ターゲットを超えない範囲」で有効な既設ルートを抽出
    const { startIdx, initialLastDraw, baseSegments } = calculateInitialState(currentConfigStr, targetSeedIndex, simSeeds);

    // 3. 利用可能なガチャ設定のリストを作成
    const usableConfigs = visibleGachaIds.map(idStr => {
        const id = idStr.replace(/[gfs]$/, '');
        const config = gachaMasterData.gachas[id] || null;
        if (config) config._fullId = idStr;
        return config;
    }).filter(c => c !== null);

    if (usableConfigs.length === 0) return null;

    // 探索設定（UIから上限取得）
    const maxPlat = parseInt(document.getElementById('sim-max-plat')?.value || 0, 10);
    const maxGuar = parseInt(document.getElementById('sim-max-guar')?.value || 0, 10);

    // 4. ビームサーチの実行（段階的に制限を緩和して探索）
    let route = findPathBeamSearch(startIdx, targetSeedIndex, targetGachaId, usableConfigs, simSeeds, initialLastDraw, primaryTargetId, 0, 0);
    
    if (!route && maxGuar > 0) {
        route = findPathBeamSearch(startIdx, targetSeedIndex, targetGachaId, usableConfigs, simSeeds, initialLastDraw, primaryTargetId, 0, maxGuar);
    }
    if (!route && maxPlat > 0) {
        route = findPathBeamSearch(startIdx, targetSeedIndex, targetGachaId, usableConfigs, simSeeds, initialLastDraw, primaryTargetId, maxPlat, maxGuar);
    }
    
    // 5. 経路の構築と最終調整
    if (route) {
        if (finalActionOverride) {
            route.push(finalActionOverride);
        }

        // 既設ルートと探索ルートを結合
        const fullRoute = [...baseSegments, ...route];

        // 6. ターゲット行数と一致させるための最終補正ロジック
        // クリックされたのが「確定枠（G列）」でない場合のみ適用
        if (!finalActionOverride) {
            // ターゲットの物理的な行番号 (1, 2, 3...)
            const targetRow = Math.floor(targetSeedIndex / 2) + 1;
            
            // 現在のルートでの総ロール数を計算
            let calculatedRolls = 0;
            fullRoute.forEach(segment => {
                calculatedRolls += segment.rolls;
            });
            
            // ターゲット行数との差分を計算
            const difference = targetRow - calculatedRolls;

            if (fullRoute.length > 0) {
                // 最後のセグメントのロール数を調整して、ターゲット行にピッタリ合わせる
                if (difference !== 0) {
                    fullRoute[fullRoute.length - 1].rolls += difference;
                    
                    // 調整の結果、ロール数が0以下になったセグメントは削除
                    if (fullRoute[fullRoute.length - 1].rolls <= 0) {
                        fullRoute.pop();
                    }
                }
            } else {
                // ルートが空（現在地がターゲット）の場合
                if (targetRow > 0) {
                    const baseId = targetGachaId.replace(/[gfs]$/, "");
                    fullRoute.push({ id: baseId, rolls: targetRow, g: false, fullId: targetGachaId });
                }
            }
        }
        
        // 重複セグメントを圧縮して文字列で返す
        return compressRoute(fullRoute);
    }
    
    return null;
}

/**
 * 探索用の乱数シード配列を生成
 */
function generateSeedsForSim(targetSeedIndex) {
    const seedEl = document.getElementById('seed');
    const initialSeed = parseInt(seedEl ? seedEl.value : 12345, 10);
    const rng = new Xorshift32(initialSeed);
    const tempSeeds = [];
    
    // ターゲットよりも余裕を持たせた長さを確保
    const limit = Math.max(targetSeedIndex, 1000) + 500;
    for (let i = 0; i < limit; i++) {
        tempSeeds.push(rng.next());
    }
    return tempSeeds;
}

/**
 * 現在のルート入力値（sim-config）を解析し、探索を開始すべき正確な地点を算出
 */
function calculateInitialState(currentConfigStr, targetSeedIndex, simSeeds) {
    let startIdx = 0;
    let initialLastDraw = null;
    let validConfigParts = [];

    if (currentConfigStr && currentConfigStr.trim() !== "") {
        const existingConfigs = parseSimConfig(currentConfigStr);
        let tempIdx = 0;
        let tempLastDraw = null;

        for (const segment of existingConfigs) {
            // 単一セグメントをシミュレートして到達地点を確認
            const res = simulateSingleSegment(segment, tempIdx, tempLastDraw, simSeeds);
            
            // 重要：目的のセル（クリック箇所）を追い越してしまう設定は、
            // 新規クリックによる再計算のために除外する
            if (res.nextIndex > targetSeedIndex) break;
            
            validConfigParts.push(segment);
            tempIdx = res.nextIndex; 
            tempLastDraw = res.lastDraw;
            
            // 目的地にピッタリ到達している場合はそこで停止
            if (tempIdx === targetSeedIndex) break;
        }
        startIdx = tempIdx;
        initialLastDraw = tempLastDraw;
    }
    
    return { 
        startIdx, 
        initialLastDraw, 
        baseSegments: validConfigParts 
    };
}

====================
FILE: sim_engine_core.js
====================
/** @file sim_engine_core.js @description 経路探索用の単一セグメント計算（トラック遷移整合性・物理配置同期強化版） */

/**
 * 単一のガチャセグメント（例：ガチャID:123で5回回す）をシミュレートする
 * トラック遷移（レア被り）を考慮し、最終的なインデックスと直前の状態を返します。
 */
function simulateSingleSegment(segment, startIdx, initialStates, seeds) {
    let currentIdx = startIdx;
    const config = gachaMasterData.gachas[segment.id];
    
    // 状態管理オブジェクトの初期化
    // initialStates が A/B 両方の状態を持っていることを想定
    let trackStates = initialStates ? { ...initialStates } : {
        lastA: null,
        lastB: null,
        lastAction: null // 最後に実行されたロールの結果
    };

    if (!config) return { nextIndex: currentIdx, trackStates: trackStates };

    let rollsToPerform = segment.rolls;
    let isGuaranteed = false;

    // 確定枠（11G/15G/7G等）の判定と、通常枠としての計算回数の調整
    if (segment.g) {
        if (segment.rolls === 15) { rollsToPerform = 14; isGuaranteed = true; }
        else if (segment.rolls === 7) { rollsToPerform = 6; isGuaranteed = true; }
        else if (segment.rolls === 11) { rollsToPerform = 10; isGuaranteed = true; }
        else { rollsToPerform = Math.max(0, segment.rolls - 1); isGuaranteed = true; }
    }

    // 通常枠のシミュレーション実行
    for (let i = 0; i < rollsToPerform; i++) {
        if (currentIdx >= seeds.length) break;
        
        const isTrackB = (currentIdx % 2 !== 0);
        
        // 物理的な「直上のセル」の情報を取得
        // そのトラック（A or B）で最後に排出されたキャラが、テーブル上の物理的な直上となる
        const drawAbove = isTrackB ? trackStates.lastB : trackStates.lastA;

        // 判定コンテキストの構築
        // originalIdAbove: テーブル上の物理的な直上ID（物理チェック用）
        // finalIdSource: 直前のロール（遷移元）で実際に排出されたID（遷移チェック用）
        const drawContext = {
            originalIdAbove: drawAbove ? String(drawAbove.charId) : null,
            finalIdSource: trackStates.lastAction ? String(trackStates.lastAction.charId) : null
        };

        // ロールの実行（ロジック層の rollWithSeedConsumptionFixed を使用）
        const rr = rollWithSeedConsumptionFixed(currentIdx, config, seeds, drawContext);
        if (rr.seedsConsumed === 0) break;

        // 状態の更新
        const result = {
            rarity: rr.rarity,
            charId: rr.charId,
            originalCharId: rr.originalChar ? String(rr.originalChar.id) : String(rr.charId),
            trackB: isTrackB
        };

        // 物理トラック履歴と最後のアクションを更新
        if (isTrackB) {
            trackStates.lastB = result;
        } else {
            trackStates.lastA = result;
        }
        trackStates.lastAction = result;

        currentIdx += rr.seedsConsumed;
    }

    // 確定枠がある場合の最後の1枠の処理
    if (isGuaranteed && currentIdx < seeds.length) {
        const isTrackB = (currentIdx % 2 !== 0);
        const gr = rollGuaranteedUber(currentIdx, config, seeds);
        
        const result = { 
            rarity: 'uber', 
            charId: gr.charId, 
            originalCharId: gr.charId,
            trackB: isTrackB
        };

        if (isTrackB) {
            trackStates.lastB = result;
        } else {
            trackStates.lastA = result;
        }
        trackStates.lastAction = result;

        currentIdx += gr.seedsConsumed;
    }

    return { nextIndex: currentIdx, trackStates: trackStates };
}

/**
 * ルート配列を文字列（sim-config形式）に圧縮・変換する
 * （連続した同一ガチャのロールをまとめる）
 */
function compressRoute(route) {
    if (!route || route.length === 0) return "";
    const segments = [];
    let current = null;

    for (const step of route) {
        // 同じガチャID、かつ確定枠フラグが一致する場合は回数を合算
        // ただし、確定枠(g)の場合は合算せず個別のセグメントとして保持
        if (current && current.id === step.id && current.g === step.g && !step.g) {
            current.rolls += step.rolls;
        } else {
            if (current) segments.push(current);
            current = { ...step };
        }
    }
    if (current) segments.push(current);

    return stringifySimConfig(segments);
}

====================
FILE: sim_engine_search.js
====================
/** @file sim_engine_search.js @description ビームサーチによる経路探索アルゴリズム（ターゲット精度・トラック同期強化版） */

/**
 * ビームサーチ本体
 * 各ステップで上位候補を保持しつつ、ターゲットのインデックスとトラックに正確に到達する経路を探します。
 */
function findPathBeamSearch(startIdx, targetIdx, targetGachaId, configs, simSeeds, initialLastDraw, primaryTargetId, maxPlat, maxGuar) {
    const BEAM_WIDTH = 25; 
    const MAX_STEPS = 3000; // 探索ステップ上限を少し引き上げ
    
    // ターゲットガチャを優先的に評価するためソート
    const sortedConfigs = [...configs].sort((a, b) => (a._fullId == targetGachaId ? -1 : 1));
    
    // 探索候補の初期化
    // idx: 現在のSEEDインデックス, path: 経路, lastDraw: 直前の描画情報, score: 評価値
    let candidates = [{ 
        idx: startIdx, 
        path: [], 
        lastDraw: initialLastDraw, 
        score: 0, 
        platUsed: 0, 
        guarUsed: 0 
    }];
    
    let loopCount = 0;

    while (candidates.length > 0 && loopCount < MAX_STEPS) {
        loopCount++;
        let nextCandidates = [];

        for (const current of candidates) {
            // ターゲットインデックスに到達したかチェック
            if (current.idx === targetIdx) {
                // インデックスが一致＝トラック(A/B)も一致しているため、ここで確定
                return current.path;
            }

            // 次の候補を展開
            const expanded = expandCandidates(current, targetIdx, targetGachaId, sortedConfigs, simSeeds, maxPlat, maxGuar, primaryTargetId);
            nextCandidates.push(...expanded);
        }

        if (nextCandidates.length === 0) break;

        // 評価スコア順にソート
        nextCandidates.sort((a, b) => b.score - a.score);
        
        // 同一状態（インデックス、最終キャラ、使用リソース）の重複を除去
        const uniqueCandidates = filterUniqueCandidates(nextCandidates);
        
        // ビーム幅内で、トラックA（偶数）とトラックB（奇数）の候補をバランスよく保持する
        // これにより、一方のトラックが有利に見える場合でも、もう一方のトラックからのルートを切り捨てずに探索できる
        const trackA = uniqueCandidates.filter(c => c.idx % 2 === 0);
        const trackB = uniqueCandidates.filter(c => c.idx % 2 !== 0);
        
        const halfBeam = Math.ceil(BEAM_WIDTH / 2);
        const bestA = trackA.slice(0, halfBeam);
        const bestB = trackB.slice(0, halfBeam);
        
        candidates = [...bestA, ...bestB].sort((a, b) => b.score - a.score).slice(0, BEAM_WIDTH);
    }
    
    return null; // ルートが見つからなかった場合
}

/**
 * 候補展開処理
 * 現在の状態から、各ガチャを「1回引く」または「確定11連を引く」アクションを試行します。
 */
function expandCandidates(current, targetIdx, targetGachaId, sortedConfigs, simSeeds, maxPlat, maxGuar, primaryTargetId) {
    const results = [];
    const dist = targetIdx - current.idx;
    
    // すでにターゲットを追い越している場合は展開しない
    if (dist < 0) return results;
    
    const lastGachaId = current.path.length > 0 ? current.path[current.path.length - 1].id : null;

    for (const conf of sortedConfigs) {
        const isPlat = conf.name.includes('プラチナ') || conf.name.includes('レジェンド');
        const isG = conf._fullId.endsWith("g");

        // 1. 通常ロール（1回）の試行
        if (!isPlat || current.platUsed < maxPlat) {
            // 物理的な「直上のセル」のキャラIDを取得（レア被り判定に必須）
            // テーブル上では index - 2 の位置にあるキャラ
            let originalIdAbove = null;
            if (current.idx >= 2) {
                // シミュレーション用シードを用いて、該当ガチャでの物理的な直上キャラを算出
                const s0_above = simSeeds[current.idx - 2];
                const s1_above = simSeeds[current.idx - 1];
                const rarityAbove = determineRarity(s0_above, conf.rarity_rates);
                const poolAbove = conf.pool[rarityAbove] || [];
                if (poolAbove.length > 0) {
                    originalIdAbove = String(poolAbove[s1_above % poolAbove.length].id);
                }
            }

            const drawContext = {
                originalIdAbove: originalIdAbove,
                finalIdSource: current.lastDraw ? String(current.lastDraw.charId) : null
            };

            // 実際のガチャ計算ロジックを実行
            const res = rollWithSeedConsumptionFixed(current.idx, conf, simSeeds, drawContext);
            
            // 到達先がターゲットを超えないか確認
            if (current.idx + res.seedsConsumed <= targetIdx) {
                const newDraw = { 
                    rarity: res.rarity, 
                    charId: res.charId, 
                    originalCharId: res.originalChar ? String(res.originalChar.id) : String(res.charId)
                };

                results.push({ 
                    idx: current.idx + res.seedsConsumed, 
                    path: [...current.path, { id: conf.id, rolls: 1, g: false, fullId: conf._fullId }], 
                    lastDraw: newDraw, 
                    score: calculateScore(current.score, res, dist, targetIdx, primaryTargetId, conf.id, lastGachaId, targetGachaId, current.lastDraw), 
                    platUsed: isPlat ? current.platUsed + 1 : current.platUsed, 
                    guarUsed: current.guarUsed 
                });
            }
        }

        // 2. 超激確定ロール（11連等）の試行
        if (!isPlat && current.guarUsed < maxGuar && isG) {
            // 確定枠シミュレーション（内部で全ロールをシミュレートしてトラック遷移を確認する）
            const res = simulateSingleSegment({id: conf.id, rolls: 11, g: true}, current.idx, current.lastDraw, simSeeds);
            
            // 確定枠を引いた後のインデックスがターゲットを超えないか、またはターゲットそのものか
            if (res.nextIndex <= targetIdx) {
                results.push({ 
                    idx: res.nextIndex, 
                    path: [...current.path, { id: conf.id, rolls: 11, g: true, fullId: conf._fullId }], 
                    lastDraw: res.lastDraw, 
                    score: current.score - 500, // 確定枠使用はスコアを下げて、可能な限り温存するルートを優先
                    platUsed: current.platUsed, 
                    guarUsed: current.guarUsed + 1 
                });
            }
        }
    }
    return results;
}

/**
 * 同一状態の候補をフィルタリングして探索効率を上げます。
 */
function filterUniqueCandidates(candidates) {
    const unique = [];
    const seen = new Set();
    for (const c of candidates) {
        // インデックス、排出キャラID、リソース使用状況をキーにする
        const key = `${c.idx}-${c.lastDraw?.charId}-${c.platUsed}-${c.guarUsed}`;
        if (!seen.has(key)) { 
            seen.add(key); 
            unique.push(c); 
        }
    }
    return unique;
}

/**
 * 候補の評価スコアを計算します。
 */
function calculateScore(currentScore, res, dist, targetIdx, primaryTargetId, confId, lastGachaId, targetGachaId, lastDraw) {
    let s = currentScore;
    
    // 1. 同一ガチャ連続ボーナス
    // ガチャを頻繁に切り替えるより、同じガチャを回し続けるほうが現実的なため加点
    if (lastGachaId && confId === lastGachaId) {
        let wasLastDrawHighValue = false;
        if (lastDraw) {
            if (lastDraw.rarity === 'legend' || lastDraw.rarity === 'uber') wasLastDrawHighValue = true;
            if (primaryTargetId && String(lastDraw.charId) === String(primaryTargetId)) wasLastDrawHighValue = true;
            if (typeof limitedCats !== 'undefined' && limitedCats.includes(String(lastDraw.charId))) wasLastDrawHighValue = true;
        }
        // 高価値キャラの直後は、別のガチャへ切り替える機会を増やすためボーナスを抑える
        s += wasLastDrawHighValue ? 50 : 200;
    } 
    // ターゲットガチャ（クリックされた列）を優先
    else if (confId === targetGachaId.replace(/[gfs]$/, '')) {
        s += 100;
    }

    // 2. ターゲットキャラ発見ボーナス
    if (primaryTargetId && String(res.charId) === String(primaryTargetId)) {
        s += 2000;
    }

    // 3. レアリティ/限定キャラボーナス
    const charId = String(res.charId);
    if (typeof limitedCats !== 'undefined' && limitedCats.includes(charId)) {
        s += 500;
    }
    if (res.rarity === 'legend') {
        s += 1000;
    } else if (res.rarity === 'uber') {
        s += 200;
    }
    
    // 4. 進行度ボーナス（ターゲットに近づくほど加点）
    // 残り距離が短い候補を優先する
    const progressBonus = (1 - (targetIdx - (res.startIndex || 0)) / targetIdx) * 100;

    return s + res.seedsConsumed + progressBonus;
}

====================
FILE: sim_ui_logic.js
====================
/** @file sim_ui_logic.js @description UI表示用の回避・誘発判定ロジック */

/** セルに対応するConfigを取得 [cite: 251-254] */
function getBestLink(cellSimConfigs, seedIndex, gachaConfigs) {
    if (seedIndex < 0) return null;
    for (const config of gachaConfigs) {
        const configStr = cellSimConfigs.get(`${seedIndex}-${config.id}`);
        if (configStr !== undefined) {
            return configStr;
        }
    }
    return null;
}

/** 再抽選後のキャラ名を取得 [cite: 255-257] */
function getForcedRerollName(currentRoll, gachaConfig) {
    if (!currentRoll || !gachaConfig || currentRoll.rarity !== 'rare' || currentRoll.s2 === null) {
        return null;
    }
    const characterPool = gachaConfig.pool['rare'] || [];
    const uniqueRareChars = characterPool.filter(c => c.id !== currentRoll.originalChar.id);
    const uniqueTotal = uniqueRareChars.length;
    
    if (uniqueTotal > 0) {
        const reRollIndex = currentRoll.s2 % uniqueTotal;
        return uniqueRareChars[reRollIndex].name;
    }
    return null;
}

/** 回避・誘発判定 [cite: 258-276] */
function checkAvoidanceAndForcing(seedIndex, currentGachaId, tableData, gachaConfigs, cellSimConfigs, newRow1Index) {
    const i = Math.floor(seedIndex / 2);
    if (i < newRow1Index) return { link: null, rerollCharName: null };

    const gachaIndex = gachaConfigs.findIndex(c => c.id === currentGachaId);
    if (gachaIndex === -1 || !tableData[seedIndex] || !tableData[seedIndex][gachaIndex]) {
        return { link: null, rerollCharName: null };
    }

    const currentRoll = tableData[seedIndex][gachaIndex].roll;
    const isRerolled = currentRoll.isRerolled;
    const originalCharId = currentRoll.originalChar?.id;
    const originalRarity = currentRoll.rarity;
    if (originalRarity !== 'rare' || !originalCharId) return { link: null, rerollCharName: null };

    const prevIndicesToCheck = [seedIndex - 2, seedIndex - 3];
    for (const otherConfig of gachaConfigs) {
        const otherGachaId = otherConfig.id;
        if (otherGachaId === currentGachaId) continue;

        const otherIndex = gachaConfigs.findIndex(c => c.id === otherGachaId);
        if (otherIndex === -1) continue;
        
        const createAltConfig = (prevIndexUsed) => {
            const configStr = getBestLink(cellSimConfigs, prevIndexUsed, gachaConfigs);
            if (configStr === null) return null; 
            const parts = parseSimConfig(configStr);
            const last_part = parts.length > 0 ? parts[parts.length - 1] : null;
            if (last_part && last_part.id === otherGachaId && !last_part.g) {
                last_part.rolls += 1;
            } else {
                parts.push({ id: otherGachaId, rolls: 1, g: false });
            }
            return stringifySimConfig(parts);
        };

        for (const prevIndex of prevIndicesToCheck) {
            if (prevIndex < 0) continue;
            const otherRoll_prev = tableData[prevIndex]?.[otherIndex]?.roll;
            if (!otherRoll_prev) continue;

            if (isRerolled) {
                if (otherRoll_prev.rarity !== 'rare' || otherRoll_prev.charId !== originalCharId) { 
                    const altConfig = createAltConfig(prevIndex);
                    if (altConfig) return { link: altConfig, rerollCharName: null };
                }
            } else {
                if (otherRoll_prev.rarity === 'rare' && otherRoll_prev.charId === originalCharId) {
                    const altConfig = createAltConfig(prevIndex);
                    if (altConfig) {
                        const rerollCharName = getForcedRerollName(currentRoll, gachaConfigs[gachaIndex]);
                        return { link: altConfig, rerollCharName: rerollCharName };
                    }
                }
            }
        }
    }
    return { link: null, rerollCharName: null };
}

/** 誘発可能判定 [cite: 277-283] */
function canBeForced(seedIndex, currentGachaId, tableData, gachaConfigs) {
    const gachaIndex = gachaConfigs.findIndex(c => c.id === currentGachaId);
    if (gachaIndex === -1 || seedIndex < 1 || !tableData[seedIndex] || !tableData[seedIndex][gachaIndex]) return false;
    const currentRoll = tableData[seedIndex][gachaIndex].roll;
    const originalCharId = currentRoll.originalChar ? currentRoll.originalChar.id : null;
    if (!originalCharId) return false;
    const prevIndicesToCheck = [seedIndex - 2, seedIndex - 3];
    for (const prevIndex of prevIndicesToCheck) {
        if (prevIndex < 0) continue;
        for (const otherConfig of gachaConfigs) {
            const otherIndex = gachaConfigs.findIndex(c => c.id === otherConfig.id);
            if (otherIndex === -1) continue;
            const otherRoll_prev = tableData[prevIndex]?.[otherIndex]?.roll;
            if (otherRoll_prev && otherRoll_prev.rarity === 'rare' && otherRoll_prev.charId === originalCharId) {
                return true;
            }
        }
    }
    return false;
}

/** 回避可能判定 [cite: 284-290] */
function canBeAvoided(seedIndex, currentGachaId, tableData, gachaConfigs) {
    const gachaIndex = gachaConfigs.findIndex(c => c.id === currentGachaId);
    if (gachaIndex === -1 || seedIndex < 1 || !tableData[seedIndex] || !tableData[seedIndex][gachaIndex]) return false;
    const currentRoll = tableData[seedIndex][gachaIndex].roll;
    if (currentRoll.rarity !== 'rare' || !currentRoll.isRerolled || !currentRoll.originalChar) return false;
    const originalCharId = currentRoll.originalChar.id;
    const prevIndicesToCheck = [seedIndex - 2, seedIndex - 3];
    for (const prevIndex of prevIndicesToCheck) {
        if (prevIndex < 0) continue;
        for (const otherConfig of gachaConfigs) {
            const otherIndex = gachaConfigs.findIndex(c => c.id === otherConfig.id);
            if (otherIndex === -1) continue;
            const otherRoll_prev = tableData[prevIndex]?.[otherIndex]?.roll;
            if (otherRoll_prev && (otherRoll_prev.rarity !== 'rare' || otherRoll_prev.charId !== originalCharId)) {
                return true;
            }
        }
    }
    return false;
}

====================
FILE: sim_utils.js
====================
/** @file sim_utils.js @description シミュレーション結果の圧縮 */

/** 経路をConfig形式に圧縮 [cite: 356-361] */
function compressRoute(path) {
    if (!path || path.length === 0) return "";
    let compressed = [];
    let currentId = path[0].id;
    let isG = path[0].g || false;
    let count = path[0].rolls || 1;
    for (let i = 1; i < path.length; i++) {
        const step = path[i];
        const stepG = step.g || false;
        if (step.id === currentId && stepG === isG && !isG) {
            count += (step.rolls || 1);
        } else {
            compressed.push(`${currentId} ${count}${isG ? 'g' : ''}`);
            currentId = step.id;
            isG = stepG;
            count = step.rolls || 1;
        }
    }
    compressed.push(`${currentId} ${count}${isG ? 'g' : ''}`);
    return compressed.join(" ");
}

====================
FILE: style.css
====================
@charset "UTF-8";

/* =========================================
   基本設定
   ========================================= */
html, body { height: 100%; margin: 0; overflow: hidden; }
body { font-family: "Helvetica Neue", Arial, sans-serif; padding: 20px; box-sizing: border-box; color: #333; background-color: #fff; display: flex; flex-direction: column; }

.container { height: 100%; display: flex; flex-direction: column; overflow: hidden; }

.header-row, 
.controls, 
.description-box, 
#result, 
.forecast-summary-container { flex-shrink: 0; }

.header-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; flex-wrap: nowrap; gap: 10px; }
h1 { font-size: 20px; margin: 0; padding: 0; white-space: nowrap; }
.header-actions { display: flex; align-items: center; gap: 4px; flex-wrap: nowrap; }

.text-btn { cursor: pointer; color: #007bff; font-weight: bold; font-size: 0.9em; text-decoration: underline; white-space: nowrap; padding: 2px 4px; user-select: none; }
.text-btn:hover { color: #0056b3; background-color: #f0f8ff; border-radius: 3px; }
.text-btn.active { color: #28a745; text-decoration: none; border: 1px solid #28a745; border-radius: 3px; padding: 1px 3px; }
.separator { color: #ccc; font-size: 0.8em; margin: 0 2px; user-select: none; }

/* =========================================
   コントロールエリア
   ========================================= */
.controls { background: #f4f4f4; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
.control-group { margin-bottom: 10px; }
.control-group:last-child { margin-bottom: 0; }
label { margin-right: 10px; font-weight: bold; }
input[type="text"],
input[type="number"] { padding: 5px; border: 1px solid #ccc; border-radius: 4px; }

/* =========================================
   ボタン（通常）
   ========================================= */
button { cursor: pointer; padding: 6px 12px; background: #007bff; color: white; border: none; border-radius: 4px; font-size: 14px; }
button:hover { background: #0056b3; }
button.secondary { background: #6c757d; }
button.secondary:hover { background: #545b62; }
button.active { background: #28a745; }

/* =========================================
   ユーティリティ
   ========================================= */
.hidden { display: none !important; }
.description-box { background: #e9ecef; padding: 10px; border-radius: 4px; margin-bottom: 15px; font-size: 0.9em; }
.result-box { margin-bottom: 10px; font-weight: bold; color: #d9534f; }
.error { color: red; font-weight: bold; }

/* =========================================
   テーブルスタイル (Gacha Rolls)
   ========================================= */
#rolls-table-container { overflow-x: auto; overflow-y: auto; max-height: none; flex-grow: 1; border: 1px solid #ddd; margin-bottom: 0; }
table { border-collapse: separate; border-spacing: 0; width: 100%; margin-top: 0; font-size: 12px; }
th, td { border: 1px solid #ddd; padding: 6px; text-align: center; white-space: nowrap; }

th { background-color: #f8f9fa; font-weight: bold; border-top: 1px solid #ddd; border-bottom: 1px solid #ddd; box-shadow: 0 1px 0 #ddd; }
.sticky-row th { position: sticky; top: 0; z-index: 20; border-bottom: none; box-shadow: 0 2px 2px rgba(0,0,0,0.1); background-color: #f8f9fa; }
.control-row th { position: static; border-top: none; background-color: #f8f9fa; padding-top: 2px; padding-bottom: 4px; z-index: 1; }

.col-no { background-color: #f8f9fa; width: 30px; }
.calc-column { background-color: #f0f8ff; font-size: 0.9em; color: #555; }
.gacha-column { min-width: 120px; }
.gacha-cell { position: relative; }
.highlight { position: relative; }
.highlight-uber { font-weight: bold; color: #c2185b; }
.char-link:hover { color: #0056b3; }
.remove-btn { background: #dc3545; padding: 2px 6px; font-size: 10px; margin-left: 5px; }
.add-gacha-btn { background: #28a745; padding: 2px 8px; font-size: 11px; }
.uber-add-select { cursor: pointer; border: 1px solid #ccc; border-radius: 3px; background-color: #fff; }

/* =========================================
   スケジュール表 & ガントチャート共通
   ========================================= */
#schedule-container { padding: 20px; background-color: #fff; border-top: 1px solid #ddd; max-width: 100%; box-sizing: border-box; flex-grow: 1; overflow-y: auto; }
.schedule-scroll-wrapper { overflow-x: auto; max-height: none; border: 1px solid #ddd; max-width: 100%; }
.schedule-table { width: 100%; border-collapse: separate; border-spacing: 0; margin-top: 0; font-size: 14px; }
.schedule-table th,
.schedule-table td { border: 1px solid #ddd; padding: 8px; text-align: center; white-space: nowrap; }
.schedule-table td:nth-child(3) { white-space: normal; text-align: left; min-width: 250px; }
.schedule-table th { background-color: #eee; position: sticky; top: 0; z-index: 10; border-top: 1px solid #ddd; border-bottom: 1px solid #ccc; }
.row-ended { background-color: #e0e0e0 !important; color: #666; }
.row-ended .gantt-bar { filter: grayscale(100%); opacity: 0.6; }
.row-guaranteed { background-color: #ffffe0 !important; }

/* =========================================
   ガントチャート
   ========================================= */
.gantt-outer-wrapper * { box-sizing: border-box; }
.gantt-outer-wrapper { display: inline-block; max-width: 100%; vertical-align: top; width: 100%; }
.gantt-chart-container { border: 1px solid #ccc; background: #fff; font-size: 12px; margin-bottom: 20px; max-width: 100%; }
.gantt-scroll-wrapper { overflow-x: auto; position: relative; padding-bottom: 10px; width: 100%; }
.gantt-header { display: flex; border-bottom: 1px solid #ccc; background: #f9f9f9; position: sticky; left: 0; z-index: 6; }
.gantt-label-col { width: 160px; min-width: 160px; padding: 5px; border-right: 1px solid #ccc; background-color: inherit; position: sticky; left: 0; z-index: 5; display: flex; align-items: center; justify-content: center; font-weight: bold; border-bottom: 1px solid #eee; }
.gantt-header .gantt-label-col { background-color: #f9f9f9; }
.gantt-date-cell { border-right: 1px solid #eee; text-align: center; padding: 5px 0; font-size: 10px; flex-shrink: 0; }
.gantt-date-cell.today { background-color: #ffeb3b; }
.gantt-date-cell.weekend { background-color: #e0f7fa; }
.gantt-body { position: relative; }
.gantt-row { display: flex; border-bottom: 1px solid #eee; height: 30px; background-color: #fff; }
.gantt-row:hover { filter: brightness(0.95); }
.gantt-row .gantt-label-col { font-weight: normal; text-align: center; justify-content: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: block; line-height: 20px; }
.gantt-bar-area { position: relative; height: 100%; flex-grow: 1; }
.gantt-bar { position: absolute; top: 5px; height: 20px; background-color: #4caf50; border: 1px solid #4caf50; box-shadow: none; border-radius: 3px; color: #fff; font-size: 10px; display: flex; align-items: center; justify-content: center; overflow: hidden; white-space: nowrap; z-index: 2; }
.gantt-bar.g-kyoku { background-color: #e91e63; border-color: #e91e63; }
.gantt-bar.g-cho { background-color: #9c27b0; border-color: #9c27b0; }
.gantt-bar.g-fest { background-color: #ff9800; border-color: #ff9800; }
.gantt-bar.g-collab { background-color: #2196f3; border-color: #2196f3; }
.gantt-bar-text { padding: 0 4px; }
.gantt-grid-line { position: absolute; top: 0; bottom: 0; border-right: 1px solid #f5f5f5; z-index: 0; }
.gantt-grid-line.weekend { background-color: rgba(224, 247, 250, 0.3); }
.gantt-current-line { position: absolute; top: 0; bottom: 0; width: 2px; background-color: #ff0000; z-index: 1; opacity: 0.7; pointer-events: none; }

/* =========================================
   モバイル用・高密度表示レイアウト
   ========================================= */
@media (max-width: 768px) { 
 html, body { height: 100%; margin: 0; padding: 0 !important; overflow: hidden; }
 .container { height: 100%; display: flex; flex-direction: column; padding: 4px; box-sizing: border-box; }
 .header-row, .controls, .description-box, #result, .forecast-summary-container { flex-shrink: 0; }
 .header-row { flex-direction: row !important; flex-wrap: nowrap !important; overflow-x: auto; align-items: center; padding-bottom: 5px; border-bottom: 1px solid #eee; margin-bottom: 5px; white-space: nowrap; }
 h1 { font-size: 16px !important; margin-right: 8px; display: inline-block; }
 .header-actions { width: auto; flex-wrap: nowrap; gap: 4px; }
 .text-btn { font-size: 11px; padding: 2px 3px; }
 .header-actions button, .header-actions span:not(.text-btn):not(.separator) { font-size: 10px !important; padding: 2px 6px !important; height: 24px; line-height: 20px; }
 #rolls-table-container { flex-grow: 1; max-height: none !important; margin-bottom: 0 !important; overflow-y: auto; border-bottom: none; width: 100%; }
 #schedule-container { flex-grow: 1; overflow-y: auto; padding-bottom: 0; width: 100%; max-width: 100vw; box-sizing: border-box; } 
 .schedule-scroll-wrapper { max-height: none !important; width: 100%; }
 .controls { padding: 8px; margin-bottom: 5px; }
 .control-group { margin-bottom: 4px; display: flex; flex-wrap: wrap; align-items: center; }
 label { font-size: 10px; margin-right: 5px; }
 input[type="text"], input[type="number"], select { font-size: 11px; padding: 2px 4px; height: 24px; }
 #seed, #sim-config { max-width: 120px; }
 button { padding: 3px 8px; font-size: 11px; height: 24px; line-height: 1; }
 table { font-size: 10px; margin-top: 5px; }
 th, td { padding: 2px 3px; height: auto; }
 .gacha-column { min-width: 85px; max-width: 100px; overflow: hidden; }  
 .gacha-header-wrapper { gap: 2px; justify-content: flex-start !important; width: 100%; }
 th div[style*="margin-top"] { transform: scale(0.85); transform-origin: center top; width: 115%; margin-left: -7.5%; white-space: nowrap; }
 .gacha-cell { line-height: 1.1; }
 .calc-column { font-size: 9px; width: auto; }
 .schedule-table th, .schedule-table td { padding: 2px 4px; font-size: 10px; }  
 .schedule-table td:nth-child(3) { min-width: 140px; }
 .gantt-row { height: 24px !important; }
 .gantt-label-col { width: 100px !important; min-width: 100px !important; font-size: 10px !important; line-height: 24px !important; padding: 0 2px !important; }
 .gantt-bar { height: 16px !important; top: 4px !important; font-size: 9px !important; }
 .gantt-date-cell { font-size: 9px !important; }
 #result { font-size: 10px; }
}

/* =========================================
   スケジュールエディタ用スタイル
   ========================================= */
#schedule-editor-table input[type="text"],
#schedule-editor-table input[type="number"] {
    font-size: 11px;
    padding: 2px;
    border: 1px solid #ccc;
    border-radius: 2px;
    box-sizing: border-box;
}

#schedule-editor-table td {
    padding: 4px 2px;
    vertical-align: middle;
}

#schedule-editor-table .remove-btn {
    background-color: #dc3545;
    color: white;
    border: none;
    border-radius: 3px;
    cursor: pointer;
}

====================
FILE: ui_cell_event.js
====================
/** @file ui_cell_event.js @description ガチャセルクリック時のイベントハンドラ（ターゲット同期・エラー案内・トラック一致強化版） */

/**
 * テーブル上のガチャセル、または確定枠（G列）をクリックした際のハンドラ
 * ターゲットのインデックス（A/Bおよび行番号）を保持したまま探索エンジンを呼び出します。
 */
function onGachaCellClick(targetSeedIndex, gachaId, charName, guaranteedType = null, fromFind = false, targetCharId = null) {
    // 1. シミュレーションモードがOFFの場合は、ONに切り替えてから実行
    if (!isSimulationMode) {
        toggleAppMode();
        const notifEl = document.getElementById('sim-notif-msg');
        if (notifEl) {
            notifEl.style.display = 'block';
            notifEl.style.color = '#007bff';
            notifEl.textContent = 'Simモードに切り替えてルートを探索します...';
            setTimeout(() => { if (notifEl.textContent.includes('Simモード')) notifEl.style.display = 'none'; }, 2000);
        }

        // モード切替後の再描画と状態遷移を待ってから再試行
        setTimeout(() => {
            onGachaCellClick(targetSeedIndex, gachaId, charName, guaranteedType, fromFind, targetCharId);
        }, 150);
        return;
    }

    // 以前の警告・通知メッセージをクリア
    const errorEl = document.getElementById('sim-error-msg');
    const notifEl = document.getElementById('sim-notif-msg');
    if (errorEl) { errorEl.textContent = ''; errorEl.style.display = 'none'; }
    if (notifEl) { notifEl.textContent = ''; notifEl.style.display = 'none'; }

    // 現在表示されているガチャIDのリストを取得（探索範囲をテーブル表示中のものに限定）
    const visibleIds = tableGachaIds.map(id => id);
    const configInput = document.getElementById('sim-config');
    const currentConfig = configInput ? configInput.value : "";

    if (typeof calculateRouteToCell === 'function') {
        let routeResult = null;

        // 2. 確定枠（11g/15g/7g等）をクリックした場合の最終アクション設定
        if (guaranteedType) {
            const rollsCount = parseInt(guaranteedType.replace('g', ''), 10);
            const finalAction = { 
                id: gachaId, 
                rolls: rollsCount, 
                g: true,
                fullId: gachaId + 'g'
            };
            // 確定枠の場合、targetSeedIndex は「確定ガチャを開始する地点」として渡し、
            // エンジン側でその地点までの最短経路 + 最後の確定ロールを結合させます
            routeResult = calculateRouteToCell(targetSeedIndex, gachaId, visibleIds, currentConfig, finalAction, targetCharId);
        } 
        // 3. 通常枠をクリックした場合
        else {
            // 通常セルの場合は finalActionOverride を null にし、エンジン内で最終ステップを自動補完させます
            routeResult = calculateRouteToCell(targetSeedIndex, gachaId, visibleIds, currentConfig, null, targetCharId);
        }

        // 4. ルートが見つかった場合の処理
        if (routeResult) {
            if (configInput) {
                configInput.value = routeResult;
                
                // URLパラメータを更新し、テーブルを再描画してハイライトを反映
                if (typeof updateUrlParams === 'function') updateUrlParams();
                resetAndGenerateTable();
                
                // 到達成功の通知（番地をフォーマットして表示）
                if (notifEl) {
                    const row = Math.floor(targetSeedIndex / 2) + 1;
                    const side = (targetSeedIndex % 2 === 0) ? 'A' : 'B';
                    notifEl.style.display = 'block';
                    notifEl.style.color = '#28a745'; // 成功色（緑）
                    notifEl.textContent = `${side}${row}セルへのルートを更新しました`;
                    setTimeout(() => { notifEl.style.display = 'none'; }, 3000);
                }
            }
        } 
        // 5. ルートが見つからなかった場合の案内
        else {
            if (errorEl) {
                errorEl.style.display = 'block';
                errorEl.style.color = '#d9534f'; // 警告色（赤）
                errorEl.textContent = '見つかりませんでした';
                
                // 1.5秒間表示して注意を促す
                setTimeout(() => {
                    errorEl.style.display = 'none';
                    errorEl.textContent = '';
                }, 1500);
            }
            console.warn(`Route not found for Target Index: ${targetSeedIndex} (Gacha: ${gachaId})`);
        }
    } else {
        console.error("calculateRouteToCell function is not defined. check sim_engine_config.js loading.");
    }
}

/**
 * 確定枠（11G）セルの詳細デバッグログ表示用のタイマー管理
 * 長押し（0.6秒）で詳細な計算過程を表示します。
 */
window.start11GTimer = function(seedIdx, colIdx, isAlt) {
    window.clear11GTimer();
    window.g11Timer = setTimeout(() => {
        if (typeof showDebugLog === 'function') {
            showDebugLog(seedIdx, colIdx, isAlt);
        }
    }, 600);
};

window.clear11GTimer = function() {
    if (window.g11Timer) {
        clearTimeout(window.g11Timer);
        window.g11Timer = null;
    }
};

====================
FILE: ui_display_logic.js
====================
/** @file ui_display_logic.js @description 表示要素（SEED列/マスター情報/Find）のトグル管理 */

// マスター情報の表示フラグ（初期値は非表示）
let isMasterInfoVisible = false;

/**
 * SEED詳細列（左側の計算用数値列）の表示/非表示を切り替える
 */
function toggleSeedColumns() {
    showSeedColumns = !showSeedColumns;
    
    // テーブル全体を再生成して表示状態を反映
    if (typeof generateRollsTable === 'function') {
        generateRollsTable();
    }
    
    // ボタンのラベル表示を更新
    updateToggleButtons();
}

/**
 * SEED列切り替えボタンのテキストを現在の状態に合わせて更新する
 */
function updateToggleButtons() {
    const btnSeed = document.getElementById('toggle-seed-btn');
    if (btnSeed) {
        btnSeed.textContent = showSeedColumns ? 'SEED非表示' : 'SEED表示';
    }
}

/**
 * ガチャのマスター情報（キャラ一覧リスト）の表示/非表示を切り替える
 */
function toggleMasterInfo() {
    isMasterInfoVisible = !isMasterInfoVisible;
    
    // マスター表示ボタンの見た目（activeクラス）を更新
    const btn = document.getElementById('toggle-master-info-btn');
    if (btn) {
        if (isMasterInfoVisible) {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
    }

    // コンテナ要素（master-info-area）の表示状態を直接制御
    const content = document.getElementById('master-info-area');
    if (content) {
        content.style.display = isMasterInfoVisible ? 'block' : 'none';
    }

    // テーブル生成フローの中でHTML構造を再構築
    if (typeof generateRollsTable === 'function') {
        generateRollsTable();
    }
    
    // リフレッシュロジックを実行して中身を最新にする
    if (typeof updateMasterInfoView === 'function') {
        updateMasterInfoView();
    }
}

/**
 * Find（高速予報・ターゲット検索）エリアの表示/非表示を切り替える
 */
function toggleFindInfo() {
    showFindInfo = !showFindInfo;
    
    const btn = document.getElementById('toggle-find-info-btn');
    
    // テーブル全体を再生成してFindエリアの有無を反映
    if (typeof generateRollsTable === 'function') {
        generateRollsTable();
    }
    
    // Findボタンの活性化状態を更新
    if (btn) {
        if (showFindInfo) {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
    }
}

====================
FILE: ui_globals.js
====================
/** @file ui_globals.js @description アプリケーション全体で共有されるグローバルな状態変数の定義 @dependency なし */

// UI状態変数 (Global)
let tableGachaIds = [];
let currentRolls = 300;
let showSeedColumns = false;
let showResultDisplay = false;
let showFindInfo = false; // Findエリア（予報＋マスター情報）の表示フラグ
let finalSeedForUpdate = null;
let isSimulationMode = false;
let isTxtMode = false; // Txtボタンの状態
let isScheduleMode = false;
let isDescriptionMode = false;
// 追加: 概要表示モードフラグ
let activeGuaranteedIds = new Set();
let isScheduleAnalyzed = false;

// Find機能の状態管理
let hiddenFindIds = new Set();
// 自動ターゲットのうち、非表示にするID
let userTargetIds = new Set();
let prioritizedFindIds = []; // クリックされたターゲットの履歴を保持する配列
let prioritizedTargetId = null; // メインテーブルハイライト用の単一ターゲット
let userPrioritizedTargets = []; // ユーザーが優先指定したターゲットリスト
let isFindListCleared = false;
let globalSearchResults = null; // 他ガチャでの検索結果を保持する

// ルート探索の上限設定
let simMaxPlat = 0;
let simMaxGuar = 0;

// 超激レア追加シミュレーション用
let uberAdditionCounts = [];

====================
FILE: ui_modal_service.js
====================
/** @file ui_modal_service.js @description 汎用モーダル表示エンジン */

function showModal(contentHtml) {
    let modal = document.getElementById('common-modal');
    if (!modal) {
        modal = document.createElement('div');
        modal.id = 'common-modal';
        modal.style = "display:none; position:fixed; z-index:10000; left:0; top:0; width:100%; height:100%; background:rgba(0,0,0,0.7); overflow:auto;";
        document.body.appendChild(modal);
    }
    modal.innerHTML = `
        <div style="background:#fff; margin:10% auto; padding:15px; width:90%; max-width:500px; border-radius:8px; position:relative; box-shadow: 0 4px 15px rgba(0,0,0,0.3);">
            ${contentHtml}
        </div>`;
    modal.style.display = 'block';
}

function closeModal() {
    const modal = document.getElementById('common-modal');
    if (modal) modal.style.display = 'none';
}

====================
FILE: ui_mode_logic.js
====================
/** @file ui_mode_logic.js @description アプリの初期化とモード切替（Sim/skd/概要/Txt）の管理 */

function initializeDefaultGachas() {
    if (typeof prepareScheduleInfo === 'function') {
        prepareScheduleInfo();
    }

    if (tableGachaIds.length === 0) {
        let scheduleFound = false;
        if (isScheduleAnalyzed && typeof parseGachaTSV === 'function') {
            try {
                const scheduleData = parseGachaTSV(loadedTsvContent);
                const now = new Date();
                const activeGachas = scheduleData.filter(item => {
                    if (typeof isPlatinumOrLegend === 'function' && isPlatinumOrLegend(item)) return false;
                    const startDt = parseDateTime(item.rawStart, item.startTime);
                    const endDt = parseDateTime(item.rawEnd, item.endTime);
                    return now >= startDt && now <= endDt;
                });
                if (activeGachas.length > 0) {
                    activeGachas.forEach(gacha => {
                        let newId = gacha.id.toString();
                        if (gacha.guaranteed) newId += 'g';
                        tableGachaIds.push(newId);
                        uberAdditionCounts.push(0); 
                    });
                    scheduleFound = true;
                }
            } catch (e) {
                console.warn("Auto-select from schedule failed:", e);
            }
        }
        
        if (!scheduleFound || tableGachaIds.length === 0) {
            const options = getGachaSelectorOptions(null);
            if (options.length > 0) {
                tableGachaIds.push(options[0].value);
                uberAdditionCounts.push(0);
                if (options.length > 1) {
                    tableGachaIds.push(options[1].value);
                    uberAdditionCounts.push(0);
                }
            } else {
                const sortedGachas = Object.values(gachaMasterData.gachas)
                    .filter(gacha => gacha.sort < 800)
                    .sort((a, b) => a.sort - b.sort);
                if (sortedGachas.length > 0) {
                    tableGachaIds.push(sortedGachas[0].id);
                    uberAdditionCounts.push(0);
                }
                if (sortedGachas.length > 1) {
                    tableGachaIds.push(sortedGachas[1].id);
                    uberAdditionCounts.push(0);
                }
            }
        }
    }

    const seedEl = document.getElementById('seed');
    if (seedEl && (seedEl.value === '12345' || seedEl.value === '')) {
        toggleSeedInput();
    }
}

function onModeChange() {
    updateModeButtonState();
    refreshModeView();
}

function toggleAppMode() {
    isSimulationMode = !isSimulationMode;
    onModeChange();
}

function toggleTxtMode() {
    isTxtMode = !isTxtMode;
    onModeChange();
}

function updateModeButtonState() {
    const btnSim = document.getElementById('mode-toggle-btn');
    if (btnSim) {
        if (isSimulationMode) btnSim.classList.add('active');
        else btnSim.classList.remove('active');
    }
    
    const btnTxt = document.getElementById('toggle-txt-btn');
    const btnCopy = document.getElementById('copy-txt-btn');
    if (btnTxt) {
        if (isTxtMode) {
            btnTxt.classList.add('active');
            if (btnCopy) btnCopy.classList.remove('hidden');
        } else {
            btnTxt.classList.remove('active');
            if (btnCopy) btnCopy.classList.add('hidden');
        }
    }
}

function refreshModeView() {
    const simWrapper = document.getElementById('sim-control-wrapper');
    if (simWrapper) {
        if (isSimulationMode && !isScheduleMode && !isDescriptionMode) {
            simWrapper.classList.remove('hidden');
        } else {
            simWrapper.classList.add('hidden');
        }
    }
    resetAndGenerateTable();
}

function toggleDescription() {
    const content = document.getElementById('description-content');
    const toggle = document.getElementById('toggle-description');
    const tableContainer = document.getElementById('rolls-table-container');
    const simWrapper = document.getElementById('sim-control-wrapper');
    const resultDiv = document.getElementById('result');
    const mainControls = document.getElementById('main-controls');
    const scheduleContainer = document.getElementById('schedule-container');

    isDescriptionMode = !isDescriptionMode;
    if (isDescriptionMode) {
        if (typeof isScheduleMode !== 'undefined' && isScheduleMode && typeof toggleSchedule === 'function') {
            toggleSchedule();
        }
        if (toggle) toggle.classList.add('active');
        if (tableContainer) tableContainer.classList.add('hidden');
        if (simWrapper) simWrapper.classList.add('hidden');
        if (resultDiv) resultDiv.classList.add('hidden');
        if (mainControls) mainControls.classList.add('hidden');
        if (scheduleContainer) scheduleContainer.classList.add('hidden');
        if (content) {
            content.classList.remove('hidden');
            content.style.flexGrow = '1';       
            content.style.overflowY = 'auto';   
            content.style.height = '100%';
            content.style.webkitOverflowScrolling = 'touch';
            content.style.minHeight = '0';
            content.style.maxHeight = 'none';
        }
    } else {
        if (toggle) toggle.classList.remove('active');
        if (content) {
            content.classList.add('hidden');
            content.style.flexGrow = '';
            content.style.overflowY = '';
            content.style.height = '';
            content.style.minHeight = '';
            content.style.maxHeight = '';
            content.style.webkitOverflowScrolling = '';
        }
        if (tableContainer) tableContainer.classList.remove('hidden');
        if (mainControls) mainControls.classList.remove('hidden');
        if (isSimulationMode && simWrapper) simWrapper.classList.remove('hidden');
        if (showResultDisplay && resultDiv) resultDiv.classList.remove('hidden');
    }
}

====================
FILE: ui_refresh_logic.js
====================
/** @file ui_refresh_logic.js @description テーブル再描画とConfig操作の管理 */

/**
 * テーブルを初期化して生成し、関連する表示（マスター情報、URLパラメータ）を更新する
 */
function resetAndGenerateTable() {
    // スケジュールモードや概要モードのときはテーブル生成を行わない
    if (isScheduleMode || isDescriptionMode) return;
    
    finalSeedForUpdate = null;
    const simConf = document.getElementById('sim-config');
    
    // ルートが空の場合はデフォルトの表示行数にリセット
    if (simConf && simConf.value.trim() === '') {
         currentRolls = 300;
    }
    
    // テーブル本体の生成
    if (typeof generateRollsTable === 'function') {
        generateRollsTable();
    }
    
    // マスター情報の表示更新
    updateMasterInfoView();
    
    // URLパラメータの同期
    if (typeof updateUrlParams === 'function') {
        updateUrlParams();
    }
}

/**
 * 表示行数を100行増やす
 */
function addMoreRolls() {
    currentRolls += 100;
    if (typeof generateRollsTable === 'function') {
        generateRollsTable();
    }
}

/**
 * シミュレーション設定（ルート）をクリアする
 */
function clearSimConfig() {
    const el = document.getElementById('sim-config');
    if (el) el.value = '';
    
    const errorEl = document.getElementById('sim-error-msg');
    if (errorEl) {
        errorEl.textContent = '';
        errorEl.style.display = 'none';
    }
    
    const notifEl = document.getElementById('sim-notif-msg');
    if (notifEl) {
        notifEl.textContent = '';
        notifEl.style.display = 'none';
    }
    
    resetAndGenerateTable();
}

/**
 * シミュレーションの最後の一歩を取り消す
 */
function backSimConfig() {
    const el = document.getElementById('sim-config');
    if (el && typeof removeLastConfigSegment === 'function') {
        el.value = removeLastConfigSegment(el.value);
        resetAndGenerateTable();
    }
}

/**
 * ガチャのマスター詳細情報（キャラリスト）表示を更新する
 */
function updateMasterInfoView() {
    // view_table.js側で生成されるコンテナIDを指定
    const el = document.getElementById('master-info-area');
    
    // 関数名のタイポ修正：generateMasterInfoHTML -> generateMasterInfoHtml
    if (!el || typeof generateMasterInfoHtml !== 'function') return;

    // 現在テーブルに表示されているガチャ情報を収集
    const configs = [];
    tableGachaIds.forEach(idStr => {
        let gachaId = idStr.replace(/[gfs]$/, '');
        if (gachaMasterData.gachas[gachaId]) {
            configs.push(gachaMasterData.gachas[gachaId]);
        }
    });

    // 収集した情報を元にHTMLを生成して流し込む
    el.innerHTML = generateMasterInfoHtml(configs);
}

====================
FILE: ui_schedule_editor_handler.js
====================
/** @file ui_schedule_editor_handler.js @description スケジュールエディタの操作イベント（追加・削除・インポート）を管理 */

/**
 * テキストからスケジュールを解析して行を追加する
 */
function processTextImport() {
    const textArea = document.getElementById('import-text-input');
    if (!textArea) return;

    let text = textArea.value;
    // ANSIエスケープシーケンス（\x1b[...m）を削除
    text = text.replace(/\x1b\[[0-9;]*m/g, "");

    const lines = text.split('\n');
    let addCount = 0;
    const now = new Date();
    const currentYear = now.getFullYear();

    lines.forEach(line => {
        if (!line.trim() || !line.includes('月')) return;

        try {
            // 1. 日付の抽出: [12月 25日 ~ 29日]
            const dateMatch = line.match(/\[(\d+)月\s*(\d+)日\s*~\s*(\d+)日\]/);
            if (!dateMatch) return;

            const month = dateMatch[1].padStart(2, '0');
            const startDay = dateMatch[2].padStart(2, '0');
            const endDay = dateMatch[3].padStart(2, '0');

            let year = currentYear;
            if (now.getMonth() === 0 && month === "12") year--;
            if (now.getMonth() === 11 && month === "01") year++;

            const rawStart = `${year}${month}${startDay}`;
            const rawEnd = `${year}${month}${endDay}`;

            // 2. ガチャ名の抽出
            const afterDate = line.substring(line.indexOf(']') + 1).trim();
            let gachaName = afterDate.split(/[\[<]/)[0].trim();
            gachaName = gachaName.replace(/\(\+.+?\)/, "").trim();

            // 3. フラグの抽出: [G|L|N] など
            const flagsMatch = line.match(/\[([^\]]*[GLNPRSP][^\]]*)\]/);
            const isGuaranteed = flagsMatch ? flagsMatch[1].includes('G') : false;

            // 4. 特殊確率の抽出: UR = 7%
            let uberRate = "500";
            const rateMatch = line.match(/UR\s*=\s*(\d+)%/);
            if (rateMatch) {
                uberRate = parseInt(rateMatch[1]) * 100;
            } else if (gachaName.includes("超ネコ祭") || gachaName.includes("極ネコ祭")) {
                uberRate = "900";
            } else if (gachaName.includes("超極ネコ祭")) {
                uberRate = "1000";
            } else if (gachaName.includes("超国王祭")) {
                uberRate = "700";
            }

            // 5. マスターデータからIDを検索
            let foundId = "0";
            if (typeof getGachaSelectorOptions === 'function') {
                const options = getGachaSelectorOptions();
                
                // まずはテキストのガチャ名で検索
                const match = options.find(opt => opt.label.includes(gachaName)) || 
                              options.find(opt => gachaName.includes(opt.label.split(') ')[1]));
                
                if (match) {
                    foundId = match.value;
                } else {
                    // 見つからなかった場合は「ネコルガ族」をデフォルトにする
                    const fallback = options.find(opt => opt.label.includes("ネコルガ族"));
                    if (fallback) foundId = fallback.value;
                }
            }

            // 行を追加
            const item = {
                rawStart: rawStart, startTime: "1100",
                rawEnd: rawEnd, endTime: "1059",
                id: foundId, tsvName: gachaName,
                uber: uberRate, legend: "30",
                guaranteed: isGuaranteed
            };

            const tbody = document.querySelector('#schedule-editor-table tbody');
            if (tbody) {
                const tempTable = document.createElement('table');
                tempTable.innerHTML = createEditorRowHtml(item);
                tbody.appendChild(tempTable.querySelector('tr'));
                addCount++;
            }
        } catch (e) {
            console.warn("Line parse error:", line, e);
        }
    });

    if (addCount > 0) {
        alert(`${addCount}件のスケジュールを追加しました。`);
        textArea.value = "";
        toggleImportArea();
    } else {
        alert("解析可能な行が見つかりませんでした。");
    }
}

/**
 * 現在のエディタの内容を解析してTSV文字列を生成する
 */
function captureEditorDataToTsv() {
    const rows = document.querySelectorAll('#schedule-editor-table tbody tr');
    let tsvRows = [];

    rows.forEach(row => {
        const rawStartD = row.querySelector('.edit-start-date').value.replace(/-/g, '');
        const rawEndD = row.querySelector('.edit-end-date').value.replace(/-/g, '');
        const startH = row.querySelector('.edit-start-time').value;
        const endH = row.querySelector('.edit-end-time').value;
        const startT = startH + "00";
        const endT = endH + "59";

        const gId = row.querySelector('.edit-id').value.trim();
        const name = row.querySelector('.edit-name').value.trim();
        const uber = row.querySelector('.edit-uber').value.trim();
        const legend = row.querySelector('.edit-legend').value.trim();
        const isG = row.querySelector('.edit-guaranteed').checked ? "1" : "0";

        if (!rawStartD || !rawEndD || !gId) return;

        let cols = Array(25).fill("0");
        cols[0] = rawStartD; cols[1] = startT;
        cols[2] = rawEndD; cols[3] = endT;
        cols[8] = "1"; cols[10] = gId;
        cols[16] = "7000"; cols[18] = "2500"; 
        cols[20] = uber; cols[21] = isG;
        cols[22] = legend; cols[24] = name;

        tsvRows.push(cols.join('\t'));
    });
    return tsvRows.join('\n');
}

/**
 * 編集内容を一時的にアプリに反映させる
 */
function applyScheduleTemporarily() {
    const tsvContent = captureEditorDataToTsv();
    if (!tsvContent) {
        alert("有効な予定データがありません。");
        return;
    }

    loadedTsvContent = tsvContent;
    isScheduleAnalyzed = false;
    window.isScheduleEditMode = false;

    if (typeof renderScheduleTable === 'function') {
        renderScheduleTable(loadedTsvContent, 'schedule-container');
    }
    
    if (typeof generateRollsTable === 'function') generateRollsTable();
}

/**
 * エディタに新しい予定行を末尾に追加する
 */
function addNewScheduleRow() {
    const tbody = document.querySelector('#schedule-editor-table tbody');
    if (!tbody) return;
    
    if (typeof createEditorRowHtml === 'function') {
        const newRowHtml = createEditorRowHtml();
        const tempTable = document.createElement('table');
        tempTable.innerHTML = newRowHtml;
        const newRow = tempTable.querySelector('tr');
        tbody.appendChild(newRow);
        newRow.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
}

/**
 * 指定された行を削除する
 */
function deleteEditorRow(btn) {
    if (confirm("この予定を削除しますか？")) {
        const row = btn.closest('tr');
        if (row) {
            row.parentNode.removeChild(row);
        }
    }
}

/**
 * 現在のエディタの内容を gatya.tsv 形式でダウンロードする
 */
function generateAndDownloadTSV() {
    const tsvContent = captureEditorDataToTsv();
    if (!tsvContent) {
        alert("データがありません。");
        return;
    }

    const blob = new Blob([tsvContent], { type: 'text/tab-separated-values' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'gatya.tsv';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    loadedTsvContent = tsvContent;
    alert("gatya.tsv を作成しました。\nGitHubの gatya.tsv をこのファイルで上書きしてください。");
}

====================
FILE: ui_schedule_handler.js
====================
/** @file ui_schedule_handler.js @description スケジュールモード（skd）の切替、スケジュールからの列追加を担当 @dependency schedule_logic.js, view_schedule.js */

// スケジュール情報の事前解析
function prepareScheduleInfo() {
    if (isScheduleAnalyzed) return;
    if (typeof loadedTsvContent === 'string' && loadedTsvContent && 
        typeof parseGachaTSV === 'function' && typeof parseDateTime === 'function') {
        try {
            const scheduleData = parseGachaTSV(loadedTsvContent);
            const now = new Date();
            activeGuaranteedIds.clear();

            scheduleData.forEach(item => {
                const startDt = parseDateTime(item.rawStart, item.startTime);
                const endDt = parseDateTime(item.rawEnd, item.endTime);
                
                if (now >= startDt && now <= endDt) {
            
                    if (item.guaranteed) {
                        const gId = parseInt(item.id);
                        activeGuaranteedIds.add(gId);
                        /* if (gachaMasterData && gachaMasterData.gachas && gachaMasterData.gachas[gId]) {
         
                            const currentName = gachaMasterData.gachas[gId].name;
                            if (!currentName.includes('[確定]')) {
                                 gachaMasterData.gachas[gId].name += " [確定]";
                            }
                        }
                        */
                    }
                }
            });
            isScheduleAnalyzed = true;
            console.log("Schedule Analyzed. Active Guaranteed IDs:", Array.from(activeGuaranteedIds));
        } catch (e) {
            console.warn("Schedule analysis failed:", e);
        }
    }
}

// スケジュールモードのUIセットアップ
function setupScheduleUI() {
    let scheduleContainer = document.getElementById('schedule-container');
    if (!scheduleContainer) {
        scheduleContainer = document.createElement('div');
        scheduleContainer.id = 'schedule-container';
        scheduleContainer.className = 'hidden';
        const tableContainer = document.getElementById('rolls-table-container');
        if (tableContainer) {
            tableContainer.parentNode.insertBefore(scheduleContainer, tableContainer.nextSibling);
        } else {
            document.body.appendChild(scheduleContainer);
        }
    }
}

// スケジュールモードの切り替え (skdボタン)
function toggleSchedule() {
    if (!loadedTsvContent) {
        alert("スケジュールの読み込みに失敗しました。");
        return;
    }

    isScheduleMode = !isScheduleMode;
    
    if (!isScheduleMode) {
        window.isScheduleEditMode = false;
    }

    if (typeof isDescriptionMode !== 'undefined' && isDescriptionMode && typeof toggleDescription === 'function' && isScheduleMode) {
        toggleDescription();
    }

    const scheduleBtn = document.getElementById('toggle-schedule-btn');
    const simWrapper = document.getElementById('sim-control-wrapper');
    const tableContainer = document.getElementById('rolls-table-container');
    const scheduleContainer = document.getElementById('schedule-container');
    const resultDiv = document.getElementById('result');
    const mainControls = document.getElementById('main-controls');

    if (isScheduleMode) {
        scheduleBtn.classList.add('active');
        if (simWrapper) simWrapper.classList.add('hidden');
        if (tableContainer) tableContainer.classList.add('hidden');
        if (resultDiv) resultDiv.classList.add('hidden');
        if (mainControls) mainControls.classList.add('hidden');
        if (scheduleContainer) {
            scheduleContainer.classList.remove('hidden');
            // 反映ボタン等で解析フラグが落ちている場合に備えて再解析
            prepareScheduleInfo();
            if (typeof renderScheduleTable === 'function') {
                renderScheduleTable(loadedTsvContent, 'schedule-container');
            }
        }
    } else {
        scheduleBtn.classList.remove('active');
        if (isSimulationMode && simWrapper) simWrapper.classList.remove('hidden');
        if (tableContainer) tableContainer.classList.remove('hidden');
        if (resultDiv && showResultDisplay) resultDiv.classList.remove('hidden');
        if (mainControls) mainControls.classList.remove('hidden');
        if (scheduleContainer) {
            scheduleContainer.classList.add('hidden');
        }
    }
}

/**
 * 編集モードへの移行処理
 */
function enterScheduleEditMode() {
    if (!loadedTsvContent) return;
    window.isScheduleEditMode = true;
    if (typeof renderScheduleEditor === 'function') {
        renderScheduleEditor(loadedTsvContent, 'schedule-container');
    }
}

// スケジュールから開催中・予定のガチャを一括追加
function addGachasFromSchedule() {
    if (!loadedTsvContent || typeof parseGachaTSV !== 'function') {
        alert("スケジュールデータがありません。");
        return;
    }

    const scheduleData = parseGachaTSV(loadedTsvContent);
    const now = new Date();
    const todayStr = now.getFullYear() + 
                     String(now.getMonth() + 1).padStart(2, '0') + 
                     String(now.getDate()).padStart(2, '0');
    const todayInt = parseInt(todayStr, 10);

    const newGachaData = [];

    scheduleData.forEach((item, index) => {
        let endValue = parseInt(item.rawEnd, 10);
        const isPlat = item.seriesName.includes("プラチナ");
        const isLeg = item.seriesName.includes("レジェンド");

        if (isPlat || isLeg) {
            const nextSameType = scheduleData.slice(index + 1).find(nextItem => {
                if (isPlat) return nextItem.seriesName.includes("プラチナ");
                if (isLeg) return nextItem.seriesName.includes("レジェンド");
                return false;
            });
            if (nextSameType) {
                endValue = parseInt(nextSameType.rawStart, 10);
            }
        }

        if (endValue < todayInt) return;

        let fullId = item.id.toString();
        if (item.guaranteed) fullId += 'g';

        let typeOrder = 0;
        if (isPlat) typeOrder = 1;
        else if (isLeg) typeOrder = 2;
        
        newGachaData.push({
            fullId: fullId,
            rawStart: parseInt(item.rawStart, 10),
            typeOrder: typeOrder,
            count: 0
        });
    });

    if (newGachaData.length === 0) {
        alert("条件に合致するスケジュール（現在開催中または未来）がありません。");
        return;
    }

    newGachaData.sort((a, b) => {
        if (a.typeOrder !== b.typeOrder) return a.typeOrder - b.typeOrder;
        return a.rawStart - b.rawStart;
    });

    const scheduleIds = new Set(newGachaData.map(d => d.fullId.replace(/[gfs]$/, '')));
    const keptGachas = [];
    tableGachaIds.forEach((idWithSuffix, index) => {
        const baseId = idWithSuffix.replace(/[gfs]$/, '');
        if (!scheduleIds.has(baseId)) {
            keptGachas.push({
                fullId: idWithSuffix,
                count: uberAdditionCounts[index] || 0
            });
        }
    });

    const finalGachaList = [...keptGachas, ...newGachaData];
    tableGachaIds = finalGachaList.map(item => item.fullId);
    uberAdditionCounts = finalGachaList.map(item => item.count);
    if (typeof generateRollsTable === 'function') generateRollsTable();
    if (typeof updateMasterInfoView === 'function') updateMasterInfoView();
    if (typeof updateUrlParams === 'function') updateUrlParams();
}


====================
FILE: ui_seed_logic.js
====================
/** @file ui_seed_logic.js @description SEED値の操作・同期ロジック */

function toggleSeedInput() {
    const container = document.getElementById('seed-input-container');
    const trigger = document.getElementById('seed-input-trigger');
    if (!container) return;

    if (container.classList.contains('hidden')) {
        container.classList.remove('hidden');
        if (trigger) {
            trigger.classList.remove('hidden');
            trigger.classList.add('active');
        }
        const input = document.getElementById('seed');
        if (input) input.focus();
    } else {
        cancelSeedInput();
    }
}

function applySeedInput() {
    if (typeof updateUrlParams === 'function') updateUrlParams();
    resetAndGenerateTable();
    const container = document.getElementById('seed-input-container');
    const trigger = document.getElementById('seed-input-trigger');
    if (container) container.classList.add('hidden');
    if (trigger) {
        trigger.classList.remove('hidden');
        trigger.classList.remove('active');
    }
}

function cancelSeedInput() {
    const container = document.getElementById('seed-input-container');
    const trigger = document.getElementById('seed-input-trigger');
    const input = document.getElementById('seed');
    const urlParams = new URLSearchParams(window.location.search);
    const currentSeed = urlParams.get('seed') || "12345";
    if (input) input.value = currentSeed;
    if (container) container.classList.add('hidden');
    if (trigger) {
        trigger.classList.remove('hidden');
        trigger.classList.remove('active');
    }
}

function copySeedToClipboard() {
    const seedInput = document.getElementById('seed');
    if (!seedInput) return;
    navigator.clipboard.writeText(seedInput.value).catch(err => {
        console.error('Failed to copy: ', err);
    });
}

/** * ルート（Config）と表示テキストをクリップボードへコピー 
 */
function copyTxtToClipboard() {
    const configInput = document.getElementById('sim-config');
    const txtDisplay = document.getElementById('txt-route-display');
    const notifEl = document.getElementById('sim-notif-msg');

    if (!configInput || !txtDisplay) return;

    // ルート入力値 + 改行 + テキストエリアの表示内容
    const textToCopy = configInput.value + "\n\n" + txtDisplay.innerText;

    navigator.clipboard.writeText(textToCopy).then(() => {
        if (notifEl) {
            notifEl.textContent = 'Copyed!';
            notifEl.style.display = 'inline';
            setTimeout(() => {
                notifEl.style.display = 'none';
            }, 2000);
        }
    }).catch(err => {
        console.error('Failed to copy: ', err);
    });
}

function updateSeedAndRefresh(newSeed) {
    const seedInput = document.getElementById('seed');
    if(seedInput && newSeed) {
        seedInput.value = newSeed;
        currentRolls = 300;
        if (typeof generateRollsTable === 'function') generateRollsTable();
        updateMasterInfoView();
        if (typeof updateUrlParams === 'function') updateUrlParams();
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }
}

function updateSeedFromSim() {
    if (finalSeedForUpdate) {
        document.getElementById('seed').value = finalSeedForUpdate;
        document.getElementById('sim-config').value = '';
        resetAndGenerateTable(); 
    }
}

====================
FILE: ui_table_handler.js
====================
/** @file ui_table_handler.js @description テーブルの列操作（追加、削除、変更）のイベントハンドラを担当 @dependency view_table.js */

// 新しいガチャ列を追加 (デフォルト選択)
function addGachaColumn() {
    const options = getGachaSelectorOptions(null);
    if (options.length > 0) {
        let val = options[0].value;
        if (activeGuaranteedIds.has(parseInt(val))) val += 'g';
        tableGachaIds.push(val);
        uberAdditionCounts.push(0); 
        if (typeof generateRollsTable === 'function') generateRollsTable();
        if (typeof updateMasterInfoView === 'function') updateMasterInfoView();
    }
}

// ガチャ列を削除
function removeGachaColumn(index) {
    if (tableGachaIds.length > 1) {
        tableGachaIds.splice(index, 1);
        uberAdditionCounts.splice(index, 1);
        if (typeof generateRollsTable === 'function') generateRollsTable();
        if (typeof updateMasterInfoView === 'function') updateMasterInfoView();
    }
}

// 最初の列以外をリセット (×ボタンから呼ばれる)
function resetToFirstGacha() {
    if (tableGachaIds.length <= 1) return;
    
    if (confirm("一番左の列以外を削除しますか？")) {
        tableGachaIds = [tableGachaIds[0]];
        uberAdditionCounts = [uberAdditionCounts[0]];
        if (typeof generateRollsTable === 'function') generateRollsTable();
        if (typeof updateMasterInfoView === 'function') updateMasterInfoView();
        if (typeof updateUrlParams === 'function') updateUrlParams();
    }
}

// 列のガチャを変更（プルダウン操作）
function updateGachaSelection(selectElement, index) {
    const originalIdWithSuffix = tableGachaIds[index];
    const newBaseId = selectElement.value;
    if (activeGuaranteedIds.has(parseInt(newBaseId))) {
        tableGachaIds[index] = newBaseId + 'g';
    } else {
        let suffix = '';
        if (originalIdWithSuffix.endsWith('f')) suffix = 'f';
        else if (originalIdWithSuffix.endsWith('s')) suffix = 's';
        else if (originalIdWithSuffix.endsWith('g')) suffix = 'g';
        tableGachaIds[index] = newBaseId + suffix;
    }
    if (typeof generateRollsTable === 'function') generateRollsTable();
    if (typeof updateMasterInfoView === 'function') updateMasterInfoView();
}

// 確定枠タイプの切り替え (通常 -> 11g -> 15g -> 7g)
function toggleGuaranteedColumn(index) {
    const currentVal = tableGachaIds[index];
    let baseId = currentVal;
    let suffix = '';
    
    if (currentVal.endsWith('f')) { suffix = 'f'; baseId = currentVal.slice(0, -1); } 
    else if (currentVal.endsWith('s')) { suffix = 's'; baseId = currentVal.slice(0, -1); } 
    else if (currentVal.endsWith('g')) { suffix = 'g'; baseId = currentVal.slice(0, -1); }

    let nextSuffix = '';
    if (suffix === '') nextSuffix = 'g';
    else if (suffix === 'g') nextSuffix = 'f';
    else if (suffix === 'f') nextSuffix = 's';
    else if (suffix === 's') nextSuffix = '';
    
    tableGachaIds[index] = baseId + nextSuffix;
    if (typeof generateRollsTable === 'function') generateRollsTable();
}

// 新規キャラ追加数（add機能）の更新
function updateUberAddition(selectElement, index) {
    const val = parseInt(selectElement.value, 10);
    uberAdditionCounts[index] = (!isNaN(val)) ? val : 0;
    if (typeof generateRollsTable === 'function') generateRollsTable();
}

// add入力欄の表示
function showAddInput(index) {
    const trigger = document.getElementById(`add-trigger-${index}`);
    const wrapper = document.getElementById(`add-select-wrapper-${index}`);
    if(trigger) trigger.style.display = 'none';
    if(wrapper) wrapper.style.display = 'inline-block';
}

// ID指定追加入力欄の表示
function showIdInput() {
    const idStr = prompt("追加したいガチャIDを入力してください（例: 1006）\n確定枠付きにする場合はIDの末尾に g を付けてください（例: 1006g）");
    if (idStr) {
        const cleanId = idStr.trim();
        const baseId = cleanId.replace(/[gfs]$/, '');
        if (gachaMasterData.gachas[baseId]) {
            tableGachaIds.push(cleanId);
            uberAdditionCounts.push(0);
            if (typeof generateRollsTable === 'function') generateRollsTable();
            if (typeof updateMasterInfoView === 'function') updateMasterInfoView();
            if (typeof updateUrlParams === 'function') updateUrlParams();
        } else {
            alert("無効なガチャIDです。");
        }
    }
}

====================
FILE: ui_target_handler.js
====================
//delete

====================
FILE: ui_target_manager.js
====================
/** @file ui_target_manager.js @description ターゲット（Find対象）の状態管理 */

function toggleTarget(id, name, rarity) {
    const index = searchTargets.findIndex(t => t.id === id);
    if (index === -1) {
        addTarget({ id, name, rarity });
    } else {
        removeTarget(id);
    }
    updateTargetListUI();
    refreshFindAreaOnly();
}

function addTarget(target) {
    if (!searchTargets.some(t => t.id === target.id)) {
        searchTargets.push(target);
    }
}

function removeTarget(id) {
    searchTargets = searchTargets.filter(t => t.id !== id);
}

function clearAllTargets() {
    // 1. 各種フィルタリング対象のIDリストを取得
    const columnConfigs = prepareColumnConfigs();
    const status = getAvailableSpecialTargets(columnConfigs);

    // 2. 伝説・限定をOFFにする（hiddenFindIds に追加）
    status.availableLegendIds.forEach(id => hiddenFindIds.add(id));
    status.availableLimitedIds.forEach(id => hiddenFindIds.add(id));

    // 3. 超激をOFFにし、その他手動追加されたターゲットもすべてクリア
    userTargetIds.clear();

    // 4. 優先表示リストをクリア
    userPrioritizedTargets = [];
    // レガシーな優先リストもクリア
    prioritizedFindIds = [];

    // 5. 元々の処理も念のため維持
    searchTargets = [];
    if (typeof updateTargetListUI === 'function') {
        updateTargetListUI();
    }
    
    // 6. テーブルを再描画してUIに反映
    if (typeof generateRollsTable === 'function') {
        generateRollsTable();
    }
}

/**
 * 予報エリア（Findエリア）のみを再描画する内部ヘルパー
 */
function refreshFindAreaOnly() {
    const container = document.getElementById('rolls-table-container');
    if (container && typeof generateFastForecast === 'function') {
        const seedEl = document.getElementById('seed');
        const initialSeed = parseInt(seedEl ? seedEl.value : 12345);
        const columnConfigs = prepareColumnConfigs();
        const findArea = document.getElementById('fast-forecast-area');
        if (findArea) {
            findArea.outerHTML = generateFastForecast(initialSeed, columnConfigs);
        }
    }
}

====================
FILE: ui_target_search_logic.js
====================
/** @file ui_target_search_logic.js @description キャラクター出現位置の計算ロジック */

function searchInAllGachas(targetId, targetName) {
    const seedEl = document.getElementById('seed');
    if (!seedEl) return;
    const initialSeed = parseInt(seedEl.value);
    const maxSearch = 10000;
    const results = [];
    const allGachaIds = Object.keys(gachaMasterData.gachas);

    allGachaIds.forEach(gachaId => {
        const gacha = gachaMasterData.gachas[gachaId];
        const findRes = findCharacterInGacha(gacha, targetId, initialSeed, maxSearch);
        if (findRes) {
            results.push({
                gachaName: gacha.name,
                gachaId: gachaId,
                distance: findRes.distance,
                track: findRes.track
            });
        }
    });

    results.sort((a, b) => a.distance - b.distance);
    displayOtherSearchResults(targetName, results);
}

function findCharacterInGacha(gacha, targetId, initialSeed, maxSearch) {
    const rng = new Xorshift32(initialSeed);
    const seeds = [];
    for (let i = 0; i < maxSearch * 2 + 100; i++) seeds.push(rng.next());

    let lastDraw = null;
    for (let i = 0; i < maxSearch; i++) {
        const resA = rollWithSeedConsumptionFixed(i * 2, gacha, seeds, lastDraw);
        if (String(resA.charId) === String(targetId)) return { distance: i + 1, track: 'A' };
        
        const resB = rollWithSeedConsumptionFixed(i * 2 + 1, gacha, seeds, lastDraw);
        if (String(resB.charId) === String(targetId)) return { distance: i + 1, track: 'B' };
    }
    return null;
}

====================
FILE: ui_target_search_view.js
====================
/** @file ui_target_search_view.js @description 検索結果のモーダル表示と操作 */

function displayOtherSearchResults(targetName, results) {
    let html = `<div style="padding: 10px;">
        <h3 style="margin-top: 0; border-bottom: 2px solid #00bbff;">「${targetName}」の出現場所</h3>
        <div style="max-height: 400px; overflow-y: auto;">
            <table style="width: 100%; border-collapse: collapse; font-size: 0.9em;">
                <thead style="position: sticky; top: 0; background: #eee;">
                    <tr><th style="padding: 5px;">ガチャ名</th><th style="padding: 5px;">位置</th></tr>
                </thead>
                <tbody>`;

    if (results.length === 0) {
        html += `<tr><td colspan="2" style="padding: 10px; text-align: center;">10000ロール以内に見つかりませんでした。</td></tr>`;
    } else {
        results.forEach(r => {
            html += `
                <tr style="border-bottom: 1px solid #eee; cursor: pointer;" onclick="addColumnAndScroll('${r.gachaId}', ${r.distance})">
                    <td style="padding: 5px;">${r.gachaName}</td>
                    <td style="padding: 5px; text-align: center; font-weight: bold; color: #0056b3;">${r.track}${r.distance}</td>
                </tr>`;
        });
    }

    html += `</tbody></table></div>
        <button onclick="closeModal()" style="width: 100%; padding: 10px; margin-top: 10px;">閉じる</button>
    </div>`;
    showModal(html);
}

function addColumnAndScroll(gachaId, distance) {
    closeModal();
    if (!tableGachaIds.includes(gachaId)) {
        tableGachaIds.push(gachaId);
        uberAdditionCounts.push(0);
    }
    if (currentRolls < distance + 10) {
        currentRolls = Math.ceil((distance + 10) / 100) * 100;
    }
    generateRollsTable();
    
    setTimeout(() => {
        const rows = document.querySelectorAll('#rolls-table-container tr');
        const targetRow = rows[distance]; // NO.行ヘッダー等があるため近似
        if (targetRow) {
            targetRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
            targetRow.style.backgroundColor = '#ffffcc';
            setTimeout(() => { targetRow.style.backgroundColor = ''; }, 2000);
        }
    }, 350);
}

====================
FILE: ui_target_view.js
====================
/** @file ui_target_view.js @description ターゲットリストのUI描画 */

function updateTargetListUI() {
    const container = document.getElementById('target-list-container');
    if (!container) return;

    if (searchTargets.length === 0) {
        container.innerHTML = '<div style="color: #999; font-size: 0.9em; padding: 5px;">ターゲットが選択されていません。「Find」からキャラを選択してください。</div>';
        return;
    }

    let html = '<div style="display: flex; flex-wrap: wrap; gap: 5px; padding: 5px;">';
    searchTargets.forEach(target => {
        const color = getRarityColor(target.rarity);
        html += `
            <div class="target-tag" style="background: ${color}22; border: 1px solid ${color}; padding: 2px 8px; border-radius: 12px; font-size: 0.85em; display: flex; align-items: center; gap: 5px;">
                <span style="font-weight: bold; color: ${color};">${target.name}</span>
                <span style="cursor: pointer; color: #666; font-weight: bold;" onclick="toggleTarget('${target.id}', '${target.name}', '${target.rarity}')">×</span>
            </div>`;
    });
    html += '<button onclick="clearAllTargets()" style="font-size: 0.8em; padding: 2px 8px; margin-left: 5px;">クリア</button>';
    html += '</div>';
    container.innerHTML = html;
}

function getRarityColor(rarity) {
    switch (rarity) {
        case 'legend': return '#ff55cc';
        case 'uber': return '#ffaa00';
        case 'limited': return '#00bbff';
        default: return '#666';
    }
}

====================
FILE: url_manager.js
====================
/** @file url_manager.js @description URLパラメータとアプリ状態の同期（保存・復元）を担当 @dependency ui_globals.js */

function processUrlParams() {
    const urlParams = new URLSearchParams(window.location.search);
    const seedParam = urlParams.get('seed');
    const simConfigParam = urlParams.get('sim_config');
    const gachasParam = urlParams.get('gachas');
    // uberAdditionCounts をリセット
    // ui_globals.js で定義された uberAdditionCounts を使用
    if (typeof uberAdditionCounts !== 'undefined') {
        uberAdditionCounts.length = 0;
        // 配列を空にする
    } else {
        // Fallback: ui_globals.js がまだ走っていない場合 (通常ありえないが)
        window.uberAdditionCounts = [];
    }

    if (gachasParam) {
        const parts = gachasParam.split('-');
        tableGachaIds = []; // reset
        
        parts.forEach((part, index) => {
            // "1006gadd5" 形式への対応
            if (part.includes('add')) {
                const subParts = part.split('add');
                const id = subParts[0];
                const addVal = parseInt(subParts[1], 10);
                
                tableGachaIds.push(id);
                // 追加数を保存
                if (!isNaN(addVal) && addVal > 0) {
                    
                    uberAdditionCounts[index] = addVal;
                } else {
                    uberAdditionCounts[index] = 0;
                }
            } else {
                tableGachaIds.push(part);
                uberAdditionCounts[index] = 0;
            }
        });
    }

    const seedEl = document.getElementById('seed');
    if (seedParam) {
        if(seedEl) seedEl.value = seedParam;
    } else {
        if(seedEl && !seedEl.value) seedEl.value = "12345";
    }

    // sim_config param の処理 (s-xxx or v-xxx)
    if (simConfigParam) {
        let rawConfig = simConfigParam;
        let mode = null;

        if (rawConfig.startsWith('s-')) {
            mode = 'sim';
            rawConfig = rawConfig.substring(2);
        } else if (rawConfig.startsWith('v-')) {
            mode = 'view';
            rawConfig = rawConfig.substring(2);
        } else {
            // 互換性: プレフィックスなしの場合はSimモードとみなす(既存動作維持)
            mode = 'sim';
        }

        const configEl = document.getElementById('sim-config');
        if(configEl) {
            // URLパラメータの + はスペースに置換済みだが、明示的に置換しておく
            configEl.value = rawConfig.replace(/\+/g, ' ');
        }
        
        if (mode === 'sim') {
            if(typeof isSimulationMode !== 'undefined') isSimulationMode = true;
        } else if (mode === 'view') {
            if(typeof isSimulationMode !== 'undefined') isSimulationMode = false;
        }
    }
}

function updateUrlParams() {
    const seed = document.getElementById('seed').value;
    const simConfig = document.getElementById('sim-config').value.trim();
    const urlParams = new URLSearchParams(window.location.search);

    if (seed) urlParams.set('seed', seed); else urlParams.delete('seed');
    
    // sim_config にプレフィックスを付与して保存
    if (simConfig) {
        const prefix = (typeof isSimulationMode !== 'undefined' && isSimulationMode) ? 's-' : 'v-';
        // スペースを + に変換するのはURLSearchParamsが自動で行うが、
        // 値としてセットする文字列自体はそのまま渡す
        urlParams.set('sim_config', prefix + simConfig);
    } else {
        urlParams.delete('sim_config');
    }
    
    // gachasパラメータの生成 (ID + "add" + Add数)
    if (tableGachaIds.length > 0) {
        const joined = tableGachaIds.map((id, index) => {
            const addVal = uberAdditionCounts[index];
            if (addVal && addVal > 0) {
                return `${id}add${addVal}`;
            }
            return id;
        }).join('-');
        urlParams.set('gachas', joined);
    } else {
        urlParams.delete('gachas');
    }

    const newUrl = `${window.location.pathname}?${urlParams.toString()}`;
    try { window.history.pushState({path: newUrl}, '', newUrl);
    } catch (e) { console.warn("URL update failed", e); }
}

====================
FILE: view_analysis.js
====================
/** @file view_analysis.js @description レア被り位置（黄色・オレンジ）のハイライト判定を担当 @dependency なし */

const RowAnalysis = {
    // 常設レア被り（黄色）: n+1とn+3のスロットが同じ
    isSimpleYellow: function(currIdx, seeds) {
        if (currIdx < 2) return false;
        const n = currIdx - 2; 
        if (n + 3 >= seeds.length) return false;
        // レア(7000未満)以外が含まれる場合は除外
        if (seeds[n] % 10000 > 6969 || seeds[n+2] % 10000 > 6969) return false;
        return (seeds[n+1] % 25) === (seeds[n+3] % 25);
    },

    // 波動バスターズ等レア被り（オレンジ）: n+1とn+3のスロットが逆順
    isSimpleOrange: function(currIdx, seeds) {
        if (currIdx < 2) return false;
        const n = currIdx - 2; 
        if (n + 3 >= seeds.length) return false;
        if (seeds[n] % 10000 > 6969 || seeds[n+2] % 10000 > 6969) return false;
        return (seeds[n+1] % 25) === (24 - (seeds[n+3] % 25));
    },

    // 連続被り判定（黄色）
    isConsecutiveYellow: function(currIdx, seeds) {
        if (currIdx < 5) return false;
        const n = currIdx - 5;
        if (currIdx + 1 >= seeds.length) return false;
        if (seeds[n] % 10000 > 6969) return false;
        if (seeds[n+2] % 10000 > 6969) return false;
        if (seeds[currIdx] % 10000 > 6969) return false;
        if (seeds[n+1] % 25 !== seeds[n+3] % 25) return false;
        return seeds[n+4] % 24 === seeds[currIdx+1] % 25;
    },

    // 連続被り判定（オレンジ）
    isConsecutiveOrange: function(currIdx, seeds) {
        if (currIdx < 5) return false;
        const n = currIdx - 5;
        if (currIdx + 1 >= seeds.length) return false;
        if (seeds[n] % 10000 > 6969) return false;
        if (seeds[n+2] % 10000 > 6969) return false;
        if (seeds[currIdx] % 10000 > 6969) return false;
        if (seeds[n+1] % 25 !== seeds[n+3] % 25) return false;
        return seeds[n+4] % 24 === (24 - (seeds[currIdx+1] % 25));
    }
};

====================
FILE: view_cell_renderer.js
====================
/** @file view_cell_renderer.js @description 個別セルの描画とレアリティ色の制御（SEED更新精度修正版） */

/**
 * テーブル用アドレス（A1, B25等）のフォーマット
 */
function formatAddress(idx) {
    if (idx === null || idx === undefined) return '';
    const row = Math.floor(idx / 2) + 1;
    const side = (idx % 2 === 0) ? 'A' : 'B';
    return `${side}${row})`;
}

/**
 * SEED値やレアリティ判定などの詳細セル群を生成する
 */
function generateDetailedCalcCells(seedIndex, seeds, tableData) {
    const calcColClass = `calc-column ${showSeedColumns ? '' : 'hidden'}`;
    if (!showSeedColumns) return `<td class="${calcColClass}"></td>`.repeat(5);
    
    const firstGachaIdWithSuffix = tableGachaIds[0] || "";
    const firstGachaId = firstGachaIdWithSuffix.replace(/[gfs]$/, '');
    const config = gachaMasterData.gachas[firstGachaId];
    
    if (!config || seedIndex + 1 >= seeds.length) return `<td class="${calcColClass}">-</td>`.repeat(5);
    
    const s0 = seeds[seedIndex];
    const rVal = s0 % 10000;
    const rates = config.rarity_rates || {};
    
    let rType = (rVal < rates.rare) ? 'rare' : 
                (rVal < rates.rare + rates.super) ? 'super' : 
                (rVal < rates.rare + rates.super + rates.uber) ? 'uber' : 
                (rVal < rates.rare + rates.super + rates.uber + rates.legend) ? 'legend' : 'rare';
                
    return `<td class="${calcColClass}">${s0}</td><td class="${calcColClass}">${rType}</td><td class="${calcColClass}">-</td><td class="${calcColClass}">-</td><td class="${calcColClass}">-</td>`;
}

/**
 * 通常のガチャ結果セル（1マス分）を生成する
 */
function generateCell(seedIndex, id, colIndex, tableData, seeds, highlightMap, isSimulationMode) {
    const cell = tableData[seedIndex]?.cells?.[colIndex];
    if (!cell || !cell.roll) return `<td>-</td>`;
    
    const r = cell.roll;
    const charName = (r.finalChar && r.finalChar.name) ? r.finalChar.name : "データ不足";
    
    let style = '';
    const gachaConfig = gachaMasterData.gachas[id];
    const isSpecialGacha = gachaConfig && (gachaConfig.name.includes("プラチナ") || gachaConfig.name.includes("レジェンド"));

    const charId = r.finalChar.id;
    const charIdStr = String(charId);

    // --- 期間限定キャラ判定 ---
    let isLimited = false;
    if (typeof limitedCats !== 'undefined' && Array.isArray(limitedCats)) {
        if (limitedCats.includes(parseInt(charId)) || limitedCats.includes(charIdStr)) {
            isLimited = true;
        }
    }

    // --- Findターゲット等のハイライト判定 ---
    // userPrioritizedTargets に含まれるキャラを緑色でハイライト
    const isPrioritized = userPrioritizedTargets.includes(charId) || userPrioritizedTargets.includes(charIdStr);

    if (isPrioritized) {
        style = 'background-color: #6EFF72; font-weight: bold;'; // ユーザー指定の緑色ハイライト
    } else if (isSimulationMode && highlightMap.get(seedIndex) === id) {
        if (isLimited || r.rarity === 'uber' || r.rarity === 'legend') {
            style = 'background:#32CD32;';
        } else {
            style = 'background:#98FB98;';
        }
    } else {
        if (isLimited) {
            style = 'background-color: #66FFFF;';
        } else if (isSpecialGacha) {
            style = '';
        } else {
            const sv = seeds[seedIndex] % 10000;
            if(sv >= 9970) style = 'background-color: #DDA0DD;';
            else if(sv >= 9940) style = 'background-color: #de59de;';
            else if(sv >= 9500) style = 'background-color: #FF4C4C;';
            else if(sv >= 6970) style = 'background-color: #ffff33;';
        }
    }

    const escapedName = charName.replace(/'/g, "\\'");
    
    // 非Simモード時のSEED更新：そのロールで最後に消費されたSEED値（seeds[seedIndex + r.seedsConsumed - 1]）をセット
    const finalUsedSeed = seeds[seedIndex + r.seedsConsumed - 1];
    const clickHandler = isSimulationMode ? 
        `onclick="onGachaCellClick(${seedIndex}, '${id}', '${escapedName}')"` :
        `onclick="updateSeedAndRefresh(${finalUsedSeed})"`;
    
    let content = "";
    if (r.isRerolled) {
        // レア被り回避時の処理
        const nextIdx = seedIndex + r.seedsConsumed;
        let destAddr = (r.isConsecutiveRerollTarget ? 'R' : '') + formatAddress(nextIdx);
        const oName = (r.originalChar && r.originalChar.name) ? r.originalChar.name : "不明";
        
        if (!isSimulationMode) {
            // 回避元のキャラ：最初に消費されたSEED（その1回分）で更新
            const originalFinalSeed = seeds[seedIndex];
            let oHtml = `<span class="char-link" onclick="event.stopPropagation(); updateSeedAndRefresh(${originalFinalSeed})">${oName}</span>`;
            
            // 回避先（最終結果）：一連の処理で最後に消費されたSEEDで更新
            let fHtml = `<span class="char-link" onclick="event.stopPropagation(); updateSeedAndRefresh(${finalUsedSeed})">${destAddr}${charName}</span>`;
            content = `${oHtml}<br>${fHtml}`;
        } else {
            content = `${oName}<br>${destAddr}${charName}`;
        }
    } else {
        content = charName;
    }
    
    return `<td class="gacha-cell" style="${style} cursor:pointer;" ${clickHandler}>${content}</td>`;
}

====================
FILE: view_description.js
====================
/** @file view_description.js @description 使い方ガイド（概要）のHTML生成と初期化を担当 */

/**
 * 概要モード（使い方ガイド）のコンテンツHTMLを生成して返す
 * 以前のindex.htmlに記述されていた内容を完全に再現しています
 * @returns {string} 使い方ガイドのHTML文字列
 */
function generateDescriptionHTML() {
    return `
        <div style="padding: 15px; background: #fff; border-radius: 4px;">
            <h3 style="margin: 0 0 10px 0; color: #333; border-bottom: 2px solid #007bff; display: inline-block;">【R_Rolls 使い方ガイド】</h3>
            <p style="margin-bottom: 15px;">このツールは、自分の「シード値（SEED）」を元に、<strong>どのガチャをどの順番で引けば狙いのキャラが手に入るか</strong>を予測・計画するためのシミュレーターです。</p>

            <h4 style="margin: 10px 0 5px 0; color: #007bff;">1. まずはシード（SEED）を入力</h4>
            <p style="margin-bottom: 10px;">
                上部の<strong>「SEED」</strong>を押し、現在の実行前シード値を入力してOKを押してください。画面に予測テーブルが表示されます。
            </p>

            <h4 style="margin: 10px 0 5px 0; color: #007bff;">2. ガチャを選んで比較する</h4>
            <p style="margin-bottom: 10px;">
                テーブル上のプルダウンメニューからガチャを切り替えられます。<strong>「＋列を追加」</strong>で複数のガチャを並べて比較できます。
            </p>

            <h4 style="margin: 10px 0 5px 0; color: #007bff;">3. Find（キャラ別検索）で狙い目を探す</h4>
            <p style="margin-bottom: 10px;">
                <strong>「Find」</strong>を押すと、2000〜10000ロール先までの「伝説枠」や「限定キャラ」を自動で検索します。
                <br>・<strong>リスト内のキャラ名</strong>をタップ：そのキャラをリストの一番上に表示します。
                <br>・<strong>「other」</strong>をタップ：ロールズに表示しているガチャ以外の全ガチャシリーズでの出現位置をまとめて検索します。
            </p>

            <h4 style="margin: 10px 0 5px 0; color: #007bff;">4. Sim（シミュレーション）でルートを決める</h4>
            <p style="margin-bottom: 10px;">
                <strong>「Sim」</strong>をONにすると、複数のガチャを跨いで引く計画を立てられます。
                <br>・<strong>テーブル上のキャラ名</strong>をタップ：現在地からそのキャラまでのルートを自動計算します。
                <br>・<strong>MaxPlat / MaxG</strong>：自動計算時に、プラチナチケットや確定11連を最大何回まで使って良いか設定できます（デフォルトは0＝温存）。
                <br>・<strong>「Txt」</strong>ボタン：作成したルートをテキスト形式で表示します。
            </p>

            <h4 style="margin: 10px 0 5px 0; color: #007bff;">5. skd（スケジュール）で開催予定をチェック</h4>
            <p style="margin-bottom: 10px;">
                <strong>「skd」</strong>を押すと、近日開催予定のガチャ一覧が表示されます。「skdで一括追加」ボタンを使うと、開催予定のガチャをすべてテーブルに並べて比較できます。
            </p>

            <h4 style="margin: 10px 0 5px 0; color: #007bff;">6. テーブルの便利な見方</h4>
            <ul style="margin: 0 0 15px 0; padding-left: 20px; font-size: 0.9em; line-height: 1.6;">
                <li><strong>No.列の背景色:</strong>
                    <ul style="padding-left: 15px; margin-top: 5px;">
                        <li><span style="background:#FFFF00; padding: 1px 3px; border-radius: 2px;">黄色</span>: 常設ガチャでのレア被り発生が予測される位置</li>
                        <li><span style="background:#FFA500; padding: 1px 3px; border-radius: 2px;">オレンジ</span>: 波動バスターズを利用し常設ガチャと組み合わせてレア被りが誘発できると予測される位置</li>
                        <li><span style="background:#FFDAB9; padding: 1px 3px; border-radius: 2px;">淡いオレンジ</span>: 表示中ガチャで実際にレア被りが発生する位置</li>
                    </ul>
                </li>
            </ul>

            <p style="font-size: 0.9em; color: #666; border-top: 1px solid #eee; padding-top: 5px;">
                ※このツールは予測値を提供するものであり、実際のゲーム内での結果を100%保証するものではありません。
            </p>
        </div>
    `;
}

/**
 * 概要コンテナにコンテンツを注入する
 * DOMが構築された後に実行する必要があります
 */
function initDescriptionView() {
    // index.html内のコンテナIDを確認
    const container = document.getElementById('description-content');
    
    if (container) {
        // コンテンツを代入
        container.innerHTML = generateDescriptionHTML();
        console.log("Description content has been successfully injected.");
    } else {
        // IDが見つからない場合のデバッグ用ログ
        console.error("Error: Element with ID 'description-content' not found in the document.");
    }
}

/**
 * 概要の表示/非表示を切り替える（既存機能の補完）
 * 以前のui_...ファイルに同名関数がある場合はそちらが優先されます
 */
window.toggleDescription = function() {
    const el = document.getElementById('description-content');
    if (el) {
        const isHidden = el.classList.contains('hidden');
        if (isHidden) {
            el.classList.remove('hidden');
            // 表示した際に確実に中身が入っているようにする
            if (!el.innerHTML || el.innerHTML === "") {
                initDescriptionView();
            }
        } else {
            el.classList.add('hidden');
        }
    }
};

====================
FILE: view_forecast.js
====================
//delete

====================
FILE: view_forecast_actions.js
====================
/** @file view_forecast_actions.js @description Find機能のユーザー操作担当 */

function toggleLegendTargets() {
    const columnConfigs = prepareColumnConfigs();
    const status = getAvailableSpecialTargets(columnConfigs);
    const ids = status.availableLegendIds;
    if (status.isLegendActive) {
        ids.forEach(id => hiddenFindIds.add(id));
    } else {
        ids.forEach(id => hiddenFindIds.delete(id));
    }
    if (typeof generateRollsTable === 'function') generateRollsTable();
}

function toggleLimitedTargets() {
    const columnConfigs = prepareColumnConfigs();
    const status = getAvailableSpecialTargets(columnConfigs);
    const ids = status.availableLimitedIds;
    if (status.isLimitedActive) {
        ids.forEach(id => hiddenFindIds.add(id));
    } else {
        ids.forEach(id => hiddenFindIds.delete(id));
    }
    if (typeof generateRollsTable === 'function') generateRollsTable();
}

function toggleUberTargets() {
    const columnConfigs = prepareColumnConfigs();
    const status = getAvailableSpecialTargets(columnConfigs);
    const ids = status.availableUberIds;

    // isUberActiveは、userTargetIdsにIDが一つでもあればtrueになる
    if (status.isUberActive) {
        // ON -> OFF : userTargetIdsから全ての超激レアを削除
        ids.forEach(id => userTargetIds.delete(id));
    } else {
        // OFF -> ON : userTargetIdsに全ての超激レアを追加
        ids.forEach(id => userTargetIds.add(id));
        // 同時に限定もONにする（hiddenFindIdsから限定IDを削除する）
        const limitedIds = status.availableLimitedIds;
        limitedIds.forEach(id => hiddenFindIds.delete(id));
    }
    if (typeof generateRollsTable === 'function') generateRollsTable();
}

function toggleCharVisibility(id) {
    const cid = isNaN(id) ? id : parseInt(id);
    if (hiddenFindIds.has(cid)) {
        hiddenFindIds.delete(cid);
    } else {
        hiddenFindIds.add(cid);
        userTargetIds.delete(cid);
    }
    if (typeof generateRollsTable === 'function') generateRollsTable();
}

function prioritizeChar(id) {
    const cid = isNaN(id) ? id : parseInt(id);

    const idx = userPrioritizedTargets.indexOf(cid);
    const pIdx = prioritizedFindIds.indexOf(cid);

    // すでに優先リストに含まれている場合は、リストから削除（優先解除）
    if (idx > -1) {
        userPrioritizedTargets.splice(idx, 1);
        if (pIdx > -1) {
            prioritizedFindIds.splice(pIdx, 1);
        }
    } else {
        // 優先リストに含まれていない場合は、リストの先頭に追加（優先指定）
        userPrioritizedTargets.unshift(cid);
        if (pIdx > -1) { // 念のため古いリストでも重複を避ける
            prioritizedFindIds.splice(pIdx, 1);
        }
        prioritizedFindIds.unshift(cid);
    }
    
    if (typeof generateRollsTable === 'function') generateRollsTable();
}

====================
FILE: view_forecast_core.js
====================
/** @file view_forecast_core.js @description Find機能のメインエントリーポイント */

function generateFastForecast(initialSeed, columnConfigs) {
    const scanRows = 2000;
    const extendedScanRows = 10000;
    const requiredSeeds = extendedScanRows * 2 + 10;
    const seeds = generateSeedsForForecast(initialSeed, requiredSeeds);
    
    const visibilityClass = (typeof showFindInfo !== 'undefined' && showFindInfo) ? '' : 'hidden';
    const specialSlots = getSpecialSlotsInfo(seeds, scanRows * 2);
    const specialTargetStatus = getAvailableSpecialTargets(columnConfigs);
    
    let summaryHtml = `<div id="forecast-summary-area" class="forecast-summary-container ${visibilityClass}" style="margin-bottom: 0; padding: 10px; background: #fdfdfd; border: 1px solid #ddd; border-bottom: none; border-radius: 4px 4px 0 0;">`;
    summaryHtml += generateForecastHeader(specialSlots, specialTargetStatus);

    columnConfigs.forEach((config) => {
        if (!config) return;
        const gachaHtml = processGachaForecast(config, seeds, scanRows, extendedScanRows);
        if (gachaHtml) summaryHtml += gachaHtml;
    });

    if (globalSearchResults) summaryHtml += renderGlobalSearchResults();

    summaryHtml += '</div>';
    return summaryHtml;
}

====================
FILE: view_forecast_logic.js
====================
/** @file view_forecast_logic.js @description Find機能の計算ロジック担当 */

function generateSeedsForForecast(initialSeed, count) {
    const seeds = new Uint32Array(count);
    const rng = new Xorshift32(initialSeed);
    for (let i = 0; i < count; i++) {
        seeds[i] = rng.next();
    }
    return seeds;
}

function formatForecastAddress(n) {
    const track = (n % 2 === 0) ? 'A' : 'B';
    const row = Math.floor(n / 2) + 1;
    return `${track}${row}`;
}

function getSpecialSlotsInfo(seeds, limit) {
    const legendSlots = [];
    const promotedSlots = [];
    for (let n = 0; n < limit; n++) {
        const val = seeds[n] % 10000;
        const addr = formatForecastAddress(n);
        if (val >= 9970) legendSlots.push(addr);
        else if (val >= 9940) promotedSlots.push(addr);
    }
    return { legendSlots, promotedSlots };
}

function getAvailableSpecialTargets(columnConfigs) {
    const processedGachaIds = new Set();
    let availableLegendIds = [];
    let availableLimitedIds = [];
    let availableUberIds = []; // 超激レアIDリストを追加
    const limitedSet = getLimitedSet();

    columnConfigs.forEach((config) => {
        if (!config || processedGachaIds.has(config.id)) return;
        processedGachaIds.add(config.id);

        // 各レアリティのIDを収集
        if (config.pool.legend) config.pool.legend.forEach(c => availableLegendIds.push(c.id));
        if (config.pool.uber) {
            config.pool.uber.forEach(c => {
                // 限定キャラは超激リストから除外
                if (!limitedSet.has(c.id) && !limitedSet.has(String(c.id))) {
                    availableUberIds.push(c.id);
                }
            });
        }
        
        ['rare', 'super', 'uber'].forEach(r => {
            if (config.pool[r]) config.pool[r].forEach(c => {
                if (limitedSet.has(c.id)) availableLimitedIds.push(c.id);
            });
        });
    });

    return {
        isLegendActive: availableLegendIds.length > 0 && availableLegendIds.some(id => !hiddenFindIds.has(id)),
        isLimitedActive: availableLimitedIds.length > 0 && availableLimitedIds.some(id => !hiddenFindIds.has(id)),
        isUberActive: availableUberIds.length > 0 && availableUberIds.some(id => userTargetIds.has(id)), // activeの判定をuserTargetIdsに変更
        isMasterActive: (typeof isMasterInfoVisible !== 'undefined') ? isMasterInfoVisible : false,
        availableLegendIds,
        availableLimitedIds,
        availableUberIds // 超激IDリストを返す
    };
}

function getLimitedSet() {
    const limitedSet = new Set();
    if (typeof limitedCats !== 'undefined' && Array.isArray(limitedCats)) {
        limitedCats.forEach(id => {
            limitedSet.add(id);
            limitedSet.add(String(id));
        });
    }
    return limitedSet;
}

function getTargetInfoForConfig(config) {
    const ids = new Set();
    const poolsToCheck = { legend: false, rare: false, super: false, uber: false };
    const limitedSet = getLimitedSet();

    ['legend', 'rare', 'super', 'uber'].forEach(r => {
        if (!config.pool[r]) return;
        config.pool[r].forEach(charObj => {
            const cid = charObj.id;
            const isAuto = isAutomaticTarget(cid);
            const isHidden = hiddenFindIds.has(cid) || hiddenFindIds.has(String(cid));
            const isManual = userTargetIds.has(cid) || userTargetIds.has(parseInt(cid));
            const isPrioritized = prioritizedFindIds.includes(cid) || prioritizedFindIds.includes(String(cid)) || prioritizedFindIds.includes(parseInt(cid));

            if ((isAuto && !isHidden) || isManual || isPrioritized) {
                ids.add(cid);
                poolsToCheck[r] = true;
            }
        });
    });

    return { ids, poolsToCheck, limitedSet };
}

function performScan(config, seeds, start, end, targets, resultMap, missingTargets) {
    const rates = config.rarity_rates;
    for (let n = start; n < end; n++) {
        if (missingTargets.size === 0 && start >= 4000) break;
        const rVal = seeds[n] % 10000;
        let rarity = 'rare';
        if (rVal < rates.rare) rarity = 'rare';
        else if (rVal < rates.rare + rates.super) rarity = 'super';
        else if (rVal < rates.rare + rates.super + rates.uber) rarity = 'uber';
        else if (rVal < rates.rare + rates.super + rates.uber + rates.legend) rarity = 'legend';

        if (targets.poolsToCheck[rarity]) {
            const pool = config.pool[rarity];
            const char = pool[seeds[n + 1] % pool.length];
            if (targets.ids.has(char.id)) {
                updateResultMap(resultMap, char, rarity, n, targets.limitedSet, missingTargets);
            }
        }
    }
}

function updateResultMap(resultMap, char, rarity, n, limitedSet, missingTargets) {
    const cid = char.id;
    if (!resultMap.has(cid)) {
        resultMap.set(cid, {
            name: gachaMasterData.cats[cid]?.name || cid,
            hits: [],
            rarity: rarity, // レアリティ情報を追加
            isLegend: (rarity === 'legend'),
            isNew: String(cid).startsWith('sim-new-'),
            isLimited: limitedSet.has(cid) || limitedSet.has(String(cid))
        });
    }
    const addr = formatForecastAddress(n);
    if (!resultMap.get(cid).hits.includes(addr)) {
        resultMap.get(cid).hits.push(addr);
        if (resultMap.get(cid).hits.length >= 3) missingTargets.delete(cid);
    }
}

function isAutomaticTarget(id) {
    const cid = String(id);
    if (cid.startsWith('sim-new-')) return true;
    if (typeof limitedCats !== 'undefined' && (limitedCats.includes(id) || limitedCats.includes(parseInt(id)))) return true;
    const cat = gachaMasterData.cats[id];
    return cat && cat.rarity === 'legend';
}

====================
FILE: view_forecast_render.js
====================
/** @file view_forecast_render.js @description Find機能のHTML描画担当 */

function generateForecastHeader(slots, status) {
    const lStr = slots.legendSlots.length > 0 ? slots.legendSlots.join(", ") : "なし";
    const pStr = slots.promotedSlots.length > 0 ? slots.promotedSlots.join(", ") : "なし";

    return `
        <div style="margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px dashed #eee; font-size: 0.85em;">
            <div style="margin-bottom: 4px;">
                <span style="font-weight:bold; color:#e91e63; background:#ffe0eb; padding:1px 4px; border-radius:3px;">伝説枠</span>
                <span style="font-family: monospace; margin-left: 5px;">${lStr}</span>
            </div>
            <div>
                <span style="font-weight:bold; color:#9c27b0; background:#f3e5f5; padding:1px 4px; border-radius:3px;">昇格枠</span>
                <span style="font-family: monospace; margin-left: 5px;">${pStr}</span>
            </div>
        </div>
        <div style="margin-bottom: 10px; text-align: left;">
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                <span onclick="clearAllTargets()" class="text-btn" title="全て非表示">×</span>
                <span class="separator">|</span>
                <span onclick="toggleLegendTargets()" class="${status.isLegendActive ? 'text-btn active' : 'text-btn'}">伝説</span>
                <span class="separator">|</span>
                <span onclick="toggleLimitedTargets()" class="${status.isLimitedActive ? 'text-btn active' : 'text-btn'}">限定</span>
                <span class="separator">|</span>
                <span onclick="toggleUberTargets()" class="${status.isUberActive ? 'text-btn active' : 'text-btn'}">超激</span>
                <span class="separator">|</span>
                <span id="toggle-master-info-btn" onclick="toggleMasterInfo()" class="${status.isMasterActive ? 'text-btn active' : 'text-btn'}">マスター</span>
                <span style="font-size: 0.8em; color: #666; margin-left: auto;">Target List</span>
            </div>
            <div style="font-size: 0.75em; color: #666; padding-left: 2px; line-height: 1.4;">
                ※キャラ名をタップで先頭へ移動。×で削除。右のアドレスをタップでルート探索。
            </div>
        </div>
    `;
}

function processGachaForecast(config, seeds, scanRows, extendedScanRows) {
    const targets = getTargetInfoForConfig(config);
    if (targets.ids.size === 0) return '';

    const resultMap = new Map();
    const missingTargets = new Set(targets.ids);

    performScan(config, seeds, 0, scanRows * 2, targets, resultMap, missingTargets);
    if (missingTargets.size > 0) {
        performScan(config, seeds, scanRows * 2, extendedScanRows * 2, targets, resultMap, missingTargets);
    }

    missingTargets.forEach(cid => {
        if (!resultMap.has(cid)) {
            resultMap.set(cid, {
                name: gachaMasterData.cats[cid]?.name || cid,
                hits: ["9999+"], isLegend: false, isNew: String(cid).startsWith('sim-new-'), isLimited: false
            });
        }
    });

    return renderGachaForecastList(config, resultMap);
}

function renderGachaForecastList(config, resultMap) {
    if (resultMap.size === 0) return '';
    let allItems = Array.from(resultMap.entries()).map(([id, data]) => ({ id, ...data }));
    
    // ユーザーが優先指定したターゲットとそれ以外を分離
    const prioritizedItems = [];
    const normalItems = [];
    const prioritizedSet = new Set(userPrioritizedTargets.map(id => String(id)));

    allItems.forEach(item => {
        if (prioritizedSet.has(String(item.id))) {
            prioritizedItems.push(item);
        } else {
            normalItems.push(item);
        }
    });

    // 優先リストを userPrioritizedTargets の順に並び替え
    prioritizedItems.sort((a, b) => {
        return userPrioritizedTargets.indexOf(a.id) - userPrioritizedTargets.indexOf(b.id);
    });

    // 通常リストのソート（ユーザー指定の優先順位）
    const rarityOrder = { 'legend': 1, 'uber': 3, 'super': 4, 'rare': 5 };
    normalItems.sort((a, b) => {
        const getPriority = (char) => {
            if (char.isLimited) return 2; // 限定キャラ
            return rarityOrder[char.rarity] || 99;
        };
        const priorityA = getPriority(a);
        const priorityB = getPriority(b);
        
        if (priorityA !== priorityB) {
            return priorityA - priorityB;
        }
        // 同じ優先度内では名前順などでソート
        return (a.name || '').localeCompare(b.name || '');
    });

    // HTMLを生成
    let prioritizedHtml = prioritizedItems.map(data => renderTargetItem(data, config)).join('');
    let normalHtml = normalItems.map(data => renderTargetItem(data, config)).join('');
    
    let separatorHtml = '';
    if (prioritizedItems.length > 0 && normalItems.length > 0) {
        separatorHtml = '<hr style="border: none; border-top: 1px dashed #ccc; margin: 4px 0;">';
    }

    return `
        <div style="margin-bottom: 8px;">
            <div style="font-weight: bold; background: #eee; padding: 2px 5px; margin-bottom: 3px; font-size: 0.85em;">${config.name}</div>
            <div style="font-family: monospace; font-size: 1em;">
                ${prioritizedHtml}
                ${separatorHtml}
                ${normalHtml}
            </div>
        </div>
    `;
}

function renderTargetItem(data, config) {
    let nameStyle = 'font-weight:bold; font-size: 0.9em; cursor:pointer;';
    if (data.isNew) nameStyle += ' color:#007bff;';
    else if (data.isLegend) nameStyle += ' color:#e91e63;';
    else if (data.isLimited) nameStyle += ' color:#d35400;';
    else nameStyle += ' color:#333;';

    const hitLinks = data.hits.map(addr => {
        if (addr === "9999+") return `<span style="color:#999; font-weight:normal;">${addr}</span>`;
        const isB = addr.startsWith('B'), rowMatch = addr.match(/\d+/);
        const row = rowMatch ? parseInt(rowMatch[0], 10) : 0;
        const sIdx = (row - 1) * 2 + (isB ? 1 : 0);
        if (row > 10000) return `<span style="margin-right:4px; color: #999; font-size: 0.9em;">${addr}</span>`;
        return `<span class="char-link" style="cursor:pointer; text-decoration:underline; margin-right:4px;" onclick="onGachaCellClick(${sIdx}, '${config.id}', '${data.name.replace(/'/g, "\\'")}', null, true, '${data.id}')">${addr}</span>`;
    }).join("");

    const otherBtn = `<span onclick="searchInAllGachas('${data.id}', '${data.name.replace(/'/g, "\\'")}')" style="cursor:pointer; margin-left:8px; color:#009688; font-size:0.8em; text-decoration:underline;" title="他ガチャを検索">other</span>`;
    
    return `
        <div style="margin-bottom: 2px; line-height: 1.3;">
            <span onclick="toggleCharVisibility('${data.id}')" style="cursor:pointer; margin-right:6px; color:#999; font-weight:bold;">×</span>
            <span style="${nameStyle}" onclick="prioritizeChar('${data.id}')">${data.name}</span>: 
            <span style="font-size: 0.85em; color: #555;">${hitLinks}${otherBtn}</span>
        </div>
    `;
}

function renderGlobalSearchResults() {
    let html = `<div style="margin-top: 15px; padding-top: 10px; border-top: 2px solid #009688;">
            <div style="font-weight:bold; color:#009688; margin-bottom:5px; font-size:0.9em;">他ガチャでの「${globalSearchResults.charName}」出現位置:</div>`;
    if (globalSearchResults.results.length === 0) {
        html += `<div style="font-size:0.85em; color:#999; padding-left:5px;">他のガチャには出現しませんでした。</div>`;
    } else {
        globalSearchResults.results.forEach(res => {
            const displayHits = res.hits.map(h => {
                if (h === "9999+") return `<span style="color:#999; font-weight:normal;">${h}</span>`;
                const isB = h.endsWith('B'), row = parseInt(h);
                return `${isB ? 'B' : 'A'}${row})`;
            }).join(", ");
            html += `<div style="font-size:0.85em; margin-bottom:2px; padding-left:5px;"><span style="color:#666;">${res.gachaName}:</span> <span style="font-family:monospace; font-weight:bold;">${displayHits}</span></div>`;
        });
    }
    return html + `</div>`;
}

====================
FILE: view_header.js
====================
/** @file view_header.js @description テーブルヘッダー（固定行・操作行）のHTML生成を担当 @dependency gacha_selector.js */

// 変更: 名前行（固定表示）のHTMLを生成
function generateNameHeaderHTML() {
    let html = ``;
    
    // index引数を追加して、uberAdditionCountsにアクセスできるように変更
    tableGachaIds.forEach((idWithSuffix, index) => {
        let id = idWithSuffix;
        let suffix = '';
        if (idWithSuffix.endsWith('f')) { suffix = 'f'; id = idWithSuffix.slice(0, -1); }
        else if (idWithSuffix.endsWith('s')) { suffix = 's'; id = idWithSuffix.slice(0, -1); }
        else if (idWithSuffix.endsWith('g')) { suffix = 'g'; id = idWithSuffix.slice(0, -1); }

        const isGuaranteed = (suffix !== '');
        const gachaConfig = gachaMasterData.gachas[id];
        if (!gachaConfig) return;
        
        let selectedLabel = `${id} ${gachaConfig.name}`;
        const options = getGachaSelectorOptions(id);
        const foundOption = options.find(o => o.value == id);
        if (foundOption) selectedLabel = foundOption.label;

        // --- 追加: add情報の表示文字列を作成 ---
        const addCount = uberAdditionCounts[index] || 0;
        let addInfoStr = '';
        if (addCount > 0) {
            // 赤字で目立たせて表示 (例: add:1)
            addInfoStr = ` <span style="font-size:0.85em; color:#d9534f; font-weight:normal;">(add:${addCount})</span>`;
        }
        // ---------------------------------------

        let displayHTML = "";
        const firstSpaceIdx = selectedLabel.indexOf(' ');
    
        if (firstSpaceIdx !== -1) {
            const part1 = selectedLabel.substring(0, firstSpaceIdx);
            const part2 = selectedLabel.substring(firstSpaceIdx + 1);
            // ガチャ名の後ろにadd情報を付与
            displayHTML = `<span style="font-size:0.85em; color:#333;">${part1}</span><br><span style="font-weight:bold; font-size:0.95em;">${part2}${addInfoStr}</span>`;
        } else {
            displayHTML = `${selectedLabel}${addInfoStr}`;
        }

        // 確定列の場合はクラスを外す（下のセルが幅を規定するため）か、
        // または幅制限のない別のクラスを検討します。
        // 今回は「下のセル（td）が幅を持つ」ため、ヘッダーは colspan のみを活かす形が安全です。
        const cls = isGuaranteed ? '' : 'class="gacha-column"'; 

        // 名前行なので ControlArea は出力しない
        html += `<th ${cls} ${isGuaranteed?'colspan="2"':''} style="vertical-align: bottom; padding-bottom: 2px;">
                    <div style="text-align: center; line-height: 1.25;">${displayHTML}</div>
                 </th>`;
    });
    return html;
}

// 変更: 操作ボタン行（スクロールと一緒に流れる）のHTMLを生成
function generateControlHeaderHTML(isInteractive) {
    let html = ``;

    tableGachaIds.forEach((idWithSuffix, index) => {
        let id = idWithSuffix;
        let suffix = '';
        if (idWithSuffix.endsWith('f')) { suffix = 'f'; id = idWithSuffix.slice(0, -1); }
        else if (idWithSuffix.endsWith('s')) { suffix = 's'; id = idWithSuffix.slice(0, -1); }
        else if (idWithSuffix.endsWith('g')) { suffix = 'g'; id = idWithSuffix.slice(0, -1); }

        const isGuaranteed = (suffix !== '');
        
        let selectorArea = '';
        let controlArea = '';

        if (isInteractive) {
            const removeBtn = `<button class="remove-btn" onclick="removeGachaColumn(${index})" style="font-size:11px; padding:2px 6px; margin-left: 5px;">x</button>`;
            let gBtnLabel = 'G';
            if (suffix === 'g') gBtnLabel = '11G';
            else if (suffix === 'f') gBtnLabel = '15G';
            else if (suffix === 's') gBtnLabel = '7G';
            
            const gBtn = `<button onclick="toggleGuaranteedColumn(${index})" style="min-width:25px; font-size:11px; padding:2px 6px;">${gBtnLabel}</button>`;
            const currentAddVal = uberAdditionCounts[index] || 0;
            const addLabelText = (currentAddVal > 0) ? `add:${currentAddVal}` : `add`;
            const triggerHtml = `<span id="add-trigger-${index}" style="font-size:12px; color:#007bff; cursor:pointer; text-decoration:underline;" onclick="showAddInput(${index})">${addLabelText}</span>`;
            
            let addSelect = `<span id="add-select-wrapper-${index}" style="display:none;">`;
            addSelect += `<select class="uber-add-select" onchange="updateUberAddition(this, ${index})" style="width: 40px; margin: 0 2px; padding: 0; font-size: 0.85em;">`;
            for(let k=0; k<=19; k++){
                addSelect += `<option value="${k}" ${k===currentAddVal ? 'selected':''}>${k}</option>`;
            }
            addSelect += `</select></span>`;
            
            // セレクター（透明）の再構築
            const options = getGachaSelectorOptions(id);
            let selector = `<select onchange="updateGachaSelection(this, ${index})" style="width: 30px; cursor: pointer; opacity: 0; position: absolute; left:0; top:0; height: 100%; width: 100%;">`;
            options.forEach(opt => {
                const selected = (opt.value == id) ? 'selected' : '';
                selector += `<option value="${opt.value}" ${selected}>${opt.label}</option>`;
            });
            selector += '</select>';
            
            const fakeSelectBtn = `<div style="width:20px; height:20px; background:#ddd; border:1px solid #999; display:flex; align-items:center; justify-content:center; border-radius:3px; font-size:10px;">▼</div>`;
            selectorArea = `<div style="position: relative; width: 20px; height: 20px;">${fakeSelectBtn}${selector}</div>`;
            
            controlArea = `<div style="display:flex; justify-content:center; align-items:center; gap:3px;">${selectorArea}${gBtn}${triggerHtml}${addSelect}${removeBtn}</div>`;
        } else {
            // Interactiveでない場合（A, Bの表示のみの箇所など）
             controlArea = `<div style="height: 20px;"></div>`;
        }
        
        const cls = isGuaranteed ? '' : 'class="gacha-column"';
        html += `<th ${cls} ${isGuaranteed?'colspan="2"':''} style="vertical-align: top; padding-top: 2px;">
                    ${controlArea}
                 </th>`;
    });
    return html;
}

====================
FILE: view_master.js
====================
/** @file view_master.js @description ガチャマスタ（キャラリスト）の詳細情報のHTML生成を担当 @dependency data_loader.js */

function toggleMasterSection(gachaId) {
    const section = document.getElementById(`master-section-${gachaId}`);
    const toggle = document.getElementById(`master-toggle-${gachaId}`);
    if (section && toggle) {
        if (section.style.display === 'none') {
            section.style.display = 'block';
            toggle.textContent = '[-]';
        } else {
            section.style.display = 'none';
            toggle.textContent = '[+]';
        }
    }
}

function generateMasterInfoHtml() {
    if (!gachaMasterData || !gachaMasterData.gachas) return '<p>データがありません</p>';
    
    // 現在選択中のユニークなガチャIDを抽出
    const uniqueIds = [...new Set(tableGachaIds.map(idStr => {
        let id = idStr;
        if (id.endsWith('f') || id.endsWith('s') || id.endsWith('g')) {
            id = id.slice(0, -1);
        }
        return id;
    }))];
    
    if (uniqueIds.length === 0) return '<p>ガチャが選択されていません</p>';

    // --- Findターゲット判定用のセットを準備 ---
    const limitedSet = new Set();
    if (typeof limitedCats !== 'undefined' && Array.isArray(limitedCats)) {
        limitedCats.forEach(id => {
            limitedSet.add(id);
            limitedSet.add(String(id));
        });
    }

    let html = '';
    uniqueIds.forEach(id => {
        const config = gachaMasterData.gachas[id];
        if (!config) return;

        // 超激レア追加設定があればプールを一時的に拡張
        const configClone = { ...config, pool: { ...config.pool } };
        if (configClone.pool.uber) configClone.pool.uber = [...configClone.pool.uber];

        const colIndex = tableGachaIds.findIndex(tid => tid.startsWith(id));
        const addCount = (colIndex >= 0 && uberAdditionCounts[colIndex]) ? uberAdditionCounts[colIndex] : 0;
        
        if (addCount > 0 && configClone.pool.uber) {
            for (let k = 1; k <= addCount; k++) {
                configClone.pool.uber.unshift({
                    id: `sim-new-${k}`,
                    name: `新規超激${k}`,
                    rarity: 'uber'
                });
            }
        }

        html += `<div style="margin-bottom: 15px; border-bottom: 1px solid #ccc; padding-bottom: 10px;">`;
        html += `<h4 style="margin: 0 0 8px 0; font-size: 1em;">
            <span id="master-toggle-${id}" style="cursor:pointer; font-family:monospace; display: inline-block; width: 20px;" onclick="toggleMasterSection('${id}')">[-]</span>
            ${config.name} (ID: ${id})
        </h4>`;

        const rates = configClone.rarity_rates || {};
        const pool = configClone.pool || {};
        
        html += `<div id="master-section-${id}" style="display: block; padding-left: 20px;">`;

        const rarities = [
            { key: 'legend', label: 'Legendary' },
            { key: 'uber', label: 'Uber' },
            { key: 'super', label: 'Super' },
            { key: 'rare', label: 'Rare' }
        ];

        rarities.forEach(r => {
            const rateVal = rates[r.key] || 0;
            const rateStr = (rateVal / 100) + '%';
            const charList = pool[r.key] || [];
            const count = charList.length;

            if (count === 0 && rateVal === 0) return;

            // キャラリスト生成
            const listStr = charList.map((c, idx) => {
                const cid = c.id;
                const cStr = String(cid);
                
                // --- 状態チェック ---
                const isHidden = hiddenFindIds.has(cid) || (typeof cid === 'number' && hiddenFindIds.has(cid));
                const isManual = userTargetIds.has(cid) || (typeof cid === 'number' && userTargetIds.has(cid));
                const isPrioritized = userPrioritizedTargets.includes(cid) || (typeof cid === 'number' && userPrioritizedTargets.includes(cid));

                // ハイライト条件:
                const isFindTarget = ((isAutomaticTarget(cid) && !isHidden) || isManual);

                let style = '';
                let titleText = 'クリックで優先表示に登録/解除';

                if (isPrioritized) {
                    style = 'background-color: #6EFF72; border: 1px solid #28a745; padding: 1px 3px; border-radius: 3px; font-weight: bold;';
                    titleText = '優先表示を解除';
                } else if (isFindTarget) {
                    style = 'background-color: #ffffcc; border: 1px solid #ff9800; padding: 1px 3px; border-radius: 3px; font-weight: bold;';
                }

                return `<span style="cursor:pointer; ${style}" onclick="prioritizeChar('${cid}')" title="${titleText}">${idx}&nbsp;${c.name}</span>`;
            }).join(', ');

            html += `<div style="margin-bottom: 3px;">`;
            html += `<strong>${r.label}:</strong> ${rateStr} (${count} cats) `;
            html += `<span style="color: #555; line-height: 1.6;">${listStr}</span>`;
            html += `</div>`;
        });

        html += `</div>`; // master-section-${id} の閉じタグ

        html += `</div>`;
    });

    return html;
}

====================
FILE: view_schedule_editor.js
====================
/** @file view_schedule_editor.js @description スケジュール予定の編集用UIレンダリング */

/**
 * 編集モードのテーブルを描画する
 */
function renderScheduleEditor(tsvContent, containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;

    const data = parseGachaTSV(tsvContent);

    let html = `
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; flex-wrap: wrap; gap: 10px;">
            <h3 style="margin:0;">スケジュール編集モード</h3>
            <div style="display: flex; gap: 5px;">
                <button onclick="toggleImportArea()" class="secondary" style="padding: 5px 10px;">テキストから読み取り</button>
                <button onclick="addNewScheduleRow()" class="add-gacha-btn" style="padding: 5px 10px;">＋ 予定を追加</button>
                <button onclick="applyScheduleTemporarily()" style="background-color: #007bff; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 11px;">一時反映</button>
                <button onclick="generateAndDownloadTSV()" style="background-color: #28a745; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 11px;">TSV保存 (DL)</button>
                <button onclick="toggleSchedule()" class="secondary" style="padding: 5px 10px;">キャンセル</button>
            </div>
        </div>

        <div id="import-area" style="display:none; background: #f8f9fa; padding: 10px; border: 1px solid #ccc; border-radius: 4px; margin-bottom: 10px;">
            <p style="margin: 0 0 5px 0; font-size: 0.8em; font-weight: bold;">解析テキストをここに貼り付けてください:</p>
            <textarea id="import-text-input" style="width: 100%; height: 80px; font-size: 10px; font-family: monospace;" placeholder="[12月 25日 ~ 29日] クリスマスギャルズ ..."></textarea>
            <div style="text-align: right; margin-top: 5px;">
                <button onclick="processTextImport()" style="background-color: #17a2b8; color: white; font-size: 11px;">解析して追加</button>
                <button onclick="toggleImportArea()" style="font-size: 11px;" class="secondary">閉じる</button>
            </div>
        </div>

        <div style="background: #fff3cd; color: #856404; padding: 8px; border-radius: 4px; font-size: 0.8em; margin-bottom: 10px; border: 1px solid #ffeeba;">
            ※カレンダーと時刻(時)を選択して編集してください。保存時に分は自動補完されます（開始:00分、終了:59分）。
        </div>
        <div class="schedule-scroll-wrapper">
        <table class="schedule-table" id="schedule-editor-table" style="font-size: 11px;">
            <thead>
                <tr>
                    <th style="min-width:120px;">開始日 / 時</th>
                    <th style="min-width:120px;">終了日 / 時</th>
                    <th style="min-width:100px;">ID / ガチャ名選択</th>
                    <th>ガチャ詳細(TSV表示名)</th>
                    <th style="min-width:45px;">超激%</th>
                    <th style="min-width:45px;">伝説%</th>
                    <th style="min-width:30px;">確定</th>
                    <th style="min-width:30px;">操作</th>
                </tr>
            </thead>
            <tbody>
    `;

    data.forEach((item) => {
        html += createEditorRowHtml(item);
    });

    html += `</tbody></table></div>`;
    container.innerHTML = html;
}

/**
 * インポートエリアの表示・非表示切り替え
 */
function toggleImportArea() {
    const area = document.getElementById('import-area');
    if (area) {
        area.style.display = (area.style.display === 'none') ? 'block' : 'none';
    }
}

/**
 * 行のHTML生成ヘルパー
 */
function createEditorRowHtml(item = null) {
    let d;
    if (item) {
        d = item;
    } else {
        // デフォルト値
        const now = new Date();
        const y = now.getFullYear();
        const m = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const aft = new Date();
        aft.setDate(now.getDate() + 2);
        const ay = aft.getFullYear();
        const am = String(aft.getMonth() + 1).padStart(2, '0');
        const ad = String(aft.getDate()).padStart(2, '0');

        let defaultId = "0";
        let defaultName = "新規予定";
        if (typeof getGachaSelectorOptions === 'function') {
            const options = getGachaSelectorOptions();
            const targetGacha = options.find(opt => opt.label.includes("ネコルガ族"));
            if (targetGacha) {
                defaultId = targetGacha.value;
                const match = targetGacha.label.match(/\)\s*(.+)$/);
                defaultName = match ? match[1].replace(/\[確定\]$/, "").trim() : targetGacha.label;
            }
        }

        d = {
            rawStart: `${y}${m}${day}`, startTime: "1100", 
            rawEnd: `${ay}${am}${ad}`, endTime: "1059",
            id: defaultId, tsvName: defaultName,
            uber: "500", legend: "30", guaranteed: false
        };
    }

    const isoStart = `${d.rawStart.substring(0,4)}-${d.rawStart.substring(4,6)}-${d.rawStart.substring(6,8)}`;
    const isoEnd = `${d.rawEnd.substring(0,4)}-${d.rawEnd.substring(4,6)}-${d.rawEnd.substring(6,8)}`;
    const startHour = d.startTime.toString().padStart(4, '0').substring(0, 2);
    const endHour = d.endTime.toString().padStart(4, '0').substring(0, 2);

    const getHourOptions = (selected) => {
        let options = "";
        for (let i = 0; i < 24; i++) {
            const h = i.toString().padStart(2, '0');
            options += `<option value="${h}" ${h === selected ? 'selected' : ''}>${h}時</option>`;
        }
        return options;
    };

    const options = typeof getGachaSelectorOptions === 'function' ? getGachaSelectorOptions(d.id) : [];
    let idOptionsHtml = "";
    options.forEach(opt => {
        const selected = (opt.value == d.id) ? 'selected' : '';
        idOptionsHtml += `<option value="${opt.value}" ${selected}>${opt.label}</option>`;
    });

    const isGuaranteedChecked = d.guaranteed ? 'checked' : '';
    
    return `
        <tr>
            <td>
                <input type="date" value="${isoStart}" class="edit-start-date" style="width:115px; display:block; margin-bottom:2px;">
                <select class="edit-start-time" style="width:60px;">${getHourOptions(startHour)}</select>
            </td>
            <td>
                <input type="date" value="${isoEnd}" class="edit-end-date" style="width:115px; display:block; margin-bottom:2px;">
                <select class="edit-end-time" style="width:60px;">${getHourOptions(endHour)}</select>
            </td>
            <td>
                <select class="edit-id" style="width:100%; max-width:150px;" onchange="updateEditorNameFromId(this)">
                    ${idOptionsHtml}
                </select>
            </td>
            <td><input type="text" value="${d.tsvName}" class="edit-name" style="width:95%; min-width:140px;"></td>
            <td><input type="number" value="${d.uber}" class="edit-uber" style="width:45px;"></td>
            <td><input type="number" value="${d.legend}" class="edit-legend" style="width:40px;"></td>
            <td><input type="checkbox" ${isGuaranteedChecked} class="edit-guaranteed"></td>
            <td><button onclick="deleteEditorRow(this)" class="remove-btn" style="padding: 2px 6px;">×</button></td>
        </tr>
    `;
}

/**
 * IDプルダウン変更時にガチャ名を自動セットする補助関数
 */
function updateEditorNameFromId(selectEl) {
    const row = selectEl.closest('tr');
    const nameInput = row.querySelector('.edit-name');
    const uberInput = row.querySelector('.edit-uber');
    if (!nameInput) return;

    const selectedText = selectEl.options[selectEl.selectedIndex].text;
    const match = selectedText.match(/\)\s*(.+)$/);
    if (match && match[1]) {
        const name = match[1].replace(/\[確定\]$/, "").trim();
        nameInput.value = name;
        if (uberInput) {
            if (name.includes("超ネコ祭") || name.includes("極ネコ祭")) uberInput.value = "900";
            else if (name.includes("超極ネコ祭")) uberInput.value = "1000";
            else if (name.includes("超国王祭")) uberInput.value = "700";
            else uberInput.value = "500";
        }
    }
}

====================
FILE: view_schedule_gantt.js
====================
/** @file view_schedule_gantt.js @description ガントチャートの描画処理 */

function renderGanttChart(data) {
    const filteredData = data.filter(item => !isPlatinumOrLegend(item));
    if (filteredData.length === 0) return '<p>表示可能なスケジュールがありません。</p>';

    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    yesterday.setHours(0, 0, 0, 0);
    const yesterdayInt = getDateInt(yesterday);
    
    let activeData = filteredData.filter(item => parseInt(item.rawEnd) >= yesterdayInt);
    const now = new Date();
    if (hideEndedSchedules) {
        activeData = activeData.filter(item => {
            const endDt = parseDateTime(item.rawEnd, item.endTime);
            return now <= endDt;
        });
    }

    activeData.sort((a, b) => {
        const endA = parseDateTime(a.rawEnd, a.endTime);
        const endB = parseDateTime(b.rawEnd, b.endTime);
        const isEndedA = now > endA;
        const isEndedB = now > endB;
        if (isEndedA !== isEndedB) return isEndedA ? -1 : 1;
        return parseInt(a.rawStart) - parseInt(b.rawStart);
    });
    if (activeData.length === 0) return '<p>表示可能な開催中のスケジュールはありません。</p>';

    let minDateInt = parseInt(activeData[0].rawStart);
    let maxEndDateTime = new Date(0);
    let maxLabelTextWidth = 0;
    activeData.forEach(item => {
        const s = parseInt(item.rawStart);
        if (s < minDateInt) minDateInt = s;
        const eDt = parseDateTime(item.rawEnd, item.endTime);
        if (eDt > maxEndDateTime) maxEndDateTime = eDt;

        let displayName = item.seriesName;
        if (item.guaranteed && !displayName.includes("[確定]")) {
            displayName += " [確定]";
        }
        
        if (typeof calcTextWidth === 'function') {
            const textW = calcTextWidth(displayName);
            if (textW > maxLabelTextWidth) maxLabelTextWidth = textW;
        }
    });
    let labelWidth = Math.max(160, maxLabelTextWidth + 20);
    if (labelWidth > 1000) labelWidth = 1000;

    let minDate = parseDateStr(String(minDateInt));
    const viewStartDate = new Date(yesterday);
    viewStartDate.setDate(viewStartDate.getDate() - 2);
    if (minDate < viewStartDate) minDate = viewStartDate;

    let chartEnd = new Date(maxEndDateTime);
    chartEnd.setHours(0, 0, 0, 0);
    chartEnd.setDate(chartEnd.getDate() + 1);

    const totalDays = Math.ceil((chartEnd - minDate) / (1000 * 60 * 60 * 24));
    if (totalDays <= 0) return '';
    const dayWidth = 50; 
    const msPerDay = 1000 * 60 * 60 * 24;
    const totalWidth = labelWidth + (totalDays * dayWidth);
    
    let currentLineHtml = '';
    if (now >= minDate && now < chartEnd) {
        const diffNowMs = now - minDate;
        const currentLineLeftPx = (diffNowMs / msPerDay) * dayWidth;
        currentLineHtml = `<div class="gantt-current-line" style="left:${currentLineLeftPx}px;"></div>`;
    }

    let headerHtml = `<div class="gantt-header" style="width: ${totalWidth}px; min-width: ${totalWidth}px; display: flex; flex-wrap: nowrap; background: #f9f9f9; height: 30px;">
        <div class="gantt-label-col" style="width:${labelWidth}px; min-width:${labelWidth}px; flex: none; display: block; height: 30px; line-height: 30px; text-align: center; box-sizing: border-box; font-weight: bold; border-right: 1px solid #ddd; padding: 0; margin: 0;">ガチャ名</div>`;
    for (let i = 0; i < totalDays; i++) {
        const d = new Date(minDate);
        d.setDate(d.getDate() + i);
        const dateStr = getShortDateStr(d);
        const isToday = getDateInt(d) === getDateInt(new Date());
        const isWeekend = d.getDay() === 0 || d.getDay() === 6;
        const cls = `gantt-date-cell${isToday ? ' today' : ''}${isWeekend ? ' weekend' : ''}`;
        headerHtml += `<div class="${cls}" style="width:${dayWidth}px; flex: none; display: block; height: 30px; line-height: 30px; text-align: center; box-sizing: border-box; border-right: 1px solid #eee; padding: 0; margin: 0;">${dateStr}</div>`;
    }
    headerHtml += `</div>`;

    let bodyHtml = '';
    activeData.forEach(item => {
        const startDateTime = parseDateTime(item.rawStart, item.startTime);
        const endDateTime = parseDateTime(item.rawEnd, item.endTime);
        const diffStartMs = startDateTime - minDate;
        const durationMs = endDateTime - startDateTime;

        let offsetPx = (diffStartMs / msPerDay) * dayWidth;
        let widthPx = (durationMs / msPerDay) * dayWidth;

        if (offsetPx < 0) { widthPx += offsetPx; offsetPx = 0; }
        const maxPx = totalDays * dayWidth;
        if (offsetPx >= maxPx) return;
        if (offsetPx + widthPx > maxPx) widthPx = maxPx - offsetPx; 
        if (widthPx <= 0) return;

        let displayName = item.seriesName;
        if (item.guaranteed && !displayName.includes("[確定]")) {
            displayName += " [確定]";
        }

        let barClass = 'gantt-bar';
        if (displayName.includes("極選抜")) barClass += ' g-kyoku';
        else if (displayName.includes("超選抜")) barClass += ' g-cho';
        else if (displayName.includes("ネコ祭")) barClass += ' g-fest';
        else if (displayName.includes("コラボ")) barClass += ' g-collab';

        const durationDays = Math.max(1, Math.round(durationMs / msPerDay));
        let rowClass = 'gantt-row';
        if (now > endDateTime) rowClass += ' row-ended';
        else if (item.guaranteed) rowClass += ' row-guaranteed';

        bodyHtml += `
            <div class="${rowClass}" style="width: ${totalWidth}px; min-width: ${totalWidth}px; display: flex; flex-wrap: nowrap; height: 30px;">
                <div class="gantt-label-col" style="width:${labelWidth}px; min-width:${labelWidth}px; flex: none; display: block; height: 30px; line-height: 30px; text-align: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; border-right: 1px solid #ddd; box-sizing: border-box; padding: 0; margin: 0;"
                title="${displayName} (ID:${item.id})">${displayName}</div>
                <div class="gantt-bar-area" style="width: ${totalDays * dayWidth}px; flex: none; position: relative; height: 30px;">
                    ${generateGridLines(totalDays, dayWidth, minDate)}
                    <div class="${barClass}" style="left: ${offsetPx}px; width: ${widthPx}px; height: 20px; top: 5px; position: absolute; display: flex; align-items: center; justify-content: center;">
                        <span class="gantt-bar-text" style="font-size: 10px; line-height: 20px;">${durationDays}日間</span>
                    </div>
                    ${currentLineHtml}
                </div>
            </div>
        `;
    });

    return `
        <div class="gantt-outer-wrapper" style="width: 100%; max-width: 100%; overflow: hidden;">
            <div style="margin-bottom: 5px; text-align: right;">
                <button onclick="saveGanttImage()" class="secondary" style="font-size: 11px; padding: 4px 8px;">画像として保存</button>
            </div>
            <div class="gantt-chart-container" style="width: 100%; max-width: 100%; overflow: hidden; border: 1px solid #ccc; background: #fff;">
                <div class="gantt-scroll-wrapper" style="overflow-x: auto; -webkit-overflow-scrolling: touch; width: 100%;">
                    <div style="width: ${totalWidth}px; min-width: ${totalWidth}px;">
                        ${headerHtml}
                        <div class="gantt-body">${bodyHtml}</div>
                    </div>
                </div>
            </div>
        </div>
    `;
}

function generateGridLines(days, width, startDate) {
    let html = '';
    for (let i = 0; i < days; i++) {
        const d = new Date(startDate);
        d.setDate(d.getDate() + i);
        const isWeekend = d.getDay() === 0 || d.getDay() === 6;
        const style = `left:${i * width}px; width:${width}px; position: absolute; height: 100%; border-right: 1px solid #eee; box-sizing: border-box; pointer-events: none;`;
        const cls = isWeekend ? 'gantt-grid-line weekend' : 'gantt-grid-line';
        html += `<div class="${cls}" style="${style}"></div>`;
    }
    return html;
}

====================
FILE: view_schedule_table.js
====================
/** @file view_schedule_table.js @description リスト形式のスケジュール表描画 */

function renderScheduleTable(tsvContent, containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    const data = parseGachaTSV(tsvContent);
    const now = new Date();
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    const yesterdayInt = getDateInt(yesterday);
    
    let filteredData = data.filter(item => parseInt(item.rawEnd) >= yesterdayInt);
    // フィルタ: 終了分の非表示設定
    if (hideEndedSchedules) {
        filteredData = filteredData.filter(item => {
            const endDt = parseDateTime(item.rawEnd, item.endTime);
            return now <= endDt;
        });
    }

    // ソート順：開催終了分を最優先 -> 通常ガチャ（日付順） -> 特別枠（日付順）
    filteredData.sort((a, b) => {
        const endA = parseDateTime(a.rawEnd, a.endTime);
        const endB = parseDateTime(b.rawEnd, b.endTime);
        const isEndedA = now > endA;
        const isEndedB = now > endB;

        if (isEndedA !== isEndedB) return isEndedA ? -1 : 1;

        const isSpecialA = isPlatinumOrLegend(a);
      
        const isSpecialB = isPlatinumOrLegend(b);
        if (isSpecialA !== isSpecialB) return isSpecialA ? 1 : -1; 

        return parseInt(a.rawStart) - parseInt(b.rawStart);
    });
    const ganttHtml = renderGanttChart(data);
    const hideBtnClass = hideEndedSchedules ? 'text-btn active' : 'text-btn';
    let html = `
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
            <h3 style="margin:0;">開催スケジュール</h3>
            <span onclick="toggleHideEnded()" class="${hideBtnClass}" style="font-size: 0.8em;">終了分を非表示</span>
        </div>
        ${ganttHtml}
        <div style="margin-top: 20px;"></div>
        <div class="schedule-scroll-wrapper">
        <table class="schedule-table">
        
        <thead>
            <tr>
                <th style="min-width:50px;">自</th>
                <th style="min-width:50px;">至</th>
                <th>ガチャ名 / 詳細</th>
                <th>レア</th>
            
                <th>激レア</th>
    
                <th>超激</th>
                <th>伝説</th>
                <th>確定</th>
            </tr>
        </thead>
        <tbody>
    `;
    filteredData.forEach((item, index) => {
        let seriesDisplay = item.seriesName ? item.seriesName : "シリーズ不明";
        
        // 重複防止：seriesNameにすでに [確定] が含まれている場合は追加しない
        if (item.guaranteed && !seriesDisplay.includes("[確定]")) {
            seriesDisplay += " [確定]";
        }

        const startStr = `${formatDateJP(item.rawStart)}<br><span style="font-size:0.85em">${formatTime(item.startTime)}</span>`;
        const endDateFormatted = formatDateJP(item.rawEnd);
        let endStr = endDateFormatted;

        const isPlat = item.seriesName.includes("プラチナ");
        const isLeg = item.seriesName.includes("レジェンド");
        let isAppliedNextStart = false;

        if (isPlat || isLeg) {
            const nextSameType = filteredData.slice(index + 1).find(nextItem => {
                if (isPlat) return nextItem.seriesName.includes("プラチナ");
                if (isLeg) return nextItem.seriesName.includes("レジェンド");
                return false;
            });
    
            if (nextSameType) {
                if (parseInt(nextSameType.rawStart) < yesterdayInt) {
                    return;
                }

                endStr = `${formatDateJP(nextSameType.rawStart)}<br><span style="font-size:0.85em">${formatTime(nextSameType.startTime)}</span>`;
                isAppliedNextStart = true;
            }
        }

        if (!isAppliedNextStart && endDateFormatted !== '永続') {
            endStr += `<br><span style="font-size:0.85em">${formatTime(item.endTime)}</span>`;
        }
        
        const isPlatLeg = isPlatinumOrLegend(item);
        const uberRateVal = parseInt(item.uber);
        let uberStyle = ( !isPlatLeg && uberRateVal !== 500 ) ? 'color:red; font-weight:bold;' : '';
        const legendRateVal = parseInt(item.legend);
        let legendStyle = ( !isPlatLeg && legendRateVal > 30 ) ? 'color:red; font-weight:bold;' : '';
        const endDateTime = parseDateTime(item.rawEnd, item.endTime);
        let rowClass = (now > endDateTime) ? "row-ended" : (item.guaranteed ? "row-guaranteed" : "");
        html += `
            <tr class="${rowClass}">
                <td>${startStr}</td>
                <td>${endStr}</td>
                <td style="text-align:left; vertical-align: middle;">
                    <div style="font-weight:bold; color:#000;">${seriesDisplay} <span style="font-weight:normal; font-size:0.9em; color:#555; user-select: text;">(ID: ${item.id})</span></div>
     
                <div style="font-size:0.85em; color:#333; margin-top:2px;">${item.tsvName}</div>
                </td>
                <td>${fmtRate(item.rare)}</td>
                <td>${fmtRate(item.supa)}</td>
                <td style="${uberStyle}">${fmtRate(item.uber)}</td>
                
                <td style="${legendStyle}">${fmtRate(item.legend)}</td>
                <td style="text-align:center; font-size:1.2em;">
                    ${item.guaranteed ?
                '<span style="color:red;">●</span>' : '-'}
                </td>
            </tr>
        `;
    });

    html += `</tbody></table></div>`;

    // 編集モードへの移行ボタンを追加
    html += `
        <div style="margin-top: 20px; padding-bottom: 30px; text-align: center;">
            <button id="enter-edit-mode-btn" class="secondary" onclick="enterScheduleEditMode()" style="padding: 10px 20px; font-size: 14px;">
                スケジュールを編集する
            </button>
        </div>
    `;

    container.innerHTML = html;
}

====================
FILE: view_schedule_utils.js
====================
/** @file view_schedule_utils.js @description スケジュール表示の共通設定とユーティリティ */

// 表示状態管理用の変数
if (typeof hideEndedSchedules === 'undefined') {
    window.hideEndedSchedules = false;
}

/** 終了分の表示/非表示を切り替えて再描画 */
function toggleHideEnded() {
    hideEndedSchedules = !hideEndedSchedules;
    if (typeof loadedTsvContent !== 'undefined' && loadedTsvContent) {
        // 再描画を実行
        renderScheduleTable(loadedTsvContent, 'schedule-container');
    }
}

/** 文字列の表示幅を概算する関数 (動的幅調整用) */
function calcTextWidth(text) {
    let width = 0;
    for (let i = 0; i < text.length; i++) {
        const code = text.charCodeAt(i);
        if ((code >= 0x00 && code < 0x81) || (code === 0xf8f0) || (code >= 0xff61 && code < 0xffa0) || (code >= 0xf8f1 && code < 0xf8f4)) {
            width += 8;
        } else {
            width += 13;
        }
    }
    return width;
}

/** 確率のフォーマット (30 -> 0.3%) */
function fmtRate(val) {
    if (!val) return "0%";
    return (parseInt(val) / 100) + "%";
}

/** ガントチャートを画像として全体保存 */
function saveGanttImage() {
    const element = document.querySelector('.gantt-chart-container');
    const scrollWrapper = document.querySelector('.gantt-scroll-wrapper');
    const scrollContent = scrollWrapper ? scrollWrapper.firstElementChild : null;
    if (!element || !scrollWrapper || !scrollContent) return;

    // 現在のコンテンツの実際の横幅を取得（全日数分）
    const fullContentWidth = scrollContent.offsetWidth;

    // 1. デスクトップ表示用のスタイルを一時的に注入
    // スマホのメディアクエリによる制限を解除するため、コンテナを全幅固定にする
    const styleOverride = document.createElement('style');
    styleOverride.id = 'gantt-save-override';
    styleOverride.innerHTML = `
        /* モバイル用の制限を完全に無効化 */
        .gantt-outer-wrapper, .gantt-chart-container, .gantt-scroll-wrapper { 
            width: ${fullContentWidth}px !important;
            max-width: none !important;
            overflow: visible !important;
        }
        .gantt-header, .gantt-row { 
            height: 30px !important; 
            display: flex !important; 
            flex-wrap: nowrap !important;
            width: ${fullContentWidth}px !important;
        }
        .gantt-label-col, .gantt-date-cell { 
            height: 30px !important;
            line-height: 30px !important; 
            display: block !important;
            padding: 0 !important;
            margin: 0 !important;
            box-sizing: border-box !important;
            text-align: center !important;
            vertical-align: middle !important;
            font-size: 11px !important;
            position: static !important; /* 固定列を解除して正しく並べる */
        }
        .gantt-bar { 
            height: 20px !important;
            top: 5px !important; 
            display: flex !important;
            align-items: center !important;
            justify-content: center !important;
        }
        .gantt-bar-text {
            line-height: 20px !important;
            font-size: 10px !important;
        }
    `;
    document.head.appendChild(styleOverride);
    
    // 2. スタイルの保存
    const originalOverflow = element.style.overflow;
    const originalWidth = element.style.width;
    const originalMaxWidth = element.style.maxWidth;
    const originalWrapperOverflow = scrollWrapper.style.overflow;

    // 要素の状態を一時変更
    element.style.overflow = 'visible';
    element.style.width = fullContentWidth + 'px';
    element.style.maxWidth = 'none';
    scrollWrapper.style.overflow = 'visible';

    // 3. html2canvasでキャプチャ
    // windowWidthをコンテンツ幅に合わせることで、モバイルブラウザでもデスクトップとして描画させる
    html2canvas(element, {
        width: fullContentWidth,
        windowWidth: fullContentWidth > 1200 ? fullContentWidth : 1200,
        scale: 2,
        useCORS: true,
        backgroundColor: "#ffffff",
        logging: false
    }).then(canvas => {
        const link = document.createElement('a');
        link.download = `gacha_schedule_${new Date().getTime()}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
        
        restoreStyles();
    }).catch(err => {
        console.error("Image capture failed:", err);
        restoreStyles();
    });

    function restoreStyles() {
        const override = document.getElementById('gantt-save-override');
        if (override) override.remove();

        element.style.overflow = originalOverflow;
        element.style.width = originalWidth;
        element.style.maxWidth = originalMaxWidth;
        scrollWrapper.style.overflow = originalWrapperOverflow;
    }
}

====================
FILE: view_table.js
====================
/** @file view_table.js @description ガチャ結果テーブル全体の描画制御（マスター情報・Sim・Txt表示・ターゲット精度同期版） */

const COLOR_ROUTE_HIGHLIGHT = '#aaddff';
const COLOR_ROUTE_UBER = '#66b2ff';
let currentTableData = null;

/**
 * テーブル描画のメインエントリーポイント
 * ガチャデータの計算、Find予報エリア、および結果テーブルの構築を制御します。
 */
function generateRollsTable() {
    try {
        // マスタデータが未ロードの場合は何もしない
        if (Object.keys(gachaMasterData.gachas).length === 0) return;

        const seedEl = document.getElementById('seed');
        if (!seedEl) return;
        
        let initialSeed = parseInt(seedEl.value, 10);
        if (isNaN(initialSeed)) { 
            initialSeed = 12345;
            seedEl.value = "12345"; 
        }
        
        // 現在の表示行数（デフォルト300〜）
        const numRolls = currentRolls;
        
        // 1. テーブル表示に必要な乱数シード配列を生成
        const seeds = [];
        const rngForSeeds = new Xorshift32(initialSeed);
        // レア被りによる消費増を考慮し、行数の約25倍程度の余裕を持って生成
        for (let i = 0; i < numRolls * 25 + 500; i++) {
            seeds.push(rngForSeeds.next());
        }

        // 2. カラム設定（ガチャIDや将来の新規キャラ追加add設定）を構築
        const columnConfigs = prepareColumnConfigs();

        // 3. 全セルのシミュレーション実行
        // この関数内で currentTableData が更新され、詳細ログ表示等で参照されます
        const tableData = executeTableSimulation(numRolls, columnConfigs, seeds);

        // 4. シミュレーション（ルート）のハイライト判定と最終シードの取得
        // 強化された判定エンジンにより、ターゲット番地（A/B・行）とのズレを解消したマップを取得
        const { highlightMap, guarHighlightMap, lastSeedValue } = preparePathHighlightMaps(initialSeed, seeds, numRolls);
        
        // Txtモード等で継続計算するために最終SEEDを保持
        finalSeedForUpdate = lastSeedValue;

        // --- HTML構築開始 ---
        let finalContainerHtml = '';

        // 5. Find（予報・ターゲット検索）エリアの生成
        if (typeof generateFastForecast === 'function') {
            finalContainerHtml += generateFastForecast(initialSeed, columnConfigs);
        }

        // 6. ガチャのマスター詳細情報エリア（キャラリスト）の生成
        // Findボタンが有効かつ、マスター表示ボタンがONの場合のみ出力
        if (typeof generateMasterInfoHtml === 'function' && showFindInfo && isMasterInfoVisible) {
            finalContainerHtml += `<div id="master-info-area" style="padding: 10px; background: #fdfdfd; border: 1px solid #ddd; border-top: none; margin-top: -16px; border-radius: 0 0 4px 4px; font-size: 0.85em;">`;
            finalContainerHtml += `<div style="border-top: 1px dashed #ccc; margin-bottom: 10px;"></div>`; 
            finalContainerHtml += generateMasterInfoHtml();
            finalContainerHtml += `</div>`;
        }

        // 7. Txt（テキストルートビュー）モードの表示
        // SimモードかつTxtボタンがONの場合、テーブルの上にテキスト形式のルートを表示
        if (isTxtMode && isSimulationMode) {
            if (typeof generateTxtRouteView === 'function') {
                const txtViewHtml = generateTxtRouteView(seeds, initialSeed);
                // ルートが空でない場合のみ表示
                if (!txtViewHtml.includes("ルートが入力されていません")) {
                    finalContainerHtml += txtViewHtml;
                }
            }
        }

        // 8. Simモード時の操作ガイド注釈
        if (isSimulationMode) {
            finalContainerHtml += `
                <div id="sim-auto-calc-notice" style="font-size: 0.75em; color: #666; padding: 5px 10px; background: #fff; border-left: 3px solid #007bff; margin: 5px 0;">
                    ※表のキャラ名をタップするとそのセルまでのルートを自動計算します。計算結果はクリックしたターゲット番地（A/Bトラック）に正確に到達するよう調整されます。
                </div>`;
        }

        // 9. メインテーブル本体の構築
        if (typeof buildTableDOM === 'function') {
            finalContainerHtml += buildTableDOM(numRolls, columnConfigs, tableData, seeds, highlightMap, guarHighlightMap);
        }

        // コンテナへの流し込み
        const container = document.getElementById('rolls-table-container');
        if (container) {
            container.innerHTML = finalContainerHtml;
        }

        // 状態表示の更新
        const resultDiv = document.getElementById('result');
        if (resultDiv) {
            resultDiv.style.display = 'block';
            resultDiv.textContent = isSimulationMode ? "Simulation Mode: Active" : "Display Mode";
        }
        
        // URLパラメータの同期
        updateUrlParams();
        
    } catch (e) {
        // 万が一の描画エラー時のフォールバック表示
        const container = document.getElementById('rolls-table-container');
        if (container) {
            container.innerHTML = `
                <div style="padding: 20px; color: #d9534f; background: #f2dede; border: 1px solid #ebccd1; border-radius: 4px;">
                    <h4 style="margin-top:0;">テーブル描画エラー</h4>
                    <p style="font-size: 0.9em;">申し訳ありません、データの処理中にエラーが発生しました。<br>SEED値やルート設定を確認してください。</p>
                    <code style="font-size: 0.8em;">${e.message}</code>
                </div>`;
        }
        console.error("Critical Table Build Error:", e);
    }
}

/**
 * executeTableSimulation をフックして、最新の計算データをグローバルに保持する
 * これにより、詳細ログ（11Gデバッグ等）で常に画面表示と一致するデータを参照可能にします。
 */
(function() {
    // 既存の関数をラップして currentTableData を更新するように拡張
    const originalExecute = (typeof executeTableSimulation === 'function') ? executeTableSimulation : null;
    
    if (originalExecute) {
        executeTableSimulation = function(n, c, s) {
            const data = originalExecute(n, c, s);
            currentTableData = data;
            return data;
        };
    }
})();

====================
FILE: view_table_data.js
====================
/** @file view_table_data.js @description シミュレーションデータ生成（将来のキャラ追加・消費SEED・二系統ID管理） */

/**
 * 各列のガチャ設定を構築する
 * 将来の超激レア追加シミュレーション(add)をここで反映する
 */
function prepareColumnConfigs() {
    return tableGachaIds.map((idWithSuffix, colIndex) => {
        let suffix = idWithSuffix.match(/[gfs]$/)?.[0] || '';
        let baseId = suffix ? idWithSuffix.slice(0, -1) : idWithSuffix;
        
        // 確定枠の通常ロール回数設定
        let normalRolls = 0;
        if (suffix === 'g') normalRolls = 10;
        else if (suffix === 'f') normalRolls = 14;
        else if (suffix === 's') normalRolls = 6;

        const configSource = gachaMasterData.gachas[idWithSuffix] || gachaMasterData.gachas[baseId];
        if (!configSource) return null;

        // 設定をコピーしてカスタマイズ
        const config = JSON.parse(JSON.stringify(configSource));
        config._guaranteedNormalRolls = normalRolls;
        config._suffix = suffix;
        
        // --- 将来の超激追加（add機能）の実装 ---
        const addCount = uberAdditionCounts[colIndex] || 0;
        if (addCount > 0 && config.pool.uber) {
            // 先頭に新規キャラを追加していく
            for (let k = 1; k <= addCount; k++) {
                config.pool.uber.unshift({ 
                    id: `sim-new-${k}`, 
                    name: `新規超激${k}`, 
                    rarity: 'uber' 
                });
            }
        }
        return config;
    });
}

/**
 * 全ガチャ列のテーブルデータをシミュレートする
 */
function executeTableSimulation(numRolls, columnConfigs, seeds) {
    const tableData = Array(numRolls * 2).fill(null).map(() => ({ cells: [], rowInfo: {} }));

    // --- 事前計算：No列の黄色・オレンジハイライト ---
    // この処理はガチャ設定に依存しないため、最初に一括で計算する
    for (let i = 2; i < numRolls * 2; i++) {
        if (seeds[i + 1] === undefined) continue;

        // レアリティチェック (固定値 6500)
        const isPrevRare = seeds[i - 2] % 10000 < 6500;
        const isCurrentRare = seeds[i] % 10000 < 6500;

        if (isPrevRare && isCurrentRare) {
            const divisor = 25; // 除数は25で固定
            const prevSlot = seeds[i - 1] % divisor;
            const currentSlot = seeds[i + 1] % divisor;

            if (prevSlot === currentSlot) {
                tableData[i].rowInfo.isNormalReroll = true; // 黄色
            } else if (prevSlot + currentSlot === (divisor - 1)) {
                tableData[i].rowInfo.isCrossReroll = true; // オレンジ
            }
        }
    }
    // --- 事前計算終了 ---

    columnConfigs.forEach((config, colIndex) => {
        if (!config) return;

        const landingMap = new Map();
        let lastDrawA = null;
        let lastDrawB = null;

        let trackA_active = true;
        let trackB_active = true;

        for (let i = 0; i < numRolls * 2; i++) {
            if (i >= seeds.length) break;

            const isTrackB = (i % 2 !== 0);
            const drawAbove = (isTrackB ? lastDrawB : lastDrawA);
            let sourceDraw = null;

            if (landingMap.has(i)) {
                sourceDraw = landingMap.get(i);
                if (isTrackB) trackB_active = true; else trackA_active = true;
            } else {
                const isActive = isTrackB ? trackB_active : trackA_active;
                if (isActive) {
                    sourceDraw = drawAbove;
                }
            }

            const drawContext = (sourceDraw || drawAbove) ? {
                originalIdAbove: drawAbove ? drawAbove.originalCharId : null,
                finalIdSource: sourceDraw ? sourceDraw.charId : null,
                rarity: sourceDraw ? sourceDraw.rarity : (drawAbove ? drawAbove.rarity : 'rare'),
                charId: sourceDraw ? sourceDraw.charId : null
            } : null;

            const rollResult = rollWithSeedConsumptionFixed(i, config, seeds, drawContext);

            // --- 事後計算：No列の淡いオレンジハイライト ---
            if (rollResult.isRerolled) {
                tableData[i].rowInfo.isActualReroll = true;
            }
            // --- 判定終了 ---

            let guaranteedResult = null;
            let alternativeGuaranteed = null;
            if (config._suffix !== '') {
                const normalCount = config._guaranteedNormalRolls;
                guaranteedResult = calculateSequentialGuaranteed(i, config, seeds, drawContext, normalCount, false);
                if (guaranteedResult.normalRollsResults && guaranteedResult.normalRollsResults.length > 0) {
                    const firstIdInG = String(guaranteedResult.normalRollsResults[0].finalChar.id);
                    const currentRollId = String(rollResult.finalChar.id);
                    guaranteedResult.isVerified = (firstIdInG === currentRollId);
                }
                if (rollResult.isRerolled) {
                    alternativeGuaranteed = calculateSequentialGuaranteed(i, config, seeds, drawContext, normalCount, true);
                }
            }

            tableData[i].cells[colIndex] = {
                gachaId: config.id,
                roll: rollResult,
                guaranteed: guaranteedResult,
                alternativeGuaranteed
            };

            const nextState = {
                rarity: rollResult.rarity,
                charId: rollResult.charId,
                originalCharId: rollResult.originalChar?.id || rollResult.charId,
                sourceGachaConfig: config
            };

            if (rollResult.isRerolled) {
                landingMap.set(i + rollResult.seedsConsumed, nextState);
                if (isTrackB) trackB_active = false; else trackA_active = false;
            } else {
                if (isTrackB) trackB_active = true; else trackA_active = true;
            }

            if (isTrackB) {
                lastDrawB = nextState;
            } else {
                lastDrawA = nextState;
            }
        }
    });
    return tableData;
}

====================
FILE: view_table_debug.js
====================
/** @file view_table_debug.js @description デバッグログ表示機能 */

let gLongPressTimer = null;

/**
 * [cite_start]デバッグモーダルの初期化 [cite: 1026-1029]
 */
function initDebugModal() {
    if (document.getElementById('debug-modal')) return;
    const modal = document.createElement('div');
    modal.id = 'debug-modal';
    modal.style = "display:none; position:fixed; z-index:9999; left:0; top:0; width:100%; height:100%; background:rgba(0,0,0,0.8); overflow:auto;";
    modal.innerHTML = `
        <div style="background:#fff; margin:5% auto; padding:20px; width:95%; max-width:800px; border-radius:8px; font-family:monospace; position:relative; box-shadow:0 4px 15px rgba(0,0,0,0.5);">
            <span onclick="this.parentElement.parentElement.style.display='none'" style="position:absolute; right:15px; top:5px; cursor:pointer; font-size:30px; font-weight:bold;">&times;</span>
            <h3 id="debug-title" style="margin-top:0;">11G Calculation Debug Log</h3>
            <div id="debug-content" style="overflow-x:auto;"></div>
        </div>`;
    document.body.appendChild(modal);
}

/**
 * [cite_start]長押しタイマー開始 [cite: 1030]
 */
window.start11GTimer = function(seedIdx, colIdx, isAlt) {
    if (!showSeedColumns) return;
    window.clear11GTimer();
    gLongPressTimer = setTimeout(() => { 
        showDebugLog(seedIdx, colIdx, isAlt); 
        gLongPressTimer = null; 
    }, 800);
};

/**
 * [cite_start]長押しタイマークリア [cite: 1031]
 */
window.clear11GTimer = function() {
    if (gLongPressTimer) { 
        clearTimeout(gLongPressTimer); 
        gLongPressTimer = null; 
    }
};

/**
 * [cite_start]詳細デバッグログの表示 [cite: 1032-1036]
 */
window.showDebugLog = function(seedIndex, colIndex, isAlt) {
    if (!showSeedColumns || !currentTableData) return;
    const cellData = currentTableData[seedIndex][colIndex];
    const data = isAlt ? cellData.alternativeGuaranteed : cellData.guaranteed;
    if (!data || !data.debugLog) return;
    
    document.getElementById('debug-title').innerText = isAlt ? "回避ルート詳細ログ" : "通常ルート詳細ログ";
    
    let logHtml = `<table border="1" style="width:100%; border-collapse:collapse; background:#fff; font-size:11px;">
        <tr style="background:#eee; position:sticky; top:0;">
            <th>Step</th><th>SEED</th><th>排出キャラ</th><th>判定詳細</th>
        </tr>`;
        
    data.debugLog.forEach(log => {
        let rerollTxt = "-";
        if (log.isRerolled) rerollTxt = `<span style="color:red;">被り回避</span><br>前回ID:${log.rerollProcess.prevId}を回避`;
        logHtml += `<tr><td>${log.step}</td><td>${log.s1 || log.seedValue}</td><td>${log.finalChar.name} (ID:${log.finalChar.id})</td><td>${rerollTxt}</td></tr>`;
    });
    
    document.getElementById('debug-content').innerHTML = logHtml + "</table>";
    document.getElementById('debug-modal').style.display = 'block';
};

====================
FILE: view_table_dom.js
====================
/** @file view_table_dom.js @description テーブルのDOM構造構築 */

/**
 * [cite_start]テーブルDOM構築のメイン [cite: 974-985]
 */
function buildTableDOM(numRolls, columnConfigs, tableData, seeds, highlightMap, guarHighlightMap) {
    const totalTrackSpan = calculateTotalTrackSpan();
    const fullTableColSpan = 2 + totalTrackSpan * 2;
    const calcColClass = `calc-column ${showSeedColumns ? '' : 'hidden'}`;

    let html = `<table style="table-layout: auto; width: 100%; border-collapse: collapse;"><thead>
        <tr>
            <th class="col-no" style="position: sticky; left: 0; z-index: 30; background: #f8f9fa; border-right: 1px solid #ddd;"></th>
            <th colspan="${totalTrackSpan}" style="text-align: center; vertical-align: middle; padding: 4px; border-right: 1px solid #ddd;">${buildHeaderButtonArea()}</th>
            <th class="col-no"></th>
            <th colspan="${totalTrackSpan}" style="text-align: center; vertical-align: middle; padding: 4px; font-weight: bold;">B</th>
        </tr>
        <tr class="sticky-row">
            <th class="col-no" style="position: sticky; top: 0; left: 0; z-index: 40; background: #f8f9fa; border-right: 1px solid #ddd;">NO.</th><th class="${calcColClass}" colspan="5">SEED</th>
            ${generateNameHeaderHTML()}
            <th class="col-no" style="border-left: 1px solid #ddd;">NO.</th><th class="${calcColClass}" colspan="5">SEED</th>
            ${generateNameHeaderHTML()}
        </tr>
        <tr class="control-row">
            <th class="col-no" style="position: sticky; left: 0; z-index: 30; background: #f8f9fa; border-right: 1px solid #ddd;"></th><th class="${calcColClass}" colspan="5"></th>
            ${generateControlHeaderHTML(true)}
            <th class="col-no" style="border-left: 1px solid #ddd;"></th><th class="${calcColClass}" colspan="5"></th>
            ${generateControlHeaderHTML(false)}
        </tr>
    </thead><tbody>`;

    for (let i = 0; i < numRolls; i++) {
        const seedIndexA = i * 2, seedIndexB = i * 2 + 1;
        html += `<tr>${renderTableRowSide(i, seedIndexA, columnConfigs, tableData, seeds, highlightMap, guarHighlightMap, true)}`;
        html += `${renderTableRowSide(i, seedIndexB, columnConfigs, tableData, seeds, highlightMap, guarHighlightMap, false)}</tr>`;
    }

    html += `<tr><td colspan="${fullTableColSpan}" style="padding: 10px; text-align: center;">
        <button onclick="addMoreRolls()">+100行</button>
        <button id="toggle-seed-btn" class="secondary" onclick="toggleSeedColumns()">${showSeedColumns ? 'SEED非表示' : 'SEED表示'}</button>
    </td></tr></tbody></table>`;
    return html;
}

/**
 * [cite_start]トラックあたりの総Colspanを計算 [cite: 978-979]
 */
function calculateTotalTrackSpan() {
    const calcColSpan = showSeedColumns ? 5 : 0;
    let gachaColSpan = 0;
    tableGachaIds.forEach(idWithSuffix => {
        let id = idWithSuffix.replace(/[gfs]$/, '');
        if (gachaMasterData.gachas[id]) {
            gachaColSpan += /[gfs]$/.test(idWithSuffix) ? 2 : 1;
        }
    });
    return calcColSpan + gachaColSpan;
}

/**
 * [cite_start]ヘッダー部分の操作ボタンエリア生成 [cite: 974-976]
 */
function buildHeaderButtonArea() {
    return `
        <div style="display: flex; flex-wrap: wrap; align-items: center; justify-content: center; gap: 3px; font-weight: normal; white-space: normal;">
            <span style="font-weight: bold; margin-right: 1px; font-size: 11px;">A</span>
            <button class="add-gacha-btn" onclick="addGachaColumn()" style="font-size: 11px; padding: 1px 4px;">＋列を追加</button>
            <button class="add-gacha-btn" style="background-color: #17a2b8; font-size: 11px; padding: 1px 4px;" onclick="addGachasFromSchedule()">skdで追加</button>
            <span id="add-id-trigger" style="cursor:pointer; text-decoration:underline; color:#007bff; font-size: 11px; font-weight:bold;" onclick="showIdInput()">IDで追加</span>
            <button class="remove-btn" onclick="resetToFirstGacha()" title="解除" style="font-size: 11px; padding: 1px 5px; margin-left: 2px;">×</button>
        </div>`;
}

====================
FILE: view_table_events.js
====================
/** @file view_table_events.js @description テーブル上のUI操作イベント */

/**
 * [cite_start]確定枠ボタンのトグル切替 (11G -> 15G -> 7G -> 無し) [cite: 1019-1021]
 */
window.toggleGStep = function(index) {
    let idFull = tableGachaIds[index];
    let base = idFull.replace(/[gfs]$/, '');
    if (idFull.endsWith('g')) tableGachaIds[index] = base + 'f';
    else if (idFull.endsWith('f')) tableGachaIds[index] = base + 's';
    else if (idFull.endsWith('s')) tableGachaIds[index] = base;
    else tableGachaIds[index] = base + 'g';
    generateRollsTable();
};

/**
 * [cite_start]add入力欄の表示 [cite: 1022]
 */
window.showAddInput = function(index) {
    const trigger = document.getElementById(`add-trigger-${index}`);
    const wrapper = document.getElementById(`add-select-wrapper-${index}`);
    if (trigger) trigger.style.display = 'none';
    if (wrapper) wrapper.style.display = 'inline';
};

/**
 * [cite_start]add選択値の更新 [cite: 1023]
 */
window.updateUberAddition = function(el, index) {
    uberAdditionCounts[index] = parseInt(el.value, 10);
    generateRollsTable();
};

====================
FILE: view_table_headers.js
====================
/** @file view_table_headers.js @description テーブルヘッダー詳細描画 */

/**
 * [cite_start]名称ヘッダーの生成 (名称右に11G表示ラベル付与) [cite: 1000-1008]
 */
function generateNameHeaderHTML() {
    let html = "";
    tableGachaIds.forEach((idWithSuffix, index) => {
        let id = idWithSuffix.replace(/[gfs]$/, '');
        const suffix = idWithSuffix.match(/[gfs]$/)?.[0] || '';
        const isGCol = suffix !== '';
        const config = gachaMasterData.gachas[id];
        if (!config) return;

        const options = (typeof getGachaSelectorOptions === 'function') ? getGachaSelectorOptions(id) : [];
        const currentOpt = options.find(o => String(o.value) === id);
        let label = currentOpt ? currentOpt.label : config.name;
        
        const addCount = uberAdditionCounts[index] || 0;
        let addStr = addCount > 0 ? ` <span style="color:#d9534f; font-weight:normal; font-size:0.8em;">(add:${addCount})</span>` : "";

        let displayHTML = "";
        const spaceIdx = label.indexOf(' ');
        if (spaceIdx !== -1) {
            const p1 = label.substring(0, spaceIdx), p2 = label.substring(spaceIdx + 1);
            displayHTML = `<span style="font-size:0.85em; color:#666;">${p1}</span><br><span style="font-weight:bold;">${p2}${addStr}</span>`;
        } else {
            displayHTML = `<span>${label}${addStr}</span>`;
        }

        if (isGCol) {
            let gText = (suffix === 'g') ? '11G' : (suffix === 'f' ? '15G' : '7G');
            html += `<th colspan="2" class="gacha-column" style="vertical-align: bottom; padding: 4px; border-right: 1px solid #ddd;">
                        <div style="display:flex; align-items:center; justify-content:center; gap:8px;">
                            <div style="text-align: center; line-height: 1.2;">${displayHTML}</div>
                            <div style="font-weight:bold; background:#d0e8ff; border-radius:3px; font-size:10px; padding:2px 8px; white-space:nowrap;">${gText}</div>
                        </div>
                     </th>`;
        } else {
            html += `<th class="gacha-column" style="vertical-align: bottom; padding: 4px; min-width: 120px; border-right: 1px solid #ddd;">
                        <div style="text-align: center; line-height: 1.2;">${displayHTML}</div>
                     </th>`;
        }
    });
    return html;
}

/**
 * [cite_start]操作ヘッダーの生成 [cite: 1009-1018]
 */
function generateControlHeaderHTML(isInteractive) {
    let html = "";
    tableGachaIds.forEach((idWithSuffix, index) => {
        let id = idWithSuffix.replace(/[gfs]$/, '');
        let suffix = idWithSuffix.match(/[gfs]$/)?.[0] || '';
        const isGCol = suffix !== '';

        let controlArea = "";
        if (isInteractive) {
            const options = (typeof getGachaSelectorOptions === 'function') ? getGachaSelectorOptions(id) : [];
            let select = `<select onchange="updateGachaSelection(this, ${index})" style="width:100%; height:100%; opacity:0; position:absolute; left:0; top:0; cursor:pointer;">`;
            options.forEach(opt => {
                select += `<option value="${opt.value}" ${String(opt.value) === id ? 'selected' : ''}>${opt.label}</option>`;
            });
            select += `</select>`;
            const pullDownBtn = `<div style="position:relative; width:18px; height:18px; background:#eee; border:1px solid #999; border-radius:3px; display:flex; align-items:center; justify-content:center; font-size:10px;">▼${select}</div>`;
            
            let gLabel = (suffix === 'g') ? '11G' : (suffix === 'f' ? '15G' : (suffix === 's' ? '7G' : 'G'));
            const gBtn = `<button onclick="toggleGStep(${index})" style="min-width:28px; font-size:10px; padding:1px 3px;">${gLabel}</button>`;
            
            const curAdd = uberAdditionCounts[index] || 0;
            const addLabel = curAdd > 0 ? `add:${curAdd}` : `add`;
            const addTrigger = `<span id="add-trigger-${index}" style="font-size:10px; color:#007bff; cursor:pointer; text-decoration:underline;" onclick="showAddInput(${index})">${addLabel}</span>`;
            
            let addSelect = `<span id="add-select-wrapper-${index}" style="display:none;"><select class="uber-add-select" onchange="updateUberAddition(this, ${index})" style="width:35px; font-size:10px;">`;
            for(let k=0; k<=20; k++) addSelect += `<option value="${k}" ${k===curAdd?'selected':''}>${k}</option>`;
            addSelect += `</select></span>`;
            
            const delBtn = `<button class="remove-btn" onclick="removeGachaColumn(${index})" style="font-size:10px; padding:1px 5px;">×</button>`;
            controlArea = `<div style="display:flex; justify-content:center; align-items:center; gap:5px;">${pullDownBtn}${gBtn}${addTrigger}${addSelect}${delBtn}</div>`;
        }

        if (isGCol) {
            html += `<th colspan="2" class="gacha-column" style="padding: 2px; border-right: 1px solid #ddd;">${controlArea}</th>`;
        } else {
            html += `<th class="gacha-column" style="padding: 2px; min-width: 120px; border-right: 1px solid #ddd;">${controlArea}</th>`;
        }
    });
    return html;
}

====================
FILE: view_table_highlight.js
====================
/** @file view_table_highlight.js @description シミュレーションモードのルートハイライト計算（確定枠・トラック遷移・物理配置完全同期版） */

/**
 * シミュレーション設定に基づき、テーブル上でハイライトすべきセルのマップを作成する
 */
function preparePathHighlightMaps(initialSeed, seeds, numRolls) {
    const highlightMap = new Map();
    const guarHighlightMap = new Map();
    let lastSeedValue = null;

    if (!isSimulationMode) return { highlightMap, guarHighlightMap, lastSeedValue };

    const simConfigEl = document.getElementById('sim-config');
    if (!simConfigEl || !simConfigEl.value.trim()) return { highlightMap, guarHighlightMap, lastSeedValue };

    // Sim設定文字列をパース
    const simConfigs = parseSimConfig(simConfigEl.value.trim());
    let rngForText = new Xorshift32(initialSeed);
    let currentSeedIndex = 0;

    // テーブルのシミュレーション（view_table_data.js）および探索エンジンと完全に同期するため、
    // トラックごとの物理的な「直上」の状態を独立して保持します。
    let lastDrawA = null;
    let lastDrawB = null;
    
    // 直前に「実際に引いた」ロールの状態（トラック遷移の起点となる情報）
    let lastRollState = null;

    for (const sim of simConfigs) {
        const config = gachaMasterData.gachas[sim.id];
        if (!config) continue;

        let normalRolls = sim.rolls;
        let isGuaranteedStep = false;

        // 確定枠設定（11G/15G/7G等）の判定
        if (sim.g) {
            if (sim.rolls === 15) { normalRolls = 14; isGuaranteedStep = true; }
            else if (sim.rolls === 7) { normalRolls = 6; isGuaranteedStep = true; }
            else if (sim.rolls === 11) { normalRolls = 10; isGuaranteedStep = true; }
            else { normalRolls = Math.max(0, sim.rolls - 1); isGuaranteedStep = true; }
        }

        // 通常ロール（確定枠に達するまでのロールを含む）の処理
        for (let k = 0; k < normalRolls; k++) {
            // 表示範囲外（生成行数×2）を超えた場合は計算のみ継続し、ハイライト登録は行わない
            const canHighlight = currentSeedIndex < numRolls * 2;
            const isTrackB = (currentSeedIndex % 2 !== 0);

            // 1. 物理的な「直上のセル」のキャラIDを特定（レア被り判定に必須）
            // テーブル描画ロジックと一致させるため、現在のセルの物理的直上（index - 2）を参照
            let originalIdAbove = null;
            if (currentSeedIndex >= 2) {
                const s0_above = seeds[currentSeedIndex - 2];
                const s1_above = seeds[currentSeedIndex - 1];
                const rates = config.rarity_rates || { rare: 6970, super: 2500, uber: 500, legend: 30 };
                const rarityAbove = determineRarity(s0_above, rates);
                const poolAbove = config.pool[rarityAbove] || [];
                if (poolAbove.length > 0) {
                    originalIdAbove = String(poolAbove[s1_above % poolAbove.length].id);
                }
            }

            // 2. 判定コンテキストの構築
            // originalIdAbove: 物理チェック用 / finalIdSource: 遷移元チェック用
            const drawContext = {
                originalIdAbove: originalIdAbove,
                finalIdSource: lastRollState ? String(lastRollState.charId) : null
            };

            if (canHighlight) {
                // 確定枠セグメントの最初の位置なら確定枠用ハイライト、それ以外は通常ハイライト
                if (isGuaranteedStep && k === 0) {
                    guarHighlightMap.set(currentSeedIndex, sim.id);
                } else {
                    highlightMap.set(currentSeedIndex, sim.id);
                }
            }

            // 3. ロールの実行と状態更新
            const rr = rollWithSeedConsumptionFixed(currentSeedIndex, config, seeds, drawContext);
            if (rr.seedsConsumed === 0) break;

            const resultState = {
                rarity: rr.rarity,
                charId: String(rr.charId),
                originalCharId: rr.originalChar ? String(rr.originalChar.id) : String(rr.charId),
                trackB: isTrackB
            };

            // 各トラックの物理履歴と、直近の遷移元状態を更新
            if (isTrackB) lastDrawB = resultState;
            else lastDrawA = resultState;
            lastRollState = resultState;

            const consumed = rr.seedsConsumed;
            currentSeedIndex += consumed;
            
            // Txtモード表示用の乱数状態を同期
            for (let x = 0; x < consumed; x++) rngForText.next();
        }

        // 確定枠（超激レア）の実行
        if (isGuaranteedStep && currentSeedIndex < seeds.length) {
            const isTrackB = (currentSeedIndex % 2 !== 0);
            const gr = rollGuaranteedUber(currentSeedIndex, config, seeds);
            
            const resultState = { 
                rarity: 'uber', 
                charId: String(gr.charId), 
                originalCharId: String(gr.charId),
                trackB: isTrackB
            };

            if (isTrackB) lastDrawB = resultState;
            else lastDrawA = resultState;
            lastRollState = resultState;

            currentSeedIndex += gr.seedsConsumed;
            for (let x = 0; x < gr.seedsConsumed; x++) rngForText.next();
        }
    }

    // 最終的なSEED値を保持（Txtモード等での継続計算用）
    lastSeedValue = rngForText.seed;

    return { highlightMap, guarHighlightMap, lastSeedValue };
}

====================
FILE: view_table_renderer.js
====================
/** @file view_table_renderer.js @description 行・セルの描画処理（G列SEED更新精度修正版） */

/**
 * 行レンダリング (A/Bサイド別)
 */
function renderTableRowSide(rowIndex, seedIndex, columnConfigs, tableData, seeds, highlightMap, guarHighlightMap, isLeftSide) {
    const rowData = tableData[seedIndex];
    if (!rowData) return ''; // データがなければ空の行を返す

    // No列の背景色を決定
    const rowInfo = rowData.rowInfo || {};
    let noColBgColor = '#f8f9fa'; // デフォルト色
    if (rowInfo.isNormalReroll) {
        noColBgColor = '#FFFF00'; // 黄色
    } else if (rowInfo.isCrossReroll) {
        noColBgColor = '#FFA500'; // オレンジ
    } else if (rowInfo.isActualReroll) {
        noColBgColor = '#FFDAB9'; // 淡いオレンジ (PeachPuff)
    }

    let sideHtml = `<td class="col-no" style="background: ${noColBgColor}; ${isLeftSide ? 'position: sticky; left: 0; z-index: 5; border-right: 1px solid #ddd;' : ''}">${rowIndex + 1}</td>`;

    // 詳細計算セルの描画 (view_cell_renderer.js で tableData の新構造に対応する必要がある)
    if (typeof generateDetailedCalcCells === 'function') {
        sideHtml += generateDetailedCalcCells(seedIndex, seeds, tableData);
    } else {
        const calcColClass = `calc-column ${showSeedColumns ? '' : 'hidden'}`;
        sideHtml += `<td class="${calcColClass}">-</td>`.repeat(5);
    }

    // 各ガチャ列のセルを描画
    tableGachaIds.forEach((idWithSuffix, colIndex) => {
        const id = idWithSuffix.replace(/[gfs]$/, '');
        const suffix = idWithSuffix.match(/[gfs]$/)?.[0] || '';
        // ★データ取得元を変更
        const data = rowData.cells ? rowData.cells[colIndex] : null;

        // 通常セルの描画 (view_cell_renderer.js で tableData の新構造に対応する必要がある)
        if (typeof generateCell === 'function') {
            sideHtml += generateCell(seedIndex, id, colIndex, tableData, seeds, highlightMap, isSimulationMode);
        } else {
            sideHtml += `<td>-</td>`;
        }

        // 確定枠セルの描画
        if (suffix) {
            // data の参照は既に新しい構造に対応済み
            if (data && (data.guaranteed || (data.result && data.result.guaranteed))) {
                sideHtml += renderGuaranteedCell(seedIndex, id, suffix, data, seeds, colIndex, guarHighlightMap);
            } else {
                sideHtml += `<td style="border: 1px solid #ddd; background: #eee; font-size:10px; text-align:center;">-</td>`;
            }
        }
    });
    return sideHtml;
}

/**
 * 確定枠セルの詳細描画
 */
function renderGuaranteedCell(seedIndex, id, suffix, data, seeds, colIndex, guarHighlightMap) {
    let cellStyle = 'white-space: normal; min-width: 80px; word-break: break-all; vertical-align: middle; border: 1px solid #ddd; font-size: 11px; padding: 0;';
    
    if (isSimulationMode && guarHighlightMap.get(seedIndex) === id) {
        cellStyle += `background-color: ${COLOR_ROUTE_UBER || '#66b2ff'};`;
    } else {
        cellStyle += `background-color: #eef7ff;`;
    }

    const gMain = data.guaranteed || (data.result ? data.result.guaranteed : null);
    const gAlt = data.alternativeGuaranteed || (data.result ? data.result.alternativeGuaranteed : null);
    
    let gContent = '<div style="padding: 4px;">---</div>';

    if (gMain && (gMain.name || (gMain.finalChar && gMain.finalChar.name))) {
        const buildGHtml = (res, isAltRoute) => {
            if (!res) return "";
            const addr = formatTableAddress(res.nextRollStartSeedIndex);
            const verifiedStyle = (!res.isVerified && showSeedColumns && !isAltRoute) ? "border-left: 3px solid #ff4444;" : "";
            const gType = (suffix === 'g') ? '11g' : (suffix === 'f' ? '15g' : '7g');
            
            const charName = res.name || (res.finalChar ? res.finalChar.name : "データ不足");
            const escapedName = charName.replace(/'/g, "\\'");
            
            // 非Simモード時：確定枠までの全ロールを終えた「最終消費SEED（res.nextRollStartSeedIndex - 1）」で更新
            // これにより、新しいテーブルの1行目が正確に次のロール開始SEED（res.nextRollStartSeedIndex）となります
            const finalSeedInProcess = seeds[res.nextRollStartSeedIndex - 1];
            
            let clickAction = isSimulationMode ?
                `onclick="if(!event.ctrlKey) onGachaCellClick(${seedIndex}, '${id}', '${escapedName}', '${gType}')"` :
                (res.nextRollStartSeedIndex >= 0 ? `onclick="if(!event.ctrlKey) updateSeedAndRefresh(${finalSeedInProcess})"` : "");
            
            const debugAttrs = showSeedColumns ? 
                `onpointerdown="window.start11GTimer(${seedIndex}, ${colIndex}, ${isAltRoute})" onpointerup="window.clear11GTimer()" onpointerleave="window.clear11GTimer()"` : "";
            
            return `<div ${clickAction} ${debugAttrs} style="cursor:pointer; padding:4px; ${verifiedStyle} ${isAltRoute ? 'border-bottom:1px dashed #ccc;' : ''}">${addr})<span class="char-link" style="font-weight:bold; color:#0056b3;">${charName}</span></div>`;
        };

        gContent = gAlt ? buildGHtml(gAlt, true) + buildGHtml(gMain, false) : buildGHtml(gMain, false);
    }
    
    return `<td class="gacha-cell gacha-column" style="${cellStyle}">${gContent}</td>`;
}

/**
 * テーブル用アドレス（A1, B25等）のフォーマット
 */
function formatTableAddress(index) {
    if (index === null || index === undefined || index < 0) return "---";
    const row = Math.floor(index / 2) + 1;
    const track = (index % 2 === 0) ? "A" : "B";
    return `${track}${row}`;
}

