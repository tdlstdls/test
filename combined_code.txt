====================
FILE: data_loader.js
====================
/** @file data_loader.js @description 外部データ（CSV/TSV）の非同期取得とマスタデータの構築を担当 @dependency cats.js, gacha_series.js */

/**
 * [gatya.tsv Data Structure Memo]
 * * ■ 基本構造
 * ・1-10列目 (Idx 0-9): 年月日・時刻情報
 * Idx 0: 開始年月日 (YYYYMMDD)
 * Idx 1: 開始時刻 (HHMM)
 * Idx 2: 終了年月日 (YYYYMMDD)
 * Idx 3: 終了時刻 (HHMM)
 * Idx 8: レアロールズ対象フラグ (1以外は除外)
 * * ・11列目以降 (Idx 10~): ガチャ情報ブロック (15列/ブロック の繰り返し)
 * ブロック開始インデックスを i (10, 25, 40...) とすると:
 * i+0  : ガチャID (Gacha ID)
 * i+6  : レアレート (Rare Rate)
 * i+8  : 激レアレート (Super Rare Rate)
 * i+10 : 超激レアレート (Uber Rare Rate)
 * i+11 : 超激レア確定フラグ (Guaranteed Flag, 1=確定)
 * i+12 : 伝説レアレート (Legend Rare Rate)
 * i+14 : 日本語説明文 (Description)
 */

// グローバル変数 (データ保持用)
let gachaMasterData = { cats: {}, gachas: {} };
let loadedTsvContent = null; // スケジュールデータ (gatya.tsv)

// 全データのロードと構築を行うメイン関数
async function loadAllData() {
    console.log("Loading data...");
    
    // 1. キャラクターデータ (cats.js) の処理
    processCatsData();

    // 2. マスタデータ (CSV/TSV) の取得と構築
    try {
        const [csvRes, tsvRes, gatyaRes] = await Promise.all([
            fetch('GatyaDataSetR1.csv'),
            fetch('GatyaData_Option_SetR.tsv'),
            fetch('gatya.tsv') // スケジュールデータもここで取得
        ]);

        if (!csvRes.ok) throw new Error("GatyaDataSetR1.csv fetch failed");
        if (!tsvRes.ok) throw new Error("GatyaData_Option_SetR.tsv fetch failed");
        
        const csvText = await csvRes.text();
        const tsvText = await tsvRes.text();
        let gatyaTsvText = null;
        
        if (gatyaRes.ok) {
            gatyaTsvText = await gatyaRes.text();
            loadedTsvContent = gatyaTsvText;
            console.log("gatya.tsv loaded successfully.");
        } else {
            console.warn("gatya.tsv not found.");
        }

        // マスタデータの構築
        const gachasMaster = buildGachaMaster(gachaMasterData.cats, csvText, tsvText);
        
        // gatya.tsv から正確なレート情報を反映
        if (gatyaTsvText) {
            applyTsvRates(gachasMaster, gatyaTsvText);
        }

        gachaMasterData.gachas = gachasMaster;
        
        console.log("Master Data Built:", Object.keys(gachasMaster).length, "gachas loaded.");
        return true;

    } catch (e) {
        console.error("Critical Data Load Error:", e);
        return false;
    }
}

// cats.js のデータを gachaMasterData.cats に変換
function processCatsData() {
    const fallbackCats = [{id:31, name:"ネコぼさつ", rarity:3}];
    let catsData = (typeof cats !== 'undefined') ? cats : fallbackCats;

    const rarityMap = { 0: "nomal", 1: "ex", 2: "rare", 3: "super", 4: "uber", 5: "legend" };
    const catsMaster = {};
    
    for (const cat of catsData) {
        catsMaster[cat.id] = { ...cat, rarity: rarityMap[cat.rarity] || "rare" };
    }
    gachaMasterData.cats = catsMaster;
}

// マスタデータ構築ロジック (CSV行番号 = ID)
function buildGachaMaster(catsMaster, csvText, tsvText) {
    const gachasMaster = {};

    // 1. CSVを行ごとに分割 (1行目=ID:0, 2行目=ID:1...)
    const gachaPools = csvText.split(/\r?\n/);

    // 2. Option TSVをパースして GatyaSetID -> seriesID のマップを作成
    const tsvLines = tsvText.split(/\r?\n/);
    const headers = tsvLines[0].split('\t').map(h => h.trim());
    const idIdx = headers.indexOf('GatyaSetID');
    const seriesIdx = headers.indexOf('seriesID');

    const gachaSeriesMap = {}; 
    if (idIdx !== -1 && seriesIdx !== -1) {
        for (let i = 1; i < tsvLines.length; i++) {
            const line = tsvLines[i];
            if (!line.trim()) continue;
            const cols = line.split('\t');
            const gID = parseInt(cols[idIdx]);
            const sID = parseInt(cols[seriesIdx]);
            if (!isNaN(gID) && !isNaN(sID)) {
                gachaSeriesMap[gID] = sID;
            }
        }
    }

    // gacha_series.js のデータ
    let seriesList = (typeof gacha_series !== 'undefined') ? gacha_series : [];

    // 3. 全結合して gachasMaster を構築
    gachaPools.forEach((line, index) => {
        if (!line.trim()) return;

        // CSVの行番号(index) = ガチャID
        const gachaID = index;
        const poolCats = line.split(',').map(s => parseInt(s.trim())).filter(n => !isNaN(n));

        const seriesID = gachaSeriesMap[gachaID];

        // デフォルト情報
        let seriesInfo = { 
            name: `Gacha ID: ${gachaID}`, 
            rare: 0, supa: 0, uber: 0, legend: 0, sort: 999 
        };
        
        // gacha_series.js から名前とレートを引く
        if (seriesID !== undefined) {
            const found = seriesList.find(s => s.series_id === seriesID);
            if (found) {
                seriesInfo = found;
            }
        }

        // キャラクタープール構築
        const pool = { rare: [], super: [], uber: [], legend: [], nomal: [], ex: [] };
        for (const catId of poolCats) {
            const catInfo = catsMaster[catId];
            if (catInfo && pool[catInfo.rarity] !== undefined) {
                pool[catInfo.rarity].push({ id: catInfo.id, name: catInfo.name });
            }
        }

        gachasMaster[gachaID] = {
            id: gachaID.toString(),
            name: seriesInfo.name, // ガチャ名称
            rarity_rates: { 
                rare: seriesInfo.rare || 0, 
                super: seriesInfo.supa || 0,
                uber: seriesInfo.uber || 0, 
                legend: seriesInfo.legend || 0 
            },
            pool: pool,
            sort: seriesInfo.sort || 999,
            series_id: seriesID,
            guaranteed: false // デフォルトはfalse
        };
    });

    return gachasMaster;
}

// gatya.tsv からレート情報と確定情報を抽出してマスタデータに適用する
function applyTsvRates(gachasMaster, tsvContent) {
    const lines = tsvContent.split('\n');
    lines.forEach(line => {
        if (line.trim().startsWith('[') || !line.trim()) return;
        const cols = line.split('\t');
        if (cols.length < 15) return; // 最小カラム数チェック

        // 9列目(Idx 8)が「1」以外の行は除外（レアロールズ対象外）
        if (cols[8] !== '1') return;

        // 11列目(Idx 10)から15列ごとにブロックが存在する
        for (let i = 10; i < cols.length; i += 15) {
            // ブロックの必須カラムが存在するか確認
            if (i + 14 >= cols.length) break;

            const gachaIdStr = cols[i];
            const gachaId = parseInt(gachaIdStr);
            
            // IDが無効、または-1の場合はスキップ
            if (isNaN(gachaId) || gachaId < 0) continue;

            // 定義に基づきレート情報を取得
            // i+6: Rare, i+8: Super, i+10: Uber, i+11: Guaranteed, i+12: Legend
            const rateRare = parseInt(cols[i + 6]) || 0;
            const rateSupa = parseInt(cols[i + 8]) || 0;
            const rateUber = parseInt(cols[i + 10]) || 0;
            const isGuaranteed = cols[i + 11] === '1';
            const rateLegend = parseInt(cols[i + 12]) || 0;

            if (gachasMaster[gachaId]) {
                gachasMaster[gachaId].rarity_rates = {
                    rare: rateRare,
                    super: rateSupa,
                    uber: rateUber,
                    legend: rateLegend
                };
                // 確定フラグを保存
                gachasMaster[gachaId].guaranteed = isGuaranteed;
            }
        }
    });
}

====================
FILE: gacha_selector.js
====================
/** @file gacha_selector.js @description ガチャ選択用プルダウンのオプション項目生成を担当 @dependency data_loader.js, schedule_logic.js */

function getGachaSelectorOptions(selectedId) {
    const now = new Date();
    const formatInt = (d) => {
        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        return parseInt(`${y}${m}${day}`, 10);
    };
    const yesterdayDate = new Date(now);
    yesterdayDate.setDate(yesterdayDate.getDate() - 1);
    const yesterdayInt = formatInt(yesterdayDate);

    const toShortDate = (str) => {
        if(!str || str.length < 8) return str;
        return `${parseInt(str.substring(4,6))}/${parseInt(str.substring(6,8))}`;
    };

    let scheduleRaw = [];
    if (loadedTsvContent && typeof parseGachaTSV === 'function') {
        scheduleRaw = parseGachaTSV(loadedTsvContent);
    }
    
    const usedIds = new Set();
    const allOptions = [];

    // Group 1: スケジュール (終了日 >= 昨日)
    let scheduledItems = [];
    scheduleRaw.forEach(item => {
        if(!gachaMasterData.gachas[item.id]) return;

        const masterName = gachaMasterData.gachas[item.id].name;
        const checkStr = (masterName + item.tsvName).replace(/\s/g, "");
        const isSpecial = checkStr.includes("プラチナ") || checkStr.includes("レジェンド");

        const e = parseInt(item.rawEnd, 10);

        // 表示条件: 特殊ガチャ または 終了日が昨日以降
        if (isSpecial || e >= yesterdayInt) {
            scheduledItems.push({
                id: item.id,
                name: masterName,
                tsvName: item.tsvName || item.name,
                rawStart: item.rawStart,
                rawEnd: item.rawEnd,
                s: parseInt(item.rawStart, 10),
                isSpecial: isSpecial,
                isGuaranteed: item.guaranteed // 確定フラグを引き継ぐ
            });
        }
    });

    scheduledItems.sort((a, b) => {
        if (a.isSpecial !== b.isSpecial) return a.isSpecial ? 1 : -1;
        return a.s - b.s;
    });

    scheduledItems.forEach(item => {
        if (usedIds.has(item.id.toString())) return;
        
        // 確定フラグがある場合、名称に [確定] を付与 (既に含まれていれば二重付与しない)
        let displayName = item.name;
        if (item.isGuaranteed && !displayName.includes("確定")) {
            displayName += " [確定]";
        }

        // 変更前: const baseName = `${displayName} (${item.id})`;
        // 変更前: let label = item.isSpecial ? ... : ...;

        // 変更後: IDを日付の直後に配置して見切れを防止
        // view_table.jsのヘッダー表示（スペースで改行）に合わせて、"日付(ID) ガチャ名" の形式にする
        let datePart = item.isSpecial 
            ? `${toShortDate(item.rawStart)}~`
            : `${toShortDate(item.rawStart)}~${toShortDate(item.rawEnd)}`;
        
        // 日付とIDの間を詰めることで、view_table.js側で「日付(ID)」の塊として認識させ、改行後にガチャ名を表示させる
        let label = `${datePart}(${item.id}) ${displayName}`;
        
        allOptions.push({ value: item.id, label: label });
        usedIds.add(item.id.toString());
    });

    // Group 2: シリーズ最新 (G1で表示済みはスキップ)
    const seriesMaxMap = new Map();
    Object.values(gachaMasterData.gachas).forEach(g => {
        if (usedIds.has(g.id)) return;
        if (g.series_id !== undefined && g.sort < 800) {
            const current = seriesMaxMap.get(g.series_id);
            if (!current || parseInt(g.id) > parseInt(current.id)) {
                seriesMaxMap.set(g.series_id, g);
            }
        }
    });

    const seriesList = Array.from(seriesMaxMap.values());
    seriesList.sort((a, b) => a.sort - b.sort);

    seriesList.forEach(g => {
        allOptions.push({ value: g.id, label: `${g.name} (${g.id})` });
        usedIds.add(g.id);
    });

    // Group 3: その他
    const othersList = [];
    Object.values(gachaMasterData.gachas).forEach(g => {
        if (usedIds.has(g.id)) return;
        othersList.push(g);
    });

    othersList.sort((a, b) => parseInt(b.id) - parseInt(a.id));

    othersList.forEach(g => {
        allOptions.push({ value: g.id, label: `${g.id} ${g.name}` });
        usedIds.add(g.id);
    });

    if (selectedId && !usedIds.has(selectedId)) {
        const missing = gachaMasterData.gachas[selectedId];
        if (missing) {
            allOptions.push({ value: selectedId, label: `${selectedId} ${missing.name} (選択中)` });
        }
    }

    return allOptions;
}

====================
FILE: gacha_series.js
====================
/** @file gacha_series.js @description 各ガチャシリーズのメタデータ（名称、デフォルトレート、ソート順）の定義 @dependency なし */

/**
 * Sortの区分について
 * 100～199：ネコ祭
 * 200～299：バスターズ
 * 300～399：常設
 * 400～499：季節
 * 500～599：４セレクション
 * 600～699：コラボ
 * 700～799：新年その他
 * 800～899：過去分
 */

const gacha_series = [
    {"series_id":0,"name":"ネコルガ族", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":300},
    {"series_id":1,"name":"ダイナマイツ", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":301},
    {"series_id":2,"name":"バサラーズ", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":302},
    {"series_id":3,"name":"ギャラクシーギャルズ", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":303},
    {"series_id":4,"name":"ドラゴンエンペラーズ", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":304},
    {"series_id":5,"name":"レッドバスターズ", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":200},
    {"series_id":6,"name":"ウルトラソウルズ", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":305},
    {"series_id":7,"name":"ダークヒーローズ", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":306},
    {"series_id":8,"name":"ハロウィン", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":400},
    {"series_id":9,"name":"クリスマスギャルズ", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":401},
    {"series_id":10,"name":"忘年会", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":801},
    {"series_id":11,"name":"ゆるドラシル", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":802},
    {"series_id":12,"name":"メタルスラッグディフェンス", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":803},
    {"series_id":13,"name":"メルクストーリア", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":600},
    {"series_id":14,"name":"生きろ！マンボウ！", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":601},
    {"series_id":15,"name":"消滅都市", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":602},
    {"series_id":16,"name":"新年", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":700},
    {"series_id":17,"name":"ケリ姫スイーツ", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":603},
    {"series_id":18,"name":"ギガントゼウス", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":307},
    {"series_id":19,"name":"超ネコ祭", "rare":6470, "supa":2600, "uber":900, "legend":30,"sort":100},
    {"series_id":20,"name":"サマーガールズ", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":804},
    {"series_id":21,"name":"プラチナガチャ", "rare":0, "supa":0, "uber":10000, "legend":0,"sort":102},
    {"series_id":22,"name":"エアバスターズ", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":201},
    {"series_id":23,"name":"魔法少女まどか☆マギカ", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":604},
    {"series_id":24,"name":"アイアンウォーズ", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":308},
    {"series_id":25,"name":"クラッシュフィーバー", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":805},
    {"series_id":26,"name":"イースターカーニバル", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":402},
    {"series_id":27,"name":"極ネコ祭", "rare":6470, "supa":2600, "uber":900, "legend":30,"sort":101},
    {"series_id":28,"name":"ギャルズモンスターズ", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":309},
    {"series_id":29,"name":"ぐでたま", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":806},
    {"series_id":30,"name":"ウルトラセレクション", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":807},
    {"series_id":31,"name":"ミラクルセレクション", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":808},
    {"series_id":32,"name":"メタルバスターズ", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":202},
    {"series_id":33,"name":"エレメンタルピクシーズ", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":310},
    {"series_id":34,"name":"劇場版 Fate stay night", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":605},
    {"series_id":35,"name":"超選抜祭", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":701},
    {"series_id":36,"name":"実況パワフルプロ野球", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":809},
    {"series_id":37,"name":"エヴァンゲリオン", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":606},
    {"series_id":38,"name":"ビックリマン", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":607},
    {"series_id":39,"name":"極選抜祭", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":702},
    {"series_id":40,"name":"ストリートファイターV", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":810},
    {"series_id":41,"name":"エクセレントセレクション", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":811},
    {"series_id":42,"name":"超極ネコ祭", "rare":6470, "supa":2500, "uber":1000, "legend":30,"sort":104},
    {"series_id":43,"name":"初音ミク", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":608},
    {"series_id":44,"name":"エヴァンゲリオン2nd", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":609},
    {"series_id":45,"name":"波動バスターズ", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":203},
    {"series_id":46,"name":"レジェンドガチャ", "rare":0, "supa":0, "uber":9500, "legend":500,"sort":103},
    {"series_id":47,"name":"超国王祭", "rare":6770, "supa":2500, "uber":700, "legend":30,"sort":105},
    {"series_id":48,"name":"バレンタインギャルズ", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":403},
    {"series_id":49,"name":"らんま1/2", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":610},
    {"series_id":50,"name":"女王祭", "rare":6940, "supa":2500, "uber":500, "legend":60,"sort":106},
    {"series_id":51,"name":"くにおくん熱血大運動会", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":812},
    {"series_id":52,"name":"ホワイトデー", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":404},
    {"series_id":53,"name":"ジューンブライド", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":405},
    {"series_id":54,"name":"ストリートファイター BLUE TEAM", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":611},
    {"series_id":55,"name":"ストリートファイター RED TEAM", "rare":6970, "supa":2500, "uber":500, "legend":30,"sort":612},
    {"series_id":56,"name":"超生命体バスターズ", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":204},
    {"series_id":57,"name":"くにお熱血大運動会 赤組", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":703},
    {"series_id":58,"name":"りき熱血大運動会 白組", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":704},
    {"series_id":59,"name":"バスターズ祭", "rare":6800, "supa":2500, "uber":700, "legend":0,"sort":107},
    {"series_id":60,"name":"メタルスラッグアタック", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":613},
    {"series_id":61,"name":"9000万DL記念選抜", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":813},
    {"series_id":62,"name":"神魔之塔", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":814},
    {"series_id":63,"name":"るろうに剣心", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":614},
    {"series_id":64,"name":"サマーガールズ サンシャイン", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":406},
    {"series_id":65,"name":"サマーガールズ ブルーオーシャン", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":407},
    {"series_id":66,"name":"ウルトラ4セレクション", "rare":6770, "supa":2500, "uber":700, "legend":30,"sort":500},
    {"series_id":67,"name":"ミラクル4セレクション", "rare":6770, "supa":2500, "uber":700, "legend":30,"sort":501},
    {"series_id":68,"name":"エクセレント4セレクション", "rare":6770, "supa":2500, "uber":700, "legend":30,"sort":502},
    {"series_id":69,"name":"1億チケットガチャ", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":815},
    {"series_id":70,"name":"億DL記念選抜", "rare":6930, "supa":2500, "uber":500, "legend":70,"sort":108},
    {"series_id":71,"name":"アウトレット", "rare":6800, "supa":2500, "uber":700, "legend":0,"sort":705},
    {"series_id":72,"name":"範馬刃牙", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":615},
    {"series_id":73,"name":"ソニック", "rare":7000, "supa":2500, "uber":500, "legend":0,"sort":616},

];

====================
FILE: index.html
====================
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=0.3, maximum-scale=3.0, user-scalable=yes">
    <title>R_Rolls</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
    <style>
        @media (max-width: 768px) {
            html, body { height: 100%; margin: 0; padding: 0 !important; overflow: hidden; }
            .container { height: 100%; display: flex; flex-direction: column; padding: 4px; box-sizing: border-box; }
            .header-row, .controls, .description-box, #result, .forecast-summary-container { flex-shrink: 0; }
            .header-row { flex-direction: row !important; flex-wrap: nowrap !important; overflow-x: auto; align-items: center; padding-bottom: 5px; border-bottom: 1px solid #eee; margin-bottom: 5px; white-space: nowrap; }
            h1 { font-size: 16px !important; margin-right: 5px; }
            .header-actions { display: flex; gap: 3px; flex-wrap: wrap; }
            .header-actions button, .header-actions span { font-size: 10px !important; padding: 2px 6px !important; height: 24px; line-height: 20px; }
            #rolls-table-container { flex-grow: 1; max-height: none !important; margin-bottom: 0 !important; overflow-y: auto; border-bottom: none; }
            #schedule-container { flex-grow: 1; overflow-y: auto; padding-bottom: 0; }
            .schedule-scroll-wrapper { max-height: none !important; }
        }
        .header-actions button { padding: 4px 8px; font-size: 12px; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header-row">
            <h1>R_Rolls</h1>
            <div class="header-actions">
                <span id="seed-input-trigger" class="text-btn" onclick="toggleSeedInput()">SEED</span>
                <span class="separator">|</span>
                <span id="toggle-find-info-btn" class="text-btn" onclick="toggleFindInfo()">Find</span>
                <span class="separator">|</span>
                <span id="mode-toggle-btn" class="text-btn" onclick="toggleAppMode()">Sim</span>
                <span class="separator">|</span>
                <span id="toggle-schedule-btn" class="text-btn" onclick="toggleSchedule()">skd</span>
                <span class="separator">|</span>
                <span id="toggle-description" class="text-btn" onclick="toggleDescription()">概要</span>
            </div>
        </div>
        <div id="description-content" class="description-box hidden" style="font-size: 0.8em;">
            <h3 style="margin-top:0;">【ツール概要】</h3>
            <p style="margin-bottom:10px;">レアガチャの排出結果を予測・シミュレーションするツールです。<br>各ガチャの排出キャラの確認や、確定枠等を利用したルート取りを支援します。</p>
            <h3 style="margin-top:0;">【基本操作】</h3>
            <ul style="padding-left: 20px; margin-bottom:10px;">
                <li><strong>SEED設定:</strong> SEEDを押し、実行前シードを入力してください。</li>
                <li><strong>ガチャ選択:</strong> 表のヘッダー下部のプルダウンから、表示したいガチャを選択できます。</li>
                <li><strong>列の追加・削除:</strong> 「＋列を追加」ボタンで比較用の列を増やせます。「skdで追加」を押すと、スケジュール一覧のガチャを一括で追加します。</li>
            </ul>
            <h3 style="margin-top:0;">【主要機能】</h3>
            <dl style="margin-bottom:10px;">
                <dt><strong>1. Find</strong></dt>
                <dd style="margin-bottom:5px;">2000ロール先までの「伝説枠」等を検索して表示します。リスト内のキャラ名をクリックすると、そのキャラを「Find」ターゲットとして登録/解除できます。</dd>
                <dt><strong>2. Sim (シミュレーションモード)</strong></dt>
                <dd style="margin-bottom:5px;">複数のガチャを跨いで引いた場合の結果をシミュレーションします。<br>「ルート」欄に形式に従って入力してください。また、Simモードでテーブル上のキャラ名をタップ（クリック）すると、そこまでのルートを自動計算します。自動計算では、超激確定・プラチナ・レジェンドは消費を避けるため使用しません。</dd>
                <dt><strong>3. skd (スケジュール)</strong></dt>
                <dd>「skd」ボタンで、直近のガチャ開催スケジュールを確認できます。</dd>
            </dl>
        </div>
        <div id="main-controls" class="controls" style="display: flex; flex-wrap: wrap; align-items: center; gap: 10px; padding: 5px; margin-bottom: 5px;">
            <div id="seed-input-container" class="control-group hidden" style="margin-bottom: 0; display: flex; align-items: center; gap: 5px;">
                <label for="seed" style="font-size:0.9em;">Seed:</label>
                <input type="number" id="seed" placeholder="Seed" value="12345" style="width:100px; font-size:0.9em;" onkeydown="if(event.key==='Enter') applySeedInput()">
                <button onclick="applySeedInput()" style="padding: 1px 6px; font-size: 11px;">OK</button>
                <button onclick="copySeedToClipboard()" class="secondary" style="padding: 1px 6px; font-size: 11px;">Copy</button>
                <button onclick="cancelSeedInput()" class="secondary" style="padding: 1px 6px; font-size: 11px;">×</button>
            </div>
            <div class="control-group hidden" id="sim-control-wrapper" style="margin-bottom: 0; display: flex; align-items: center; flex-wrap: wrap; width: 100%;">
                <div style="display: flex; align-items: center; width: 100%; gap: 5px;">
                    <label for="sim-config" style="font-size:0.9em;">ルート:</label>
                    <input type="text" id="sim-config" placeholder="e.g. 1006 4 942 11g" onchange="updateUrlParams(); resetAndGenerateTable();" style="flex-grow: 1;">
                    <button onclick="backSimConfig()" style="font-size: 11px; min-width: 40px;">Back</button>
                    <button onclick="clearSimConfig()" style="font-size: 11px;">Clear</button>
                    <button id="toggle-txt-btn" onclick="toggleTxtMode()" style="font-size: 11px;">Txt</button>
                    <button id="copy-txt-btn" onclick="copyTxtToClipboard()" class="hidden" style="margin-left: 2px; font-size: 11px;">Copy</button>
                    <span id="sim-notif-msg" style="color: #28a745; font-size: 0.8em; margin-left: 5px; font-weight: bold; display: none;"></span>
                    <div id="sim-error-msg" style="color: #d9534f; font-size: 0.85em; margin-left: 5px; display: none;"></div>
                </div>
            </div>
        </div>
        <div id="result" class="result-box hidden" style="font-size: 10px; margin-bottom: 2px;"></div>
        <div id="rolls-table-container"></div>
        <div id="schedule-container" class="hidden"></div>
    </div>
    <script src="cats.js"></script>
    <script src="gacha_series.js"></script>
    <script src="limited_cats.js"></script>
    <script src="logic.js"></script>
    <script src="sim_config_helpers.js"></script>
    <script src="sim_utils.js"></script>
    <script src="sim_engine.js"></script>
    <script src="sim_ui_logic.js"></script>
    <script src="schedule_logic.js"></script>
    <script src="view_schedule_utils.js"></script>
    <script src="view_schedule_gantt.js"></script>
    <script src="view_schedule_table.js"></script>
    <script src="data_loader.js"></script>
    <script src="url_manager.js"></script>
    <script src="gacha_selector.js"></script>
    <script src="view_schedule_editor.js"></script>
    <script src="ui_schedule_editor_handler.js"></script>
    <script src="view_forecast.js"></script>
    <script src="view_master.js"></script>
    <script src="view_analysis.js"></script>
    <script src="view_header.js"></script>
    <script src="view_cell_renderer.js"></script>
    <script src="view_table_data.js"></script>
    <script src="view_table_highlight.js"></script>
    <script src="view_table.js"></script>
    <script src="ui_globals.js"></script>
    <script src="ui_schedule_handler.js"></script>
    <script src="ui_target_handler.js"></script>
    <script src="ui_table_handler.js"></script>
    <script src="ui_mode_logic.js"></script>
    <script src="ui_seed_logic.js"></script>
    <script src="ui_refresh_logic.js"></script>
    <script src="ui_display_logic.js"></script>
    <script src="ui_cell_event.js"></script>
    <script src="main.js"></script>
</body>
</html>

====================
FILE: limited_cats.js
====================
/** @file limited_cats.js @description 限定キャラクター（祭限定など）のIDリスト管理 @dependency なし */

const limitedCats = [283,286,318,333,378,380,397,435,441,484,529,543,559,585,586,609,612,641,657,690,705,758,779,783,787,810,837];
const AnniversaryLimited = [435,484,758,783,810,837];

//837は、2026新年超極_新規の予測のため手動で入力したもののためアップデートされた際には削除すること

====================
FILE: logic.js
====================
/** @file logic.js @description ガチャ抽選の核心ロジック（Xorshift32、レア被り再抽選）を担当 @dependency なし */

/** 乱数生成クラス */
class Xorshift32 {
    constructor(seed) { this.seed = (seed >>> 0) || 1;
}
    next() {
        let x = this.seed;
        x ^= (x << 13);
        x ^= (x >>> 17);
        x ^= (x << 15);
        this.seed = x >>> 0;
        return this.seed;
    }
}

/**
 * 1回分のガチャ抽選を行う（シード消費あり）
 * 多重レア被りに対応 (被り続ける限りプールを減らして再抽選)
 */
function rollWithSeedConsumptionFixed(startIndex, gachaConfig, seeds, lastDrawInfo) {
    if (startIndex + 1 >= seeds.length) return { seedsConsumed: 0, finalChar: { name: "データ不足", id: null }, originalChar: null, isRerolled: false, rarity: null, charId: null, s0: null, s1: null, s2: null };
    const s0_seed = seeds[startIndex];
    const s1_seed = seeds[startIndex + 1];

    const rarityRoll = s0_seed % 10000;
    const rates = gachaConfig.rarity_rates || {};
    const rareRate = rates.rare || 0, superRate = rates.super || 0, uberRate = rates.uber || 0, legendRate = rates.legend || 0;
    
    let currentRarity;
    if (rarityRoll < rareRate) { currentRarity = 'rare'; } 
    else if (rarityRoll < rareRate + superRate) { currentRarity = 'super';
} 
    else if (rarityRoll < rareRate + superRate + uberRate) { currentRarity = 'uber';
} 
    else if (rarityRoll < rareRate + superRate + uberRate + legendRate) { currentRarity = 'legend';
} 
    else { currentRarity = 'rare';
}
    
    const characterPool = gachaConfig.pool[currentRarity] || [];
    if (characterPool.length === 0) {
        const s2_seed = (startIndex + 2 < seeds.length) ? seeds[startIndex + 2] : null;
        return { seedsConsumed: 2, finalChar: { name: "該当なし", id: null }, originalChar: null, isRerolled: false, rarity: currentRarity, charId: null, charIndex: -1, totalChars: 0, s0: s0_seed, s1: s1_seed, s2: s2_seed };
}
    
    const totalChars = characterPool.length;
    const charIndex = s1_seed % totalChars;
    let character = characterPool[charIndex];
    const originalChar = character;
    
    let seedsConsumed = 2;
    let isRerolled = false;
    let reRollIndex = null;
    let uniqueTotal = null;
    let finalSeedVal = null; // 最後に使用したSEED（表示用）

    // --- 連続レア被り判定（強制フラグ） ---
    // 条件:
    // 1. 今回(S_n+5:Row3/3B)がレア、前回(S_n+2:Row2/2A)、前々回(S_n:Row1/1A)もレアである
    // 2. インデックス的に連続している: StartIndex(S6)に対し、-1(S5), -2(S4), -4(S2), -5(S1) を参照
    // 3. ユーザー定義の計算式を満たす
    let forceDuplicate = false;
    
    // 判定開始位置を5 (3B相当) に変更
    if (currentRarity === 'rare' && startIndex >= 5) {
        // プールサイズ取得 (通常25)
        const P = totalChars; 
        
        if (P > 1) {
            // インデックス定義 (Current = startIndex = 5 (S6) と仮定)
            
            // Check Rarity of 1A (Index -5) and 2A (Index -3)
            const s_n0 = seeds[startIndex - 5]; // S1
            const s_n2 = seeds[startIndex - 3]; // S3
            
            const isRare1A = (s_n0 % 10000) < rareRate;
            const isRare2A = (s_n2 % 10000) < rareRate;

            if (isRare1A && isRare2A) {
                // Check 1: S_n+1 % P == S_n+3 % P  (1A Slot == 2A Slot)
                const s_n1 = seeds[startIndex - 4];
                const s_n3 = seeds[startIndex - 2];
                
                if (s_n1 !== undefined && s_n3 !== undefined) {
                    const isPrevDupe = (s_n1 % P) === (s_n3 % P);
                    
                    if (isPrevDupe) {
                        // Check 2: S_n+4 % (P-1) == S_n+6 % P (2A Reroll == 3B Slot)
                        const s_n4 = seeds[startIndex - 1];
                        const s_n6 = seeds[startIndex + 1];
                        
                        if (s_n4 !== undefined && s_n6 !== undefined) {
                            const row2RerollVal = s_n4 % (P - 1);
                            const row3TargetVal = s_n6 % P;
                            
                            if (row2RerollVal === row3TargetVal) {
                                forceDuplicate = true;
                            }
                        }
                    }
                }
            }
        }
    }

    // --- レア被り判定と多重再抽選ロジック ---
    if ( (currentRarity === 'rare' && lastDrawInfo && lastDrawInfo.rarity === 'rare' && lastDrawInfo.charId === character.id) || forceDuplicate ) {
        
        // 元のプールをコピーして操作用プールを作成
        let currentPool = [...characterPool];
        // 直前に選ばれたインデックス（除外対象）
        let removeIndex = charIndex;
        // 被りが解消されるまでループ
        while (true) {
            // 1. 直前の抽選で選ばれたキャラ（index）をプールから除外
            currentPool.splice(removeIndex, 1);
            uniqueTotal = currentPool.length;

            if (uniqueTotal === 0) {
                // 万が一プールが空になった場合はループ終了
                break;
}

            // 2. 次のSEEDが存在するか確認
            if (startIndex + seedsConsumed >= seeds.length) {
                return { seedsConsumed: 0, finalChar: { name: "データ不足", id: null }, originalChar: null, isRerolled: false, rarity: null, charId: null, s0: s0_seed, s1: s1_seed, s2: null };
}

            // 3. 次のSEEDを取得
            finalSeedVal = seeds[startIndex + seedsConsumed];
            seedsConsumed++; // SEED消費数を加算

            // 4. 新しいプールで抽選
            reRollIndex = finalSeedVal % uniqueTotal;
            character = currentPool[reRollIndex];
            
            isRerolled = true;

            // 5. 再抽選結果が、なお前回の確定キャラ(lastDrawInfo)と同じIDか確認
            if (!forceDuplicate && character.id !== lastDrawInfo.charId) {
                // 通常被りが解消されたので終了
                break;
}
            if (forceDuplicate) {
                // 強制被りの場合、1回再抽選したらとりあえずループを抜ける
                break;
            }

            // まだ被っている場合
            // 今回選ばれた reRollIndex を次の除外対象としてループ継続
            removeIndex = reRollIndex;
            // 安全策: もしプール内の全キャラが同じIDなら無限ループになるためチェック
            const hasDifferentChar = currentPool.some(c => c.id !== character.id);
            if (!hasDifferentChar) {
                break;
// 回避不可能
            }
        }
    } else {
        // 再抽選なしの場合、S2のSEED値として仮に次の値をセット（従来の互換性のため）
        if (startIndex + 2 < seeds.length) finalSeedVal = seeds[startIndex + 2];
}
    
    return { 
        s0: s0_seed, 
        s1: s1_seed, 
        s2: finalSeedVal, // 最終的に抽選に使用されたSEED
        originalChar: originalChar, 
        finalChar: character, 
        isRerolled: isRerolled, 
        isForceDuplicate: forceDuplicate, // 追加: 連続レア被りフラグ
        rarity: currentRarity, 
        charId: character.id, 
        charIndex: charIndex, 
        totalChars: totalChars, 
        uniqueTotal: uniqueTotal, // 最終ループ時のプールサイズ
        reRollIndex: reRollIndex, // 最終ループ時のスロット値
        seedsConsumed: seedsConsumed 
    };
}

/**
 * 確定枠（Uber）の抽選
 */
function rollGuaranteedUber(startIndex, gachaConfig, seeds) {
    if (startIndex >= seeds.length) return { seedsConsumed: 0, finalChar: { name: "データ不足", id: null }, originalChar: null, isRerolled: false, rarity: 'uber', charId: null, s0: null };
    const s0_seed = seeds[startIndex];
    const currentRarity = 'uber';
    const characterPool = gachaConfig.pool[currentRarity] || [];
    const totalChars = characterPool.length;
    if (totalChars === 0) {
        return { seedsConsumed: 1, finalChar: { name: "該当なし", id: null }, originalChar: null, isRerolled: false, rarity: currentRarity, charId: null, charIndex: -1, totalChars: 0, s0: s0_seed };
}
    const charIndex = s0_seed % totalChars;
    const character = characterPool[charIndex];
    return { seedsConsumed: 1, finalChar: character, originalChar: character, isRerolled: false, rarity: currentRarity, charId: character.id, charIndex: charIndex, totalChars: totalChars, s0: s0_seed };
}

/**
 * 確定枠の先読み計算
 */
function calculateGuaranteedLookahead(startSeedIndex, gachaConfig, allSeeds, initialLastDraw, normalRollsCount = 10) {
    if (!gachaConfig || !gachaConfig.pool['uber']) return { name: "N/A", charId: null, nextSeed: null, nextRollStartSeedIndex: null };
    // シミュレーション実行用ヘルパー関数
    const simulateRoute = (startSeed, startLastDraw) => {
        let seedCursor = startSeed;
        let lastDraw = startLastDraw;
        
        for (let i = 0; i < normalRollsCount; i++) {
            if (seedCursor + 1 >= allSeeds.length) return null;
            const rollResult = rollWithSeedConsumptionFixed(seedCursor, gachaConfig, allSeeds, lastDraw);
            if (rollResult.seedsConsumed === 0) return null;
            
            seedCursor += rollResult.seedsConsumed;
            lastDraw = { rarity: rollResult.rarity, charId: rollResult.charId, isRerolled: rollResult.isRerolled };
        }

        if (seedCursor >= allSeeds.length) return null;
        const guarRoll = rollGuaranteedUber(seedCursor, gachaConfig, allSeeds);
        if (guarRoll.seedsConsumed === 0) return null;
        
        seedCursor += guarRoll.seedsConsumed;
        const nextSimSeedValue = (seedCursor < allSeeds.length) ? allSeeds[seedCursor] : null;
        return {
            name: guarRoll.finalChar.name,
            charId: guarRoll.finalChar.id,
            nextSeed: nextSimSeedValue,
            nextRollStartSeedIndex: seedCursor // 排出後のインデックス
        };
    };

    // 1. 最初の1回目がレア被りになるかチェック
    let isFirstDupe = false;
    if (normalRollsCount > 0 && startSeedIndex + 1 < allSeeds.length) {
        const checkRoll = rollWithSeedConsumptionFixed(startSeedIndex, gachaConfig, allSeeds, initialLastDraw);
        if (checkRoll.isRerolled) {
            isFirstDupe = true;
}
    }

    // 2. メインルート（実際の挙動）
    const mainResult = simulateRoute(startSeedIndex, initialLastDraw);
    if (!mainResult) return { name: "データ不足", charId: null, nextSeed: null, nextRollStartSeedIndex: null };
    // 3. Alternativeルート（1回目が被りなしと仮定）
    let altResult = null;
    if (isFirstDupe) {
        // initialLastDrawをnullにすることで、1回目の被り判定を回避させる
        altResult = simulateRoute(startSeedIndex, null);
}

    // 結果をマージして返す
    return {
        ...mainResult, // 既存コードとの互換性のため展開
        alternative: altResult
    };
}

====================
FILE: main.js
====================
/** @file main.js @description アプリのエントリーポイント（window.onloadでの初期化フロー実行） @dependency data_loader.js, ui_controller.js */

/**
 * ==============================================================================
 * [R_Rolls] システム相関図 (System Dependency Map) - Updated 2025
 * ==============================================================================
 * 【1. Entry Point / Controller】
 * main.js --------------------> アプリ初期化フローの実行
 * |
 * +--[ UI Management Modules ]--+
 * | ui_mode_logic.js ----------> 初期化・Sim/skd/概要の切替
 * | ui_seed_logic.js ----------> SEED値操作・同期
 * | ui_refresh_logic.js --------> 再描画・Config操作
 * | ui_display_logic.js --------> SEED列/マスター情報の表示管理
 * |
 * | ui_cell_event.js -----------> セルクリック時のルート計算指令
 * +-----------------------------+
 * +--> url_manager.js ------> URLとアプリ状態の同期
 *
 * 【2. Data & Logic Layer】
 * data_loader.js -------------> CSV/TSV取得・マスタデータ構築
 * |
 * (cats.js, gacha_series.js を参照)
 * logic.js -------------------> ガチャ抽選・再抽選の核心計算ロジック
 * schedule_logic.js ----------> gatya.tsv解析・日付計算
 * |
 * +--[ Simulation Modules ]--+
 * |
 * | sim_config_helpers.js ----> Config文字列の解析・生成・操作
 * | sim_engine.js ------------> 経路探索(ビームサーチ)・シミュレーション実行
 * | sim_ui_logic.js ----------> 回避・誘発判定・UI表示判定ロジック
 * |
 * | sim_utils.js -------------> 探索された経路の圧縮・整形
 * +--------------------------+
 *
 * 【3. View / Rendering Layer】
 * view_table.js --------------> テーブル描画のメイン制御・DOM構築
 * |
 * +--> view_table_data.js ----> テーブル用データの生成
 * +--> view_table_highlight.js -> ルートハイライトの計算
 * +--> view_header.js ------> ヘッダー(固定名/操作ボタン)生成
 * +--> view_cell_renderer.js -> 各セルのHTML生成
 * |
 * +--> view_analysis.js -> レア被りハイライト判定
 * |
 * +--> view_forecast.js ----> Findエリア・予報HTML生成
 * +--> view_master.js ------> マスタ詳細情報HTML生成
 * +--> view_schedule_utils.js -> スケジュール共通設定・ユーティリティ
 * +--> view_schedule_gantt.js -> ガントチャート描画
 * +--> view_schedule_table.js -> スケジュール表描画
 *
 * 【4. Event Handlers / UI Parts】
 * ui_table_handler.js --------> 列追加/削除/変更のイベント
 * ui_target_handler.js -------> Findターゲットの管理
 * ui_schedule_handler.js -----> skdモード切替・スケジュール列追加
 * gacha_selector.js ----------> プルダウンの選択肢生成
 *
 * 【5. Core State】
 * ui_globals.js --------------> 全ファイルで共有されるグローバル変数
 * ==============================================================================
 */

window.onload = async function() {
    // 1. データの読み込み (data_loader.js)
    const success = await loadAllData();
    if (!success) {
        alert("データの読み込みに失敗しました。");
        return;
    }

    // 2. URLパラメータの処理 (url_manager.js)
    processUrlParams();

    // 3. デフォルトガチャの初期化 (ui_mode_logic.js)
    initializeDefaultGachas();

    // 4. スケジュールUIの準備 (ui_schedule_handler.js)
    setupScheduleUI();

    // 5. 初回描画 (ui_mode_logic.js)
    onModeChange();
};

====================
FILE: schedule_logic.js
====================
/** @file schedule_logic.js @description gatya.tsvの解析、日付・時刻計算のユーティリティを担当 @dependency なし */

// YYYYMMDD -> M/D (年は無視、20300101は「永続」)
function formatDateJP(dateStr) {
    if (!dateStr || dateStr.length < 8) return dateStr;
    // 特殊対応: 2030/1/1 (20300101) は「永続」と表示
    if (dateStr === '20300101') {
        return '永続';
    }

    // 年は切り捨てて 月/日 形式に変換 (parseIntで0埋めを除去: 05月 -> 5)
    const m = parseInt(dateStr.substring(4, 6), 10);
    const d = parseInt(dateStr.substring(6, 8), 10);
    return `${m}/${d}`;
}

// HHMM -> HH:MM
function formatTime(timeStr) {
    if (!timeStr) return "00:00";
    let s = timeStr.toString().padStart(4, '0');
    return `${s.substring(0, 2)}:${s.substring(2, 4)}`;
}

// YYYYMMDD -> Dateオブジェクト (00:00:00)
function parseDateStr(dateStr) {
    if (!dateStr || dateStr.length < 8) return new Date();
    const y = parseInt(dateStr.substring(0, 4), 10);
    const m = parseInt(dateStr.substring(4, 6), 10) - 1;
    const d = parseInt(dateStr.substring(6, 8), 10);
    return new Date(y, m, d);
}

// YYYYMMDD, HHMM -> Dateオブジェクト
function parseDateTime(dateStr, timeStr) {
    const d = parseDateStr(dateStr);
    if (timeStr) {
        let s = timeStr.toString().padStart(4, '0');
        const h = parseInt(s.substring(0, 2), 10);
        const min = parseInt(s.substring(2, 4), 10);
        d.setHours(h, min, 0, 0);
    }
    return d;
}

// Date -> YYYYMMDD 数値
function getDateInt(dateObj) {
    const y = dateObj.getFullYear();
    const m = String(dateObj.getMonth() + 1).padStart(2, '0');
    const d = String(dateObj.getDate()).padStart(2, '0');
    return parseInt(`${y}${m}${d}`, 10);
}

// Date -> M/D 文字列
function getShortDateStr(dateObj) {
    return `${dateObj.getMonth() + 1}/${dateObj.getDate()}`;
}

// プラチナ・レジェンド判定
function isPlatinumOrLegend(item) {
    const name = (item.seriesName + (item.tsvName || "")).replace(/\s/g, "");
    return name.includes("プラチナガチャ") || name.includes("レジェンドガチャ");
}

// TSVデータのパース処理
function parseGachaTSV(tsv) {
    const lines = tsv.split('\n');
    const schedule = [];
    lines.forEach(line => {
        if (line.trim().startsWith('[') || !line.trim()) return;

        const cols = line.split('\t');
        if (cols.length < 10) return;

        // 1. フィルタリング: 9列目(index 8)が '1' のもののみ抽出
        if (cols[8] !== '1') return;

        // 2. 年月日・時刻情報の取得
        const startDateStr = cols[0]; 
        const startTimeStr = cols[1]; 
   
        const endDateStr   = cols[2]; 
        const endTimeStr   = cols[3]; 

        // 3. 有効なガチャ情報ブロックの探索
        let validBlockIndex = -1;
        for (let i = 10; i < cols.length; i += 15) {
            const descIndex = i + 14;
            if (descIndex >= cols.length) break;
  
            const desc = cols[descIndex];
            if (desc && desc !== '0' && /[^\x01-\x7E]/.test(desc)) {
                validBlockIndex = i;
                break; 
            }
        }

        if (validBlockIndex === -1) 
        {
            if (cols[10] && cols[10] !== '-1') {
                validBlockIndex = 10;
            } else {
                return;
            }
        }

        const base = validBlockIndex;
        // ガチャ情報抽出
        const gachaId = cols[base];
        const rateRare = cols[base + 6];
        const rateSupa = cols[base + 8]; 
        const rateUber = cols[base + 10]; 
        const guarFlag = cols[base + 11];
        const rateLegend = cols[base + 12]; 
        const detail = cols[base + 14];
        const guaranteed = (guarFlag === '1' || parseInt(guarFlag) > 0);

        let seriesName = "";
        let tsvName = detail || "";
        if (typeof gachaMasterData !== 'undefined' && gachaMasterData.gachas[gachaId]) {
            seriesName = gachaMasterData.gachas[gachaId].name;
        } else {
            seriesName = `ID:${gachaId}`;
        }

        schedule.push({
            id: gachaId,
            start: startDateStr,
            end: endDateStr,
            rawStart: startDateStr,
            rawEnd: endDateStr,
            startTime: startTimeStr,
            endTime: endTimeStr,
 
            seriesName: seriesName,
            tsvName: tsvName,
            rare: rateRare,
            supa: rateSupa,
            uber: rateUber,
            legend: rateLegend,
            guaranteed: guaranteed
        });
    });

    // 開始日順にソート
    schedule.sort((a, b) => parseInt(a.start) - parseInt(b.start));
    return schedule;
}

/**
 * ロールズ（シミュレータ）の初期値を決定する関数
 * - 終了していないガチャの中で開始日が最も早いものを選択
 * - 確定ガチャの場合は '11g'、それ以外は '11' を推奨設定として返す
 */
function findDefaultGachaState(data) {
    const now = new Date();
    // 1. フィルタリング (終了していない & プラチナ・レジェンド除外)
    let candidates = data.filter(item => {
        if (isPlatinumOrLegend(item)) return false; // 通常ロールズ対象外を除外
        
        const endDt = parseDateTime(item.rawEnd, item.endTime);
        return endDt >= now; // 現在時刻を過ぎていない
    });
    // 2. 開始日順にソート
    candidates.sort((a, b) => {
        const startA = parseDateTime(a.rawStart, a.startTime);
        const startB = parseDateTime(b.rawStart, b.startTime);
        return startA - startB;
    });
    if (candidates.length === 0) return null;

    // 3. 最も開催が近い(または開催中の)ものを選択
    const target = candidates[0];
    // 確定フラグがあれば初期表示を '11g' (11連確定) にする
    const recommendedRollType = target.guaranteed ? '11g' : '11';
    return {
        gacha: target,
        gachaId: target.id,
        rollType: recommendedRollType
    };
}

====================
FILE: sim_config_helpers.js
====================
/** @file sim_config_helpers.js @description Config文字列の解析・生成ヘルパー */

/** Config文字列をオブジェクト配列に変換 [cite: 230-233] */
function parseSimConfig(configStr) {
    if (!configStr) return [];
    const parts = configStr.split(/[\s\-]+/).filter(Boolean);
    const configs = [];
    for (let i = 0; i < parts.length; i += 2) {
        const id = parts[i];
        const rollStr = parts[i+1];
        if (id && rollStr) {
            const isGuaranteed = rollStr.endsWith('g');
            const rolls = parseInt(rollStr.replace('g', ''), 10);
            configs.push({ id, rolls, g: isGuaranteed });
        }
    }
    return configs;
}

/** オブジェクト配列をConfig文字列に変換 [cite: 235] */
function stringifySimConfig(configArr) {
    return configArr.map(c => `${c.id} ${c.rolls}${c.g ? 'g' : ''}`).join(' ');
}

/** 最後のロール回数を1増やす [cite: 236-239] */
function incrementLastRoll(configStr) {
    if (!configStr) return null;
    const configs = parseSimConfig(configStr);
    if (configs.length > 0) {
        const last = configs[configs.length - 1];
        if (!last.g) { 
            last.rolls += 1;
        } else {
            configs.push({ id: last.id, rolls: 1, g: false });
        }
    }
    return stringifySimConfig(configs);
}

/** 最後のロールを1減らす、またはセグメントを削除 [cite: 240-243] */
function decrementLastRollOrRemoveSegment(configStr) {
    if (!configStr) return null;
    const configs = parseSimConfig(configStr);
    if (configs.length > 0) {
        const last = configs[configs.length - 1];
        if (last.rolls > 1 && !last.g) {
            last.rolls -= 1;
        } else {
            configs.pop();
        }
    }
    return stringifySimConfig(configs);
}

/** 最後のConfigセグメントを削除 [cite: 244-245] */
function removeLastConfigSegment(configStr) {
    if (!configStr) return "";
    const configs = parseSimConfig(configStr);
    if (configs.length > 0) {
        configs.pop();
    }
    return stringifySimConfig(configs);
}

/** 確定枠設定の生成 [cite: 246-250] */
function generateGuaranteedConfig(configStr, gachaId) {
    if (!configStr) return null;
    const parsed = parseSimConfig(configStr);
    if (parsed.length === 0) return null;
    
    const lastPart = parsed.pop();
    if (!lastPart.g && lastPart.rolls > 0) { 
        const newRollsForLastPart = Math.max(0, lastPart.rolls - 1);
        if (newRollsForLastPart > 0) {
            lastPart.rolls = newRollsForLastPart;
            parsed.push(lastPart);
        }
        parsed.push({ id: gachaId, rolls: 11, g: true });
        return stringifySimConfig(parsed);
    }
    return null;
}

====================
FILE: sim_engine.js
====================
/** @file sim_engine.js @description 経路探索・シミュレーションエンジン */

/** 単一セグメントのシミュレーション [cite: 291-301] */
function simulateSingleSegment(sim, currentIdx, currentLastDraw, seeds) {
    const conf = gachaMasterData.gachas[sim.id];
    if (!conf) return { nextIndex: currentIdx, lastDraw: currentLastDraw };

    let normalRolls = sim.rolls;
    let isGuaranteedStep = false;
    let tempIdx = currentIdx;
    let tempLastDraw = currentLastDraw;

    if (sim.g) {
         if (sim.rolls === 15) { normalRolls = 14; isGuaranteedStep = true; }
         else if (sim.rolls === 7) { normalRolls = 6; isGuaranteedStep = true; }
         else if (sim.rolls === 11) { normalRolls = 10; isGuaranteedStep = true; }
         else { normalRolls = sim.rolls; }
    }

    for(let k=0; k < normalRolls; k++) {
        if (tempIdx >= seeds.length - 5) break;
        const rr = rollWithSeedConsumptionFixed(tempIdx, conf, seeds, tempLastDraw);
        if (rr.seedsConsumed === 0) break;
        tempLastDraw = { rarity: rr.rarity, charId: rr.charId, isRerolled: rr.isRerolled };
        tempIdx += rr.seedsConsumed;
    }
    
    if (isGuaranteedStep && tempIdx < seeds.length) {
        if (typeof rollGuaranteedUber !== 'undefined') {
            const gr = rollGuaranteedUber(tempIdx, conf, seeds);
            tempIdx += gr.seedsConsumed;
        }
    }
    return { nextIndex: tempIdx, lastDraw: tempLastDraw };
}

/** 経路探索エントリポイント [cite: 302-320] */
function calculateRouteToCell(targetSeedIndex, targetGachaId, visibleGachaIds, currentConfigStr, finalActionOverride = null, primaryTargetId = null) {
    const getSeeds = () => {
        const seedEl = document.getElementById('seed');
        const initialSeed = parseInt(seedEl ? seedEl.value : 12345);
        const rng = new Xorshift32(initialSeed);
        const tempSeeds = [];
        const limit = Math.max(targetSeedIndex, 1000) + 500;
        for(let i=0; i < limit; i++) tempSeeds.push(rng.next());
        return tempSeeds;
    };
    const simSeeds = getSeeds();
    let startIdx = 0;
    let initialLastDraw = null;
    let validConfigParts = [];
    if (currentConfigStr && currentConfigStr.trim() !== "") {
        const existingConfigs = parseSimConfig(currentConfigStr);
        let tempIdx = 0;
        let tempLastDraw = null;
        for (const segment of existingConfigs) {
            const res = simulateSingleSegment(segment, tempIdx, tempLastDraw, simSeeds);
            if (res.nextIndex > targetSeedIndex) break;
            validConfigParts.push(segment);
            tempIdx = res.nextIndex;
            tempLastDraw = res.lastDraw;
            if (tempIdx === targetSeedIndex) break;
        }
        startIdx = tempIdx;
        initialLastDraw = tempLastDraw;
    }
    
    const baseConfigStr = stringifySimConfig(validConfigParts);
    const usableConfigs = visibleGachaIds.map(idStr => {
        const id = idStr.replace(/[gfs]$/, '');
        const conf = gachaMasterData.gachas[id];
        if (!conf) return null;
        if (conf.name.includes('プラチナ') || conf.name.includes('レジェンド')) return null;
        return conf;
    }).filter(c => c !== null);

    if (usableConfigs.length === 0) return null;

    const route = findPathBeamSearch(startIdx, targetSeedIndex, targetGachaId, usableConfigs, simSeeds, initialLastDraw, primaryTargetId);
    if (route) {
        if (finalActionOverride) route.push(finalActionOverride);
        else route.push({ id: targetGachaId, rolls: 1 });
        const newRouteStr = compressRoute(route);
        return baseConfigStr ? baseConfigStr + " " + newRouteStr : newRouteStr;
    }
    return null;
}

/** ビームサーチによる経路探索  */
function findPathBeamSearch(startIdx, targetIdx, targetGachaId, configs, simSeeds, initialLastDraw, primaryTargetId = null) {
    const BEAM_WIDTH = 20;
    const MAX_STEPS = 2200;

    const sortedConfigs = [...configs].sort((a, b) => {
        if (a.id == targetGachaId) return -1;
        if (b.id == targetGachaId) return 1;
        return 0;
    });
    let candidates = [{ idx: startIdx, path: [], lastDraw: initialLastDraw, score: 0 }];
    let loopCount = 0;

    while (candidates.length > 0 && loopCount < MAX_STEPS) {
        loopCount++;
        let nextCandidates = [];
        for (const current of candidates) {
            if (current.idx === targetIdx) return current.path;
            const dist = targetIdx - current.idx;
            if (dist < 0) continue;

            for (const conf of sortedConfigs) {
                const res = rollWithSeedConsumptionFixed(current.idx, conf, simSeeds, current.lastDraw);
                if (current.idx + res.seedsConsumed > targetIdx) continue;

                let score = current.score;
                const distIsOdd = (dist % 2 !== 0);
                const moveIsOdd = (res.seedsConsumed % 2 !== 0);
                if (distIsOdd === moveIsOdd) score += 500;
                else score -= 50;

                const cid = res.charId;
                const cStr = String(cid);
                if (primaryTargetId !== null && (cid == primaryTargetId || cStr == primaryTargetId)) score += 1000;

                let rarityScore = 0;
                const isLimited = (typeof limitedCats !== 'undefined' && (limitedCats.includes(cid) || limitedCats.includes(cStr)));
                const isUserTarget = (typeof userTargetIds !== 'undefined' && (userTargetIds.has(cid) || userTargetIds.has(parseInt(cid))));
                if (res.rarity === 'legend') rarityScore = isUserTarget ? 300 : 250;
                else if (isLimited) rarityScore = isUserTarget ? 200 : 150;
                else if (res.rarity === 'uber') rarityScore = isUserTarget ? 100 : 80;
                else if (isUserTarget) rarityScore = 50;

                score += rarityScore;
                const prevId = current.path.length > 0 ? current.path[current.path.length - 1].id : null;
                if (conf.id == prevId) score += 40;
                score += res.seedsConsumed;

                const newPath = [...current.path, { id: conf.id, rolls: 1 }];
                const newLastDraw = { rarity: res.rarity, charId: res.charId, isRerolled: res.isRerolled };
                if (current.idx + res.seedsConsumed === targetIdx) return newPath;

                nextCandidates.push({ idx: current.idx + res.seedsConsumed, path: newPath, lastDraw: newLastDraw, score: score });
            }
        }
        if (nextCandidates.length === 0) break;
        nextCandidates.sort((a, b) => b.score - a.score);

        const uniqueCandidates = [];
        const seenState = new Set();
        for (const cand of nextCandidates) {
            const stateKey = `${cand.idx}-${cand.lastDraw.charId}`;
            if (!seenState.has(stateKey)) {
                seenState.add(stateKey);
                uniqueCandidates.push(cand);
            }
        }
        const bestA = uniqueCandidates.filter(c => c.idx % 2 === 0).slice(0, BEAM_WIDTH / 2);
        const bestB = uniqueCandidates.filter(c => c.idx % 2 !== 0).slice(0, BEAM_WIDTH / 2);
        let combined = [...bestA, ...bestB];
        if (combined.length < BEAM_WIDTH) {
            const combinedSet = new Set(combined);
            const remaining = uniqueCandidates.filter(c => !combinedSet.has(c));
            combined = combined.concat(remaining.slice(0, BEAM_WIDTH - combined.length));
        }
        candidates = combined.sort((a, b) => b.score - a.score);
    }
    return null;
}

====================
FILE: sim_ui_logic.js
====================
/** @file sim_ui_logic.js @description UI表示用の回避・誘発判定ロジック */

/** セルに対応するConfigを取得 [cite: 251-254] */
function getBestLink(cellSimConfigs, seedIndex, gachaConfigs) {
    if (seedIndex < 0) return null;
    for (const config of gachaConfigs) {
        const configStr = cellSimConfigs.get(`${seedIndex}-${config.id}`);
        if (configStr !== undefined) {
            return configStr;
        }
    }
    return null;
}

/** 再抽選後のキャラ名を取得 [cite: 255-257] */
function getForcedRerollName(currentRoll, gachaConfig) {
    if (!currentRoll || !gachaConfig || currentRoll.rarity !== 'rare' || currentRoll.s2 === null) {
        return null;
    }
    const characterPool = gachaConfig.pool['rare'] || [];
    const uniqueRareChars = characterPool.filter(c => c.id !== currentRoll.originalChar.id);
    const uniqueTotal = uniqueRareChars.length;
    
    if (uniqueTotal > 0) {
        const reRollIndex = currentRoll.s2 % uniqueTotal;
        return uniqueRareChars[reRollIndex].name;
    }
    return null;
}

/** 回避・誘発判定 [cite: 258-276] */
function checkAvoidanceAndForcing(seedIndex, currentGachaId, tableData, gachaConfigs, cellSimConfigs, newRow1Index) {
    const i = Math.floor(seedIndex / 2);
    if (i < newRow1Index) return { link: null, rerollCharName: null };

    const gachaIndex = gachaConfigs.findIndex(c => c.id === currentGachaId);
    if (gachaIndex === -1 || !tableData[seedIndex] || !tableData[seedIndex][gachaIndex]) {
        return { link: null, rerollCharName: null };
    }

    const currentRoll = tableData[seedIndex][gachaIndex].roll;
    const isRerolled = currentRoll.isRerolled;
    const originalCharId = currentRoll.originalChar?.id;
    const originalRarity = currentRoll.rarity;
    if (originalRarity !== 'rare' || !originalCharId) return { link: null, rerollCharName: null };

    const prevIndicesToCheck = [seedIndex - 2, seedIndex - 3];
    for (const otherConfig of gachaConfigs) {
        const otherGachaId = otherConfig.id;
        if (otherGachaId === currentGachaId) continue;

        const otherIndex = gachaConfigs.findIndex(c => c.id === otherGachaId);
        if (otherIndex === -1) continue;
        
        const createAltConfig = (prevIndexUsed) => {
            const configStr = getBestLink(cellSimConfigs, prevIndexUsed, gachaConfigs);
            if (configStr === null) return null; 
            const parts = parseSimConfig(configStr);
            const last_part = parts.length > 0 ? parts[parts.length - 1] : null;
            if (last_part && last_part.id === otherGachaId && !last_part.g) {
                last_part.rolls += 1;
            } else {
                parts.push({ id: otherGachaId, rolls: 1, g: false });
            }
            return stringifySimConfig(parts);
        };

        for (const prevIndex of prevIndicesToCheck) {
            if (prevIndex < 0) continue;
            const otherRoll_prev = tableData[prevIndex]?.[otherIndex]?.roll;
            if (!otherRoll_prev) continue;

            if (isRerolled) {
                if (otherRoll_prev.rarity !== 'rare' || otherRoll_prev.charId !== originalCharId) { 
                    const altConfig = createAltConfig(prevIndex);
                    if (altConfig) return { link: altConfig, rerollCharName: null };
                }
            } else {
                if (otherRoll_prev.rarity === 'rare' && otherRoll_prev.charId === originalCharId) {
                    const altConfig = createAltConfig(prevIndex);
                    if (altConfig) {
                        const rerollCharName = getForcedRerollName(currentRoll, gachaConfigs[gachaIndex]);
                        return { link: altConfig, rerollCharName: rerollCharName };
                    }
                }
            }
        }
    }
    return { link: null, rerollCharName: null };
}

/** 誘発可能判定 [cite: 277-283] */
function canBeForced(seedIndex, currentGachaId, tableData, gachaConfigs) {
    const gachaIndex = gachaConfigs.findIndex(c => c.id === currentGachaId);
    if (gachaIndex === -1 || seedIndex < 1 || !tableData[seedIndex] || !tableData[seedIndex][gachaIndex]) return false;
    const currentRoll = tableData[seedIndex][gachaIndex].roll;
    const originalCharId = currentRoll.originalChar ? currentRoll.originalChar.id : null;
    if (!originalCharId) return false;
    const prevIndicesToCheck = [seedIndex - 2, seedIndex - 3];
    for (const prevIndex of prevIndicesToCheck) {
        if (prevIndex < 0) continue;
        for (const otherConfig of gachaConfigs) {
            const otherIndex = gachaConfigs.findIndex(c => c.id === otherConfig.id);
            if (otherIndex === -1) continue;
            const otherRoll_prev = tableData[prevIndex]?.[otherIndex]?.roll;
            if (otherRoll_prev && otherRoll_prev.rarity === 'rare' && otherRoll_prev.charId === originalCharId) {
                return true;
            }
        }
    }
    return false;
}

/** 回避可能判定 [cite: 284-290] */
function canBeAvoided(seedIndex, currentGachaId, tableData, gachaConfigs) {
    const gachaIndex = gachaConfigs.findIndex(c => c.id === currentGachaId);
    if (gachaIndex === -1 || seedIndex < 1 || !tableData[seedIndex] || !tableData[seedIndex][gachaIndex]) return false;
    const currentRoll = tableData[seedIndex][gachaIndex].roll;
    if (currentRoll.rarity !== 'rare' || !currentRoll.isRerolled || !currentRoll.originalChar) return false;
    const originalCharId = currentRoll.originalChar.id;
    const prevIndicesToCheck = [seedIndex - 2, seedIndex - 3];
    for (const prevIndex of prevIndicesToCheck) {
        if (prevIndex < 0) continue;
        for (const otherConfig of gachaConfigs) {
            const otherIndex = gachaConfigs.findIndex(c => c.id === otherConfig.id);
            if (otherIndex === -1) continue;
            const otherRoll_prev = tableData[prevIndex]?.[otherIndex]?.roll;
            if (otherRoll_prev && (otherRoll_prev.rarity !== 'rare' || otherRoll_prev.charId !== originalCharId)) {
                return true;
            }
        }
    }
    return false;
}

====================
FILE: sim_utils.js
====================
/** @file sim_utils.js @description シミュレーション結果の圧縮 */

/** 経路をConfig形式に圧縮 [cite: 356-361] */
function compressRoute(path) {
    if (!path || path.length === 0) return "";
    let compressed = [];
    let currentId = path[0].id;
    let isG = path[0].g || false;
    let count = path[0].rolls || 1;
    for (let i = 1; i < path.length; i++) {
        const step = path[i];
        const stepG = step.g || false;
        if (step.id === currentId && stepG === isG && !isG) {
            count += (step.rolls || 1);
        } else {
            compressed.push(`${currentId} ${count}${isG ? 'g' : ''}`);
            currentId = step.id;
            isG = stepG;
            count = step.rolls || 1;
        }
    }
    compressed.push(`${currentId} ${count}${isG ? 'g' : ''}`);
    return compressed.join(" ");
}

====================
FILE: style.css
====================
@charset "UTF-8";

/* =========================================
   基本設定
   ========================================= */
html, body { height: 100%; margin: 0; overflow: hidden; }
body { font-family: "Helvetica Neue", Arial, sans-serif; padding: 20px; box-sizing: border-box; color: #333; background-color: #fff; display: flex; flex-direction: column; }

.container { height: 100%; display: flex; flex-direction: column; overflow: hidden; }

.header-row, 
.controls, 
.description-box, 
#result, 
.forecast-summary-container { flex-shrink: 0; }

.header-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; flex-wrap: nowrap; gap: 10px; }
h1 { font-size: 20px; margin: 0; padding: 0; white-space: nowrap; }
.header-actions { display: flex; align-items: center; gap: 4px; flex-wrap: nowrap; }

.text-btn { cursor: pointer; color: #007bff; font-weight: bold; font-size: 0.9em; text-decoration: underline; white-space: nowrap; padding: 2px 4px; user-select: none; }
.text-btn:hover { color: #0056b3; background-color: #f0f8ff; border-radius: 3px; }
.text-btn.active { color: #28a745; text-decoration: none; border: 1px solid #28a745; border-radius: 3px; padding: 1px 3px; }
.separator { color: #ccc; font-size: 0.8em; margin: 0 2px; user-select: none; }

/* =========================================
   コントロールエリア
   ========================================= */
.controls { background: #f4f4f4; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
.control-group { margin-bottom: 10px; }
.control-group:last-child { margin-bottom: 0; }
label { margin-right: 10px; font-weight: bold; }
input[type="text"],
input[type="number"] { padding: 5px; border: 1px solid #ccc; border-radius: 4px; }

/* =========================================
   ボタン（通常）
   ========================================= */
button { cursor: pointer; padding: 6px 12px; background: #007bff; color: white; border: none; border-radius: 4px; font-size: 14px; }
button:hover { background: #0056b3; }
button.secondary { background: #6c757d; }
button.secondary:hover { background: #545b62; }
button.active { background: #28a745; }

/* =========================================
   ユーティリティ
   ========================================= */
.hidden { display: none !important; }
.description-box { background: #e9ecef; padding: 10px; border-radius: 4px; margin-bottom: 15px; font-size: 0.9em; }
.result-box { margin-bottom: 10px; font-weight: bold; color: #d9534f; }
.error { color: red; font-weight: bold; }

/* =========================================
   テーブルスタイル (Gacha Rolls)
   ========================================= */
#rolls-table-container { overflow-x: auto; overflow-y: auto; max-height: none; flex-grow: 1; border: 1px solid #ddd; margin-bottom: 0; }
table { border-collapse: separate; border-spacing: 0; width: 100%; margin-top: 0; font-size: 12px; }
th, td { border: 1px solid #ddd; padding: 6px; text-align: center; white-space: nowrap; }

th { background-color: #f8f9fa; font-weight: bold; border-top: 1px solid #ddd; border-bottom: 1px solid #ddd; box-shadow: 0 1px 0 #ddd; }
.sticky-row th { position: sticky; top: 0; z-index: 20; border-bottom: none; box-shadow: 0 2px 2px rgba(0,0,0,0.1); background-color: #f8f9fa; }
.control-row th { position: static; border-top: none; background-color: #f8f9fa; padding-top: 2px; padding-bottom: 4px; z-index: 1; }

.col-no { background-color: #f8f9fa; width: 30px; }
.calc-column { background-color: #f0f8ff; font-size: 0.9em; color: #555; }
.gacha-column { min-width: 120px; }
.gacha-cell { position: relative; }
.highlight { position: relative; }
.highlight-uber { font-weight: bold; color: #c2185b; }
.char-link:hover { color: #0056b3; }
.remove-btn { background: #dc3545; padding: 2px 6px; font-size: 10px; margin-left: 5px; }
.add-gacha-btn { background: #28a745; padding: 2px 8px; font-size: 11px; }
.uber-add-select { cursor: pointer; border: 1px solid #ccc; border-radius: 3px; background-color: #fff; }

/* =========================================
   スケジュール表 & ガントチャート共通
   ========================================= */
#schedule-container { padding: 20px; background-color: #fff; border-top: 1px solid #ddd; max-width: 100%; box-sizing: border-box; flex-grow: 1; overflow-y: auto; }
.schedule-scroll-wrapper { overflow-x: auto; max-height: none; border: 1px solid #ddd; max-width: 100%; }
.schedule-table { width: 100%; border-collapse: separate; border-spacing: 0; margin-top: 0; font-size: 14px; }
.schedule-table th,
.schedule-table td { border: 1px solid #ddd; padding: 8px; text-align: center; white-space: nowrap; }
.schedule-table td:nth-child(3) { white-space: normal; text-align: left; min-width: 250px; }
.schedule-table th { background-color: #eee; position: sticky; top: 0; z-index: 10; border-top: 1px solid #ddd; border-bottom: 1px solid #ccc; }
.row-ended { background-color: #e0e0e0 !important; color: #666; }
.row-ended .gantt-bar { filter: grayscale(100%); opacity: 0.6; }
.row-guaranteed { background-color: #ffffe0 !important; }

/* =========================================
   ガントチャート
   ========================================= */
.gantt-outer-wrapper * { box-sizing: border-box; }
.gantt-outer-wrapper { display: inline-block; max-width: 100%; vertical-align: top; width: 100%; }
.gantt-chart-container { border: 1px solid #ccc; background: #fff; font-size: 12px; margin-bottom: 20px; max-width: 100%; }
.gantt-scroll-wrapper { overflow-x: auto; position: relative; padding-bottom: 10px; width: 100%; }
.gantt-header { display: flex; border-bottom: 1px solid #ccc; background: #f9f9f9; position: sticky; left: 0; z-index: 6; }
.gantt-label-col { width: 160px; min-width: 160px; padding: 5px; border-right: 1px solid #ccc; background-color: inherit; position: sticky; left: 0; z-index: 5; display: flex; align-items: center; justify-content: center; font-weight: bold; border-bottom: 1px solid #eee; }
.gantt-header .gantt-label-col { background-color: #f9f9f9; }
.gantt-date-cell { border-right: 1px solid #eee; text-align: center; padding: 5px 0; font-size: 10px; flex-shrink: 0; }
.gantt-date-cell.today { background-color: #ffeb3b; }
.gantt-date-cell.weekend { background-color: #e0f7fa; }
.gantt-body { position: relative; }
.gantt-row { display: flex; border-bottom: 1px solid #eee; height: 30px; background-color: #fff; }
.gantt-row:hover { filter: brightness(0.95); }
.gantt-row .gantt-label-col { font-weight: normal; text-align: center; justify-content: center; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: block; line-height: 20px; }
.gantt-bar-area { position: relative; height: 100%; flex-grow: 1; }
.gantt-bar { position: absolute; top: 5px; height: 20px; background-color: #4caf50; border: 1px solid #4caf50; box-shadow: none; border-radius: 3px; color: #fff; font-size: 10px; display: flex; align-items: center; justify-content: center; overflow: hidden; white-space: nowrap; z-index: 2; }
.gantt-bar.g-kyoku { background-color: #e91e63; border-color: #e91e63; }
.gantt-bar.g-cho { background-color: #9c27b0; border-color: #9c27b0; }
.gantt-bar.g-fest { background-color: #ff9800; border-color: #ff9800; }
.gantt-bar.g-collab { background-color: #2196f3; border-color: #2196f3; }
.gantt-bar-text { padding: 0 4px; }
.gantt-grid-line { position: absolute; top: 0; bottom: 0; border-right: 1px solid #f5f5f5; z-index: 0; }
.gantt-grid-line.weekend { background-color: rgba(224, 247, 250, 0.3); }
.gantt-current-line { position: absolute; top: 0; bottom: 0; width: 2px; background-color: #ff0000; z-index: 1; opacity: 0.7; pointer-events: none; }

/* =========================================
   モバイル用・高密度表示レイアウト
   ========================================= */
@media (max-width: 768px) { 
 html, body { height: 100%; margin: 0; padding: 0 !important; overflow: hidden; }
 .container { height: 100%; display: flex; flex-direction: column; padding: 4px; box-sizing: border-box; }
 .header-row, .controls, .description-box, #result, .forecast-summary-container { flex-shrink: 0; }
 .header-row { flex-direction: row !important; flex-wrap: nowrap !important; overflow-x: auto; align-items: center; padding-bottom: 5px; border-bottom: 1px solid #eee; margin-bottom: 5px; white-space: nowrap; }
 h1 { font-size: 16px !important; margin-right: 8px; display: inline-block; }
 .header-actions { width: auto; flex-wrap: nowrap; gap: 4px; }
 .text-btn { font-size: 11px; padding: 2px 3px; }
 .header-actions button, .header-actions span:not(.text-btn):not(.separator) { font-size: 10px !important; padding: 2px 6px !important; height: 24px; line-height: 20px; }
 #rolls-table-container { flex-grow: 1; max-height: none !important; margin-bottom: 0 !important; overflow-y: auto; border-bottom: none; width: 100%; }
 #schedule-container { flex-grow: 1; overflow-y: auto; padding-bottom: 0; width: 100%; max-width: 100vw; box-sizing: border-box; } 
 .schedule-scroll-wrapper { max-height: none !important; width: 100%; }
 .controls { padding: 8px; margin-bottom: 5px; }
 .control-group { margin-bottom: 4px; display: flex; flex-wrap: wrap; align-items: center; }
 label { font-size: 10px; margin-right: 5px; }
 input[type="text"], input[type="number"], select { font-size: 11px; padding: 2px 4px; height: 24px; }
 #seed, #sim-config { max-width: 120px; }
 button { padding: 3px 8px; font-size: 11px; height: 24px; line-height: 1; }
 table { font-size: 10px; margin-top: 5px; }
 th, td { padding: 2px 3px; height: auto; }
 .gacha-column { min-width: 85px; max-width: 100px; overflow: hidden; }  
 .gacha-header-wrapper { gap: 2px; justify-content: flex-start !important; width: 100%; }
 th div[style*="margin-top"] { transform: scale(0.85); transform-origin: center top; width: 115%; margin-left: -7.5%; white-space: nowrap; }
 .gacha-cell { line-height: 1.1; }
 .calc-column { font-size: 9px; width: auto; }
 .schedule-table th, .schedule-table td { padding: 2px 4px; font-size: 10px; }  
 .schedule-table td:nth-child(3) { min-width: 140px; }
 .gantt-row { height: 24px !important; }
 .gantt-label-col { width: 100px !important; min-width: 100px !important; font-size: 10px !important; line-height: 24px !important; padding: 0 2px !important; }
 .gantt-bar { height: 16px !important; top: 4px !important; font-size: 9px !important; }
 .gantt-date-cell { font-size: 9px !important; }
 #result { font-size: 10px; }
}

/* =========================================
   スケジュールエディタ用スタイル
   ========================================= */
#schedule-editor-table input[type="text"],
#schedule-editor-table input[type="number"] {
    font-size: 11px;
    padding: 2px;
    border: 1px solid #ccc;
    border-radius: 2px;
    box-sizing: border-box;
}

#schedule-editor-table td {
    padding: 4px 2px;
    vertical-align: middle;
}

#schedule-editor-table .remove-btn {
    background-color: #dc3545;
    color: white;
    border: none;
    border-radius: 3px;
    cursor: pointer;
}

====================
FILE: ui_cell_event.js
====================
/** @file ui_cell_event.js @description ガチャセルクリック時のイベントハンドラ */

function onGachaCellClick(targetSeedIndex, gachaId, charName, guaranteedType = null, fromFind = false, targetCharId = null) {
    if (isSimulationMode) {
        const errorEl = document.getElementById('sim-error-msg');
        if (errorEl) {
            errorEl.textContent = '';
            errorEl.style.display = 'none';
        }

        const visibleIds = tableGachaIds.map(id => id);
        const configInput = document.getElementById('sim-config');
        const currentConfig = configInput ? configInput.value : "";

        if (typeof calculateRouteToCell === 'function') {
            let routeConfig;
            if (guaranteedType) {
                const finalAction = { 
                    id: gachaId, 
                    rolls: parseInt(guaranteedType.replace('g', ''), 10), 
                    g: true 
                };
                routeConfig = calculateRouteToCell(targetSeedIndex, gachaId, visibleIds, currentConfig, finalAction, targetCharId);
            } else {
                routeConfig = calculateRouteToCell(targetSeedIndex, gachaId, visibleIds, currentConfig, null, targetCharId);
            }

            if (routeConfig) {
                if (configInput) {
                    configInput.value = routeConfig;
                    if (typeof updateUrlParams === 'function') updateUrlParams();
                    resetAndGenerateTable();
                }
            } else {
                if (errorEl) {
                    const row = Math.floor(targetSeedIndex / 2) + 1;
                    const side = (targetSeedIndex % 2 === 0) ? 'A' : 'B';
                    const cellLabel = `${side}${row}`;
                    errorEl.textContent = `${cellLabel}セルへのルートは見つかりませんでした`;
                    errorEl.style.display = 'block'; 
                }
                console.warn("Route not found.");
            }
        }
    } else {
        toggleAppMode();
        if (fromFind) {
            const notifEl = document.getElementById('sim-notif-msg');
            if (notifEl) {
                notifEl.textContent = 'Findのセル番地クリックによりSIMモードに切り替えました';
                notifEl.style.display = 'inline';
            }
        }
        setTimeout(() => {
            onGachaCellClick(targetSeedIndex, gachaId, charName, guaranteedType, fromFind, targetCharId);
        }, 100);
    }
}

====================
FILE: ui_display_logic.js
====================
/** @file ui_display_logic.js @description 表示要素（SEED列/マスター情報/Find）のトグル管理 */

// グローバル変数の定義を ui_globals.js に移行することを推奨
let isMasterInfoVisible = false; 

function toggleSeedColumns() {
    showSeedColumns = !showSeedColumns;
    if (typeof generateRollsTable === 'function') generateRollsTable(); 
    updateToggleButtons();
}

function updateToggleButtons() {
    const btnSeed = document.getElementById('toggle-seed-btn');
    if(btnSeed) btnSeed.textContent = showSeedColumns ? 'SEED非表示' : 'SEED表示';
}

function toggleMasterInfo() {
    isMasterInfoVisible = !isMasterInfoVisible;
    const content = document.getElementById('master-info-content');
    if (content) {
        content.style.display = isMasterInfoVisible ? 'block' : 'none';
    }
    if (typeof generateRollsTable === 'function') generateRollsTable();
    if (typeof updateMasterInfoView === 'function') updateMasterInfoView();
}

function toggleFindInfo() {
    showFindInfo = !showFindInfo;
    const btn = document.getElementById('toggle-find-info-btn');
    if (typeof generateRollsTable === 'function') generateRollsTable();
    if (btn) {
        if (showFindInfo) btn.classList.add('active');
        else btn.classList.remove('active');
    }
}

====================
FILE: ui_globals.js
====================
/** @file ui_globals.js @description アプリケーション全体で共有されるグローバルな状態変数の定義 @dependency なし */

// UI状態変数 (Global)
let tableGachaIds = [];
let currentRolls = 300;
let showSeedColumns = false;
let showResultDisplay = false;
let showFindInfo = false; // Findエリア（予報＋マスター情報）の表示フラグ
let finalSeedForUpdate = null;
let isSimulationMode = false;
let isTxtMode = false; // Txtボタンの状態
let isScheduleMode = false;
let isDescriptionMode = false; // 追加: 概要表示モードフラグ
let activeGuaranteedIds = new Set();
let isScheduleAnalyzed = false;

// Find機能の状態管理
let hiddenFindIds = new Set(); // 自動ターゲットのうち、非表示にするID
let userTargetIds = new Set();
let isFindListCleared = false;

// 超激レア追加シミュレーション用
let uberAdditionCounts = [];

====================
FILE: ui_mode_logic.js
====================
/** @file ui_mode_logic.js @description アプリの初期化とモード切替（Sim/skd/概要/Txt）の管理 */

function initializeDefaultGachas() {
    if (typeof prepareScheduleInfo === 'function') {
        prepareScheduleInfo();
    }

    if (tableGachaIds.length === 0) {
        let scheduleFound = false;
        if (isScheduleAnalyzed && typeof parseGachaTSV === 'function') {
            try {
                const scheduleData = parseGachaTSV(loadedTsvContent);
                const now = new Date();
                const activeGachas = scheduleData.filter(item => {
                    if (typeof isPlatinumOrLegend === 'function' && isPlatinumOrLegend(item)) return false;
                    const startDt = parseDateTime(item.rawStart, item.startTime);
                    const endDt = parseDateTime(item.rawEnd, item.endTime);
                    return now >= startDt && now <= endDt;
                });
                if (activeGachas.length > 0) {
                    activeGachas.forEach(gacha => {
                        let newId = gacha.id.toString();
                        if (gacha.guaranteed) newId += 'g';
                        tableGachaIds.push(newId);
                        uberAdditionCounts.push(0); 
                    });
                    scheduleFound = true;
                }
            } catch (e) {
                console.warn("Auto-select from schedule failed:", e);
            }
        }
        
        if (!scheduleFound || tableGachaIds.length === 0) {
            const options = getGachaSelectorOptions(null);
            if (options.length > 0) {
                tableGachaIds.push(options[0].value);
                uberAdditionCounts.push(0);
                if (options.length > 1) {
                    tableGachaIds.push(options[1].value);
                    uberAdditionCounts.push(0);
                }
            } else {
                const sortedGachas = Object.values(gachaMasterData.gachas)
                    .filter(gacha => gacha.sort < 800)
                    .sort((a, b) => a.sort - b.sort);
                if (sortedGachas.length > 0) {
                    tableGachaIds.push(sortedGachas[0].id);
                    uberAdditionCounts.push(0);
                }
                if (sortedGachas.length > 1) {
                    tableGachaIds.push(sortedGachas[1].id);
                    uberAdditionCounts.push(0);
                }
            }
        }
    }

    const seedEl = document.getElementById('seed');
    if (seedEl && (seedEl.value === '12345' || seedEl.value === '')) {
        toggleSeedInput();
    }
}

function onModeChange() {
    updateModeButtonState();
    refreshModeView();
}

function toggleAppMode() {
    isSimulationMode = !isSimulationMode;
    onModeChange();
}

function toggleTxtMode() {
    isTxtMode = !isTxtMode;
    onModeChange();
}

function updateModeButtonState() {
    const btnSim = document.getElementById('mode-toggle-btn');
    if (btnSim) {
        if (isSimulationMode) btnSim.classList.add('active');
        else btnSim.classList.remove('active');
    }
    
    const btnTxt = document.getElementById('toggle-txt-btn');
    const btnCopy = document.getElementById('copy-txt-btn');
    if (btnTxt) {
        if (isTxtMode) {
            btnTxt.classList.add('active');
            if (btnCopy) btnCopy.classList.remove('hidden');
        } else {
            btnTxt.classList.remove('active');
            if (btnCopy) btnCopy.classList.add('hidden');
        }
    }
}

function refreshModeView() {
    const simWrapper = document.getElementById('sim-control-wrapper');
    if (simWrapper) {
        if (isSimulationMode && !isScheduleMode && !isDescriptionMode) {
            simWrapper.classList.remove('hidden');
        } else {
            simWrapper.classList.add('hidden');
        }
    }
    resetAndGenerateTable();
}

function toggleDescription() {
    const content = document.getElementById('description-content');
    const toggle = document.getElementById('toggle-description');
    const tableContainer = document.getElementById('rolls-table-container');
    const simWrapper = document.getElementById('sim-control-wrapper');
    const resultDiv = document.getElementById('result');
    const mainControls = document.getElementById('main-controls');
    const scheduleContainer = document.getElementById('schedule-container');

    isDescriptionMode = !isDescriptionMode;
    if (isDescriptionMode) {
        if (typeof isScheduleMode !== 'undefined' && isScheduleMode && typeof toggleSchedule === 'function') {
            toggleSchedule();
        }
        if (toggle) toggle.classList.add('active');
        if (tableContainer) tableContainer.classList.add('hidden');
        if (simWrapper) simWrapper.classList.add('hidden');
        if (resultDiv) resultDiv.classList.add('hidden');
        if (mainControls) mainControls.classList.add('hidden');
        if (scheduleContainer) scheduleContainer.classList.add('hidden');
        if (content) {
            content.classList.remove('hidden');
            content.style.flexGrow = '1';       
            content.style.overflowY = 'auto';   
            content.style.height = '100%';
            content.style.webkitOverflowScrolling = 'touch';
            content.style.minHeight = '0';
            content.style.maxHeight = 'none';
        }
    } else {
        if (toggle) toggle.classList.remove('active');
        if (content) {
            content.classList.add('hidden');
            content.style.flexGrow = '';
            content.style.overflowY = '';
            content.style.height = '';
            content.style.minHeight = '';
            content.style.maxHeight = '';
            content.style.webkitOverflowScrolling = '';
        }
        if (tableContainer) tableContainer.classList.remove('hidden');
        if (mainControls) mainControls.classList.remove('hidden');
        if (isSimulationMode && simWrapper) simWrapper.classList.remove('hidden');
        if (showResultDisplay && resultDiv) resultDiv.classList.remove('hidden');
    }
}

====================
FILE: ui_refresh_logic.js
====================
/** @file ui_refresh_logic.js @description テーブル再描画とConfig操作の管理 */

function resetAndGenerateTable() {
    if (isScheduleMode || isDescriptionMode) return;
    finalSeedForUpdate = null;
    const simConf = document.getElementById('sim-config');
    if (simConf && simConf.value.trim() === '') {
         currentRolls = 300;
    }
    if (typeof generateRollsTable === 'function') generateRollsTable();
    updateMasterInfoView();
    if (typeof updateUrlParams === 'function') updateUrlParams();
}

function addMoreRolls() {
    currentRolls += 100;
    if (typeof generateRollsTable === 'function') generateRollsTable();
}

function clearSimConfig() {
    const el = document.getElementById('sim-config');
    if(el) el.value = '';
    const errorEl = document.getElementById('sim-error-msg');
    if (errorEl) {
        errorEl.textContent = '';
        errorEl.style.display = 'none';
    }
    const notifEl = document.getElementById('sim-notif-msg');
    if (notifEl) {
        notifEl.textContent = '';
        notifEl.style.display = 'none';
    }
    resetAndGenerateTable();
}

function backSimConfig() {
    const el = document.getElementById('sim-config');
    if (el && typeof removeLastConfigSegment === 'function') {
        el.value = removeLastConfigSegment(el.value);
        resetAndGenerateTable();
    }
}

function updateMasterInfoView() {
    const el = document.getElementById('master-info-area');
    if (!el || typeof generateMasterInfoHTML !== 'function') return;
    const configs = [];
    tableGachaIds.forEach(idStr => {
        let gachaId = idStr.replace(/[gfs]$/, '');
        if (gachaMasterData.gachas[gachaId]) {
            configs.push(gachaMasterData.gachas[gachaId]);
        }
    });
    el.innerHTML = generateMasterInfoHTML(configs);
}

====================
FILE: ui_schedule_editor_handler.js
====================
/** @file ui_schedule_editor_handler.js @description スケジュールエディタの操作イベント（追加・削除・インポート）を管理 */

/**
 * テキストからスケジュールを解析して行を追加する
 */
function processTextImport() {
    const textArea = document.getElementById('import-text-input');
    if (!textArea) return;

    let text = textArea.value;
    // ANSIエスケープシーケンス（\x1b[...m）を削除
    text = text.replace(/\x1b\[[0-9;]*m/g, "");

    const lines = text.split('\n');
    let addCount = 0;
    const now = new Date();
    const currentYear = now.getFullYear();

    lines.forEach(line => {
        if (!line.trim() || !line.includes('月')) return;

        try {
            // 1. 日付の抽出: [12月 25日 ~ 29日]
            const dateMatch = line.match(/\[(\d+)月\s*(\d+)日\s*~\s*(\d+)日\]/);
            if (!dateMatch) return;

            const month = dateMatch[1].padStart(2, '0');
            const startDay = dateMatch[2].padStart(2, '0');
            const endDay = dateMatch[3].padStart(2, '0');

            let year = currentYear;
            if (now.getMonth() === 0 && month === "12") year--;
            if (now.getMonth() === 11 && month === "01") year++;

            const rawStart = `${year}${month}${startDay}`;
            const rawEnd = `${year}${month}${endDay}`;

            // 2. ガチャ名の抽出
            const afterDate = line.substring(line.indexOf(']') + 1).trim();
            let gachaName = afterDate.split(/[\[<]/)[0].trim();
            gachaName = gachaName.replace(/\(\+.+?\)/, "").trim();

            // 3. フラグの抽出: [G|L|N] など
            const flagsMatch = line.match(/\[([^\]]*[GLNPRSP][^\]]*)\]/);
            const isGuaranteed = flagsMatch ? flagsMatch[1].includes('G') : false;

            // 4. 特殊確率の抽出: UR = 7%
            let uberRate = "500";
            const rateMatch = line.match(/UR\s*=\s*(\d+)%/);
            if (rateMatch) {
                uberRate = parseInt(rateMatch[1]) * 100;
            } else if (gachaName.includes("超ネコ祭") || gachaName.includes("極ネコ祭")) {
                uberRate = "900";
            } else if (gachaName.includes("超極ネコ祭")) {
                uberRate = "1000";
            } else if (gachaName.includes("超国王祭")) {
                uberRate = "700";
            }

            // 5. マスターデータからIDを検索
            let foundId = "0";
            if (typeof getGachaSelectorOptions === 'function') {
                const options = getGachaSelectorOptions();
                
                // まずはテキストのガチャ名で検索
                const match = options.find(opt => opt.label.includes(gachaName)) || 
                              options.find(opt => gachaName.includes(opt.label.split(') ')[1]));
                
                if (match) {
                    foundId = match.value;
                } else {
                    // 見つからなかった場合は「ネコルガ族」をデフォルトにする
                    const fallback = options.find(opt => opt.label.includes("ネコルガ族"));
                    if (fallback) foundId = fallback.value;
                }
            }

            // 行を追加
            const item = {
                rawStart: rawStart, startTime: "1100",
                rawEnd: rawEnd, endTime: "1059",
                id: foundId, tsvName: gachaName,
                uber: uberRate, legend: "30",
                guaranteed: isGuaranteed
            };

            const tbody = document.querySelector('#schedule-editor-table tbody');
            if (tbody) {
                const tempTable = document.createElement('table');
                tempTable.innerHTML = createEditorRowHtml(item);
                tbody.appendChild(tempTable.querySelector('tr'));
                addCount++;
            }
        } catch (e) {
            console.warn("Line parse error:", line, e);
        }
    });

    if (addCount > 0) {
        alert(`${addCount}件のスケジュールを追加しました。`);
        textArea.value = "";
        toggleImportArea();
    } else {
        alert("解析可能な行が見つかりませんでした。");
    }
}

/**
 * 現在のエディタの内容を解析してTSV文字列を生成する
 */
function captureEditorDataToTsv() {
    const rows = document.querySelectorAll('#schedule-editor-table tbody tr');
    let tsvRows = [];

    rows.forEach(row => {
        const rawStartD = row.querySelector('.edit-start-date').value.replace(/-/g, '');
        const rawEndD = row.querySelector('.edit-end-date').value.replace(/-/g, '');
        const startH = row.querySelector('.edit-start-time').value;
        const endH = row.querySelector('.edit-end-time').value;
        const startT = startH + "00";
        const endT = endH + "59";

        const gId = row.querySelector('.edit-id').value.trim();
        const name = row.querySelector('.edit-name').value.trim();
        const uber = row.querySelector('.edit-uber').value.trim();
        const legend = row.querySelector('.edit-legend').value.trim();
        const isG = row.querySelector('.edit-guaranteed').checked ? "1" : "0";

        if (!rawStartD || !rawEndD || !gId) return;

        let cols = Array(25).fill("0");
        cols[0] = rawStartD; cols[1] = startT;
        cols[2] = rawEndD; cols[3] = endT;
        cols[8] = "1"; cols[10] = gId;
        cols[16] = "7000"; cols[18] = "2500"; 
        cols[20] = uber; cols[21] = isG;
        cols[22] = legend; cols[24] = name;

        tsvRows.push(cols.join('\t'));
    });
    return tsvRows.join('\n');
}

/**
 * 編集内容を一時的にアプリに反映させる
 */
function applyScheduleTemporarily() {
    const tsvContent = captureEditorDataToTsv();
    if (!tsvContent) {
        alert("有効な予定データがありません。");
        return;
    }

    loadedTsvContent = tsvContent;
    isScheduleAnalyzed = false;
    window.isScheduleEditMode = false;

    if (typeof renderScheduleTable === 'function') {
        renderScheduleTable(loadedTsvContent, 'schedule-container');
    }
    
    if (typeof generateRollsTable === 'function') generateRollsTable();
}

/**
 * エディタに新しい予定行を末尾に追加する
 */
function addNewScheduleRow() {
    const tbody = document.querySelector('#schedule-editor-table tbody');
    if (!tbody) return;
    
    if (typeof createEditorRowHtml === 'function') {
        const newRowHtml = createEditorRowHtml();
        const tempTable = document.createElement('table');
        tempTable.innerHTML = newRowHtml;
        const newRow = tempTable.querySelector('tr');
        tbody.appendChild(newRow);
        newRow.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
    }
}

/**
 * 指定された行を削除する
 */
function deleteEditorRow(btn) {
    if (confirm("この予定を削除しますか？")) {
        const row = btn.closest('tr');
        if (row) {
            row.parentNode.removeChild(row);
        }
    }
}

/**
 * 現在のエディタの内容を gatya.tsv 形式でダウンロードする
 */
function generateAndDownloadTSV() {
    const tsvContent = captureEditorDataToTsv();
    if (!tsvContent) {
        alert("データがありません。");
        return;
    }

    const blob = new Blob([tsvContent], { type: 'text/tab-separated-values' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'gatya.tsv';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    loadedTsvContent = tsvContent;
    alert("gatya.tsv を作成しました。\nGitHubの gatya.tsv をこのファイルで上書きしてください。");
}

====================
FILE: ui_schedule_handler.js
====================
/** @file ui_schedule_handler.js @description スケジュールモード（skd）の切替、スケジュールからの列追加を担当 @dependency schedule_logic.js, view_schedule.js */

// スケジュール情報の事前解析
function prepareScheduleInfo() {
    if (isScheduleAnalyzed) return;
    if (typeof loadedTsvContent === 'string' && loadedTsvContent && 
        typeof parseGachaTSV === 'function' && typeof parseDateTime === 'function') {
        try {
            const scheduleData = parseGachaTSV(loadedTsvContent);
            const now = new Date();
            activeGuaranteedIds.clear();

            scheduleData.forEach(item => {
                const startDt = parseDateTime(item.rawStart, item.startTime);
                const endDt = parseDateTime(item.rawEnd, item.endTime);
                
                if (now >= startDt && now <= endDt) {
            
                    if (item.guaranteed) {
                        const gId = parseInt(item.id);
                        activeGuaranteedIds.add(gId);
                        if (gachaMasterData && gachaMasterData.gachas && gachaMasterData.gachas[gId]) {
         
                            const currentName = gachaMasterData.gachas[gId].name;
                            if (!currentName.includes('[確定]')) {
                                 gachaMasterData.gachas[gId].name += " [確定]";
            
                            }
                        }
                    }
                }
            });
            isScheduleAnalyzed = true;
            console.log("Schedule Analyzed. Active Guaranteed IDs:", Array.from(activeGuaranteedIds));
        } catch (e) {
            console.warn("Schedule analysis failed:", e);
        }
    }
}

// スケジュールモードのUIセットアップ
function setupScheduleUI() {
    let scheduleContainer = document.getElementById('schedule-container');
    if (!scheduleContainer) {
        scheduleContainer = document.createElement('div');
        scheduleContainer.id = 'schedule-container';
        scheduleContainer.className = 'hidden';
        const tableContainer = document.getElementById('rolls-table-container');
        if (tableContainer) {
            tableContainer.parentNode.insertBefore(scheduleContainer, tableContainer.nextSibling);
        } else {
            document.body.appendChild(scheduleContainer);
        }
    }
}

// スケジュールモードの切り替え (skdボタン)
function toggleSchedule() {
    if (!loadedTsvContent) {
        alert("スケジュールの読み込みに失敗しました。");
        return;
    }

    isScheduleMode = !isScheduleMode;
    
    if (!isScheduleMode) {
        window.isScheduleEditMode = false;
    }

    if (typeof isDescriptionMode !== 'undefined' && isDescriptionMode && typeof toggleDescription === 'function' && isScheduleMode) {
        toggleDescription();
    }

    const scheduleBtn = document.getElementById('toggle-schedule-btn');
    const simWrapper = document.getElementById('sim-control-wrapper');
    const tableContainer = document.getElementById('rolls-table-container');
    const scheduleContainer = document.getElementById('schedule-container');
    const resultDiv = document.getElementById('result');
    const mainControls = document.getElementById('main-controls');

    if (isScheduleMode) {
        scheduleBtn.classList.add('active');
        if (simWrapper) simWrapper.classList.add('hidden');
        if (tableContainer) tableContainer.classList.add('hidden');
        if (resultDiv) resultDiv.classList.add('hidden');
        if (mainControls) mainControls.classList.add('hidden');
        if (scheduleContainer) {
            scheduleContainer.classList.remove('hidden');
            // 反映ボタン等で解析フラグが落ちている場合に備えて再解析
            prepareScheduleInfo();
            if (typeof renderScheduleTable === 'function') {
                renderScheduleTable(loadedTsvContent, 'schedule-container');
            }
        }
    } else {
        scheduleBtn.classList.remove('active');
        if (isSimulationMode && simWrapper) simWrapper.classList.remove('hidden');
        if (tableContainer) tableContainer.classList.remove('hidden');
        if (resultDiv && showResultDisplay) resultDiv.classList.remove('hidden');
        if (mainControls) mainControls.classList.remove('hidden');
        if (scheduleContainer) {
            scheduleContainer.classList.add('hidden');
        }
    }
}

/**
 * 編集モードへの移行処理
 */
function enterScheduleEditMode() {
    if (!loadedTsvContent) return;
    window.isScheduleEditMode = true;
    if (typeof renderScheduleEditor === 'function') {
        renderScheduleEditor(loadedTsvContent, 'schedule-container');
    }
}

// スケジュールから開催中・予定のガチャを一括追加
function addGachasFromSchedule() {
    if (!loadedTsvContent || typeof parseGachaTSV === 'function') {
        alert("スケジュールデータがありません。");
        return;
    }

    const scheduleData = parseGachaTSV(loadedTsvContent);
    const now = new Date();
    const todayStr = now.getFullYear() + 
                     String(now.getMonth() + 1).padStart(2, '0') + 
                     String(now.getDate()).padStart(2, '0');
    const todayInt = parseInt(todayStr, 10);

    const newGachaData = [];

    scheduleData.forEach((item, index) => {
        let endValue = parseInt(item.rawEnd, 10);
        const isPlat = item.seriesName.includes("プラチナ");
        const isLeg = item.seriesName.includes("レジェンド");

        if (isPlat || isLeg) {
            const nextSameType = scheduleData.slice(index + 1).find(nextItem => {
                if (isPlat) return nextItem.seriesName.includes("プラチナ");
                if (isLeg) return nextItem.seriesName.includes("レジェンド");
                return false;
            });
            if (nextSameType) {
                endValue = parseInt(nextSameType.rawStart, 10);
            }
        }

        if (endValue < todayInt) return;

        let fullId = item.id.toString();
        if (item.guaranteed) fullId += 'g';

        let typeOrder = 0;
        if (isPlat) typeOrder = 1;
        else if (isLeg) typeOrder = 2;
        
        newGachaData.push({
            fullId: fullId,
            rawStart: parseInt(item.rawStart, 10),
            typeOrder: typeOrder,
            count: 0
        });
    });

    if (newGachaData.length === 0) {
        alert("条件に合致するスケジュール（現在開催中または未来）がありません。");
        return;
    }

    newGachaData.sort((a, b) => {
        if (a.typeOrder !== b.typeOrder) return a.typeOrder - b.typeOrder;
        return a.rawStart - b.rawStart;
    });

    const scheduleIds = new Set(newGachaData.map(d => d.fullId.replace(/[gfs]$/, '')));
    const keptGachas = [];
    tableGachaIds.forEach((idWithSuffix, index) => {
        const baseId = idWithSuffix.replace(/[gfs]$/, '');
        if (!scheduleIds.has(baseId)) {
            keptGachas.push({
                fullId: idWithSuffix,
                count: uberAdditionCounts[index] || 0
            });
        }
    });

    const finalGachaList = [...keptGachas, ...newGachaData];
    tableGachaIds = finalGachaList.map(item => item.fullId);
    uberAdditionCounts = finalGachaList.map(item => item.count);
    if (typeof generateRollsTable === 'function') generateRollsTable();
    if (typeof updateMasterInfoView === 'function') updateMasterInfoView();
    if (typeof updateUrlParams === 'function') updateUrlParams();
}

====================
FILE: ui_seed_logic.js
====================
/** @file ui_seed_logic.js @description SEED値の操作・同期ロジック */

function toggleSeedInput() {
    const container = document.getElementById('seed-input-container');
    const trigger = document.getElementById('seed-input-trigger');
    if (!container) return;

    if (container.classList.contains('hidden')) {
        container.classList.remove('hidden');
        if (trigger) {
            trigger.classList.remove('hidden');
            trigger.classList.add('active');
        }
        const input = document.getElementById('seed');
        if (input) input.focus();
    } else {
        cancelSeedInput();
    }
}

function applySeedInput() {
    if (typeof updateUrlParams === 'function') updateUrlParams();
    resetAndGenerateTable();
    const container = document.getElementById('seed-input-container');
    const trigger = document.getElementById('seed-input-trigger');
    if (container) container.classList.add('hidden');
    if (trigger) {
        trigger.classList.remove('hidden');
        trigger.classList.remove('active');
    }
}

function cancelSeedInput() {
    const container = document.getElementById('seed-input-container');
    const trigger = document.getElementById('seed-input-trigger');
    const input = document.getElementById('seed');
    const urlParams = new URLSearchParams(window.location.search);
    const currentSeed = urlParams.get('seed') || "12345";
    if (input) input.value = currentSeed;
    if (container) container.classList.add('hidden');
    if (trigger) {
        trigger.classList.remove('hidden');
        trigger.classList.remove('active');
    }
}

function copySeedToClipboard() {
    const seedInput = document.getElementById('seed');
    if (!seedInput) return;
    navigator.clipboard.writeText(seedInput.value).catch(err => {
        console.error('Failed to copy: ', err);
    });
}

/** * ルート（Config）と表示テキストをクリップボードへコピー 
 */
function copyTxtToClipboard() {
    const configInput = document.getElementById('sim-config');
    const txtDisplay = document.getElementById('txt-route-display');
    const notifEl = document.getElementById('sim-notif-msg');

    if (!configInput || !txtDisplay) return;

    // ルート入力値 + 改行 + テキストエリアの表示内容
    const textToCopy = configInput.value + "\n\n" + txtDisplay.innerText;

    navigator.clipboard.writeText(textToCopy).then(() => {
        if (notifEl) {
            notifEl.textContent = 'Copyed!';
            notifEl.style.display = 'inline';
            setTimeout(() => {
                notifEl.style.display = 'none';
            }, 2000);
        }
    }).catch(err => {
        console.error('Failed to copy: ', err);
    });
}

function updateSeedAndRefresh(newSeed) {
    const seedInput = document.getElementById('seed');
    if(seedInput && newSeed) {
        seedInput.value = newSeed;
        currentRolls = 300;
        if (typeof generateRollsTable === 'function') generateRollsTable();
        updateMasterInfoView();
        if (typeof updateUrlParams === 'function') updateUrlParams();
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }
}

function updateSeedFromSim() {
    if (finalSeedForUpdate) {
        document.getElementById('seed').value = finalSeedForUpdate;
        document.getElementById('sim-config').value = '';
        resetAndGenerateTable(); 
    }
}

====================
FILE: ui_table_handler.js
====================
/** @file ui_table_handler.js @description テーブルの列操作（追加、削除、変更）のイベントハンドラを担当 @dependency view_table.js */

// 新しいガチャ列を追加 (デフォルト選択)
function addGachaColumn() {
    const options = getGachaSelectorOptions(null);
    if (options.length > 0) {
        let val = options[0].value;
        if (activeGuaranteedIds.has(parseInt(val))) val += 'g';
        tableGachaIds.push(val);
        uberAdditionCounts.push(0); 
        if (typeof generateRollsTable === 'function') generateRollsTable();
        if (typeof updateMasterInfoView === 'function') updateMasterInfoView();
    }
}

// ガチャ列を削除
function removeGachaColumn(index) {
    if (tableGachaIds.length > 1) {
        tableGachaIds.splice(index, 1);
        uberAdditionCounts.splice(index, 1);
        if (typeof generateRollsTable === 'function') generateRollsTable();
        if (typeof updateMasterInfoView === 'function') updateMasterInfoView();
    }
}

// 最初の列以外をリセット (×ボタンから呼ばれる)
function resetToFirstGacha() {
    if (tableGachaIds.length <= 1) return;
    
    if (confirm("一番左の列以外を削除しますか？")) {
        tableGachaIds = [tableGachaIds[0]];
        uberAdditionCounts = [uberAdditionCounts[0]];
        if (typeof generateRollsTable === 'function') generateRollsTable();
        if (typeof updateMasterInfoView === 'function') updateMasterInfoView();
        if (typeof updateUrlParams === 'function') updateUrlParams();
    }
}

// 列のガチャを変更（プルダウン操作）
function updateGachaSelection(selectElement, index) {
    const originalIdWithSuffix = tableGachaIds[index];
    const newBaseId = selectElement.value;
    if (activeGuaranteedIds.has(parseInt(newBaseId))) {
        tableGachaIds[index] = newBaseId + 'g';
    } else {
        let suffix = '';
        if (originalIdWithSuffix.endsWith('f')) suffix = 'f';
        else if (originalIdWithSuffix.endsWith('s')) suffix = 's';
        else if (originalIdWithSuffix.endsWith('g')) suffix = 'g';
        tableGachaIds[index] = newBaseId + suffix;
    }
    if (typeof generateRollsTable === 'function') generateRollsTable();
    if (typeof updateMasterInfoView === 'function') updateMasterInfoView();
}

// 確定枠タイプの切り替え (通常 -> 11g -> 15g -> 7g)
function toggleGuaranteedColumn(index) {
    const currentVal = tableGachaIds[index];
    let baseId = currentVal;
    let suffix = '';
    
    if (currentVal.endsWith('f')) { suffix = 'f'; baseId = currentVal.slice(0, -1); } 
    else if (currentVal.endsWith('s')) { suffix = 's'; baseId = currentVal.slice(0, -1); } 
    else if (currentVal.endsWith('g')) { suffix = 'g'; baseId = currentVal.slice(0, -1); }

    let nextSuffix = '';
    if (suffix === '') nextSuffix = 'g';
    else if (suffix === 'g') nextSuffix = 'f';
    else if (suffix === 'f') nextSuffix = 's';
    else if (suffix === 's') nextSuffix = '';
    
    tableGachaIds[index] = baseId + nextSuffix;
    if (typeof generateRollsTable === 'function') generateRollsTable();
}

// 新規キャラ追加数（add機能）の更新
function updateUberAddition(selectElement, index) {
    const val = parseInt(selectElement.value, 10);
    uberAdditionCounts[index] = (!isNaN(val)) ? val : 0;
    if (typeof generateRollsTable === 'function') generateRollsTable();
}

// add入力欄の表示
function showAddInput(index) {
    const trigger = document.getElementById(`add-trigger-${index}`);
    const wrapper = document.getElementById(`add-select-wrapper-${index}`);
    if(trigger) trigger.style.display = 'none';
    if(wrapper) wrapper.style.display = 'inline-block';
}

// ID指定追加入力欄の表示
function showIdInput() {
    const idStr = prompt("追加したいガチャIDを入力してください（例: 1006）\n確定枠付きにする場合はIDの末尾に g を付けてください（例: 1006g）");
    if (idStr) {
        const cleanId = idStr.trim();
        const baseId = cleanId.replace(/[gfs]$/, '');
        if (gachaMasterData.gachas[baseId]) {
            tableGachaIds.push(cleanId);
            uberAdditionCounts.push(0);
            if (typeof generateRollsTable === 'function') generateRollsTable();
            if (typeof updateMasterInfoView === 'function') updateMasterInfoView();
            if (typeof updateUrlParams === 'function') updateUrlParams();
        } else {
            alert("無効なガチャIDです。");
        }
    }
}

====================
FILE: ui_target_handler.js
====================
/** @file ui_target_handler.js @description Find機能のターゲット指定（伝説・限定）の管理を担当 @dependency ui_globals.js, view_table.js */

// 自動ターゲット対象かどうか
// 変更: 伝説レア・限定キャラを除外し、手動追加（sim-new）のみを自動対象とする
function isAutomaticTarget(charId) {
    const idStr = String(charId);
    if (idStr.startsWith('sim-new-')) return true;
    
    // 以前のロジック（限定・伝説を自動対象とする）を無効化
    return false;
}

// キャラクターの表示/非表示トグル（Findリストやマスター情報からのクリック）
function toggleCharVisibility(charId) {
    let idVal = charId;
    if (!isNaN(parseInt(charId)) && !String(charId).includes('sim-new')) {
        idVal = parseInt(charId);
    }
    
    if (isAutomaticTarget(idVal)) {
        // 自動ターゲット（sim-new等）は hidden リストで管理（デフォルト表示→非表示にする）
        if (hiddenFindIds.has(idVal)) hiddenFindIds.delete(idVal);
        else hiddenFindIds.add(idVal);
    } else {
        // 手動ターゲット（伝説・限定含む）は userTarget リストで管理（デフォルト非表示→表示にする）
        if (userTargetIds.has(idVal)) userTargetIds.delete(idVal);
        else userTargetIds.add(idVal);
    }
    
    // テーブルとFindエリアの更新
    if (typeof generateRollsTable === 'function') generateRollsTable();
    // マスター情報の表示更新（ハイライト切り替えのため追加）
    if (typeof updateMasterInfoView === 'function') updateMasterInfoView();
}

// ターゲット一括操作: 全消去 (×ボタン)
function clearAllTargets() {
    const uniqueIds = [...new Set(tableGachaIds.map(idStr => {
        let id = idStr;
        if (id.endsWith('f') || id.endsWith('s') || id.endsWith('g')) id = id.slice(0, -1);
        return id;
    }))];
    
    uniqueIds.forEach(id => {
        // 追加キャラ(sim-new)を隠す
        const colIndex = tableGachaIds.findIndex(tid => tid.startsWith(id));
        const addCount = (colIndex >= 0 && uberAdditionCounts[colIndex]) ? uberAdditionCounts[colIndex] : 0;
        for(let k=1; k<=addCount; k++){
           hiddenFindIds.add(`sim-new-${k}`);
        }
    });

    // 手動ターゲットリスト（伝説・限定含む）を空にする
    userTargetIds.clear();
    
    if (typeof generateRollsTable === 'function') generateRollsTable();
    if (typeof updateMasterInfoView === 'function') updateMasterInfoView();
}

// ターゲット一括操作: 伝説トグル
// 変更: 現在の状態を確認し、全て選択済みなら解除、それ以外なら全選択を行う
function toggleLegendTargets() {
    const uniqueIds = [...new Set(tableGachaIds.map(idStr => {
        let id = idStr;
        if (id.endsWith('f') || id.endsWith('s') || id.endsWith('g')) id = id.slice(0, -1);
        return id;
    }))];

    // まず対象となるIDを全て収集
    let allLegendIds = [];
    uniqueIds.forEach(id => {
        const config = gachaMasterData.gachas[id];
        if (!config || !config.pool.legend) return;
        config.pool.legend.forEach(c => {
            allLegendIds.push(c.id);
        });
    });

    if (allLegendIds.length === 0) return;

    // 現在全て選択されているかチェック
    const isAllSelected = allLegendIds.every(cid => userTargetIds.has(cid));

    if (isAllSelected) {
        // 全て選択済み -> 全解除
        allLegendIds.forEach(cid => userTargetIds.delete(cid));
    } else {
        // 未選択がある -> 全選択
        allLegendIds.forEach(cid => userTargetIds.add(cid));
        // もしHiddenに入っていたら削除（自動ターゲットの場合の保険）
        allLegendIds.forEach(cid => {
             if (hiddenFindIds.has(cid)) hiddenFindIds.delete(cid);
        });
    }

    if (typeof generateRollsTable === 'function') generateRollsTable();
    if (typeof updateMasterInfoView === 'function') updateMasterInfoView();
}

// ターゲット一括操作: 限定トグル
// 変更: 現在の状態を確認し、全て選択済みなら解除、それ以外なら全選択を行う
function toggleLimitedTargets() {
    const uniqueIds = [...new Set(tableGachaIds.map(idStr => {
        let id = idStr;
        if (id.endsWith('f') || id.endsWith('s') || id.endsWith('g')) id = id.slice(0, -1);
        return id;
    }))];

    const limitedSet = new Set();
    if (typeof limitedCats !== 'undefined' && Array.isArray(limitedCats)) {
        limitedCats.forEach(id => {
            limitedSet.add(id);
            limitedSet.add(String(id));
        });
    }

    // まず対象となるIDを全て収集
    let allLimitedIds = [];
    uniqueIds.forEach(id => {
        const config = gachaMasterData.gachas[id];
        if (!config) return;
        ['rare', 'super', 'uber'].forEach(r => {
            if (config.pool[r]) {
                config.pool[r].forEach(c => {
                    const cid = c.id;
                    const cStr = String(cid);
                    if (limitedSet.has(cid) || limitedSet.has(cStr)) {
                        allLimitedIds.push(cid);
                    }
                });
            }
        });
    });

    if (allLimitedIds.length === 0) return;

    // 現在全て選択されているかチェック
    const isAllSelected = allLimitedIds.every(cid => userTargetIds.has(cid));

    if (isAllSelected) {
        // 全て選択済み -> 全解除
        allLimitedIds.forEach(cid => userTargetIds.delete(cid));
    } else {
        // 未選択がある -> 全選択
        allLimitedIds.forEach(cid => userTargetIds.add(cid));
        // もしHiddenに入っていたら削除
        allLimitedIds.forEach(cid => {
             if (hiddenFindIds.has(cid)) hiddenFindIds.delete(cid);
             if (hiddenFindIds.has(String(cid))) hiddenFindIds.delete(String(cid));
        });
    }

    if (typeof generateRollsTable === 'function') generateRollsTable();
    if (typeof updateMasterInfoView === 'function') updateMasterInfoView();
}

====================
FILE: url_manager.js
====================
/** @file url_manager.js @description URLパラメータとアプリ状態の同期（保存・復元）を担当 @dependency ui_globals.js */

function processUrlParams() {
    const urlParams = new URLSearchParams(window.location.search);
    const seedParam = urlParams.get('seed');
    const simConfigParam = urlParams.get('sim_config');
    const gachasParam = urlParams.get('gachas');
    // uberAdditionCounts をリセット
    // ui_globals.js で定義された uberAdditionCounts を使用
    if (typeof uberAdditionCounts !== 'undefined') {
        uberAdditionCounts.length = 0;
        // 配列を空にする
    } else {
        // Fallback: ui_globals.js がまだ走っていない場合 (通常ありえないが)
        window.uberAdditionCounts = [];
    }

    if (gachasParam) {
        const parts = gachasParam.split('-');
        tableGachaIds = []; // reset
        
        parts.forEach((part, index) => {
            // "1006gadd5" 形式への対応
            if (part.includes('add')) {
                const subParts = part.split('add');
                const id = subParts[0];
                const addVal = parseInt(subParts[1], 10);
                
                tableGachaIds.push(id);
                // 追加数を保存
                if (!isNaN(addVal) && addVal > 0) {
                    
                    uberAdditionCounts[index] = addVal;
                } else {
                    uberAdditionCounts[index] = 0;
                }
            } else {
                tableGachaIds.push(part);
                uberAdditionCounts[index] = 0;
            }
        });
    }

    const seedEl = document.getElementById('seed');
    if (seedParam) {
        if(seedEl) seedEl.value = seedParam;
    } else {
        if(seedEl && !seedEl.value) seedEl.value = "12345";
    }

    // sim_config param の処理 (s-xxx or v-xxx)
    if (simConfigParam) {
        let rawConfig = simConfigParam;
        let mode = null;

        if (rawConfig.startsWith('s-')) {
            mode = 'sim';
            rawConfig = rawConfig.substring(2);
        } else if (rawConfig.startsWith('v-')) {
            mode = 'view';
            rawConfig = rawConfig.substring(2);
        } else {
            // 互換性: プレフィックスなしの場合はSimモードとみなす(既存動作維持)
            mode = 'sim';
        }

        const configEl = document.getElementById('sim-config');
        if(configEl) {
            // URLパラメータの + はスペースに置換済みだが、明示的に置換しておく
            configEl.value = rawConfig.replace(/\+/g, ' ');
        }
        
        if (mode === 'sim') {
            if(typeof isSimulationMode !== 'undefined') isSimulationMode = true;
        } else if (mode === 'view') {
            if(typeof isSimulationMode !== 'undefined') isSimulationMode = false;
        }
    }
}

function updateUrlParams() {
    const seed = document.getElementById('seed').value;
    const simConfig = document.getElementById('sim-config').value.trim();
    const urlParams = new URLSearchParams(window.location.search);

    if (seed) urlParams.set('seed', seed); else urlParams.delete('seed');
    
    // sim_config にプレフィックスを付与して保存
    if (simConfig) {
        const prefix = (typeof isSimulationMode !== 'undefined' && isSimulationMode) ? 's-' : 'v-';
        // スペースを + に変換するのはURLSearchParamsが自動で行うが、
        // 値としてセットする文字列自体はそのまま渡す
        urlParams.set('sim_config', prefix + simConfig);
    } else {
        urlParams.delete('sim_config');
    }
    
    // gachasパラメータの生成 (ID + "add" + Add数)
    if (tableGachaIds.length > 0) {
        const joined = tableGachaIds.map((id, index) => {
            const addVal = uberAdditionCounts[index];
            if (addVal && addVal > 0) {
                return `${id}add${addVal}`;
            }
            return id;
        }).join('-');
        urlParams.set('gachas', joined);
    } else {
        urlParams.delete('gachas');
    }

    const newUrl = `${window.location.pathname}?${urlParams.toString()}`;
    try { window.history.pushState({path: newUrl}, '', newUrl);
    } catch (e) { console.warn("URL update failed", e); }
}

====================
FILE: view_analysis.js
====================
/** @file view_analysis.js @description レア被り位置（黄色・オレンジ）のハイライト判定を担当 @dependency なし */

const RowAnalysis = {
    // 常設レア被り（黄色）: n+1とn+3のスロットが同じ
    isSimpleYellow: function(currIdx, seeds) {
        if (currIdx < 2) return false;
        const n = currIdx - 2; 
        if (n + 3 >= seeds.length) return false;
        // レア(7000未満)以外が含まれる場合は除外
        if (seeds[n] % 10000 > 6969 || seeds[n+2] % 10000 > 6969) return false;
        return (seeds[n+1] % 25) === (seeds[n+3] % 25);
    },

    // 波動バスターズ等レア被り（オレンジ）: n+1とn+3のスロットが逆順
    isSimpleOrange: function(currIdx, seeds) {
        if (currIdx < 2) return false;
        const n = currIdx - 2; 
        if (n + 3 >= seeds.length) return false;
        if (seeds[n] % 10000 > 6969 || seeds[n+2] % 10000 > 6969) return false;
        return (seeds[n+1] % 25) === (24 - (seeds[n+3] % 25));
    },

    // 連続被り判定（黄色）
    isConsecutiveYellow: function(currIdx, seeds) {
        if (currIdx < 5) return false;
        const n = currIdx - 5;
        if (currIdx + 1 >= seeds.length) return false;
        if (seeds[n] % 10000 > 6969) return false;
        if (seeds[n+2] % 10000 > 6969) return false;
        if (seeds[currIdx] % 10000 > 6969) return false;
        if (seeds[n+1] % 25 !== seeds[n+3] % 25) return false;
        return seeds[n+4] % 24 === seeds[currIdx+1] % 25;
    },

    // 連続被り判定（オレンジ）
    isConsecutiveOrange: function(currIdx, seeds) {
        if (currIdx < 5) return false;
        const n = currIdx - 5;
        if (currIdx + 1 >= seeds.length) return false;
        if (seeds[n] % 10000 > 6969) return false;
        if (seeds[n+2] % 10000 > 6969) return false;
        if (seeds[currIdx] % 10000 > 6969) return false;
        if (seeds[n+1] % 25 !== seeds[n+3] % 25) return false;
        return seeds[n+4] % 24 === (24 - (seeds[currIdx+1] % 25));
    }
};

====================
FILE: view_cell_renderer.js
====================
/** @file view_cell_renderer.js @description テーブル内の個別のセル（通常・確定枠・計算列）のHTML生成を担当 @dependency logic.js, view_analysis.js */

// アドレスフォーマット (例: 1A, 2B)
function formatAddress(idx) {
    if (idx === null || idx === undefined) return '';
    const row = Math.floor(idx / 2) + 1;
    const side = (idx % 2 === 0) ? 'A' : 'B';
    return `${side}${row})`;
}

// 左側の詳細計算列 (SEED, Rarity, Slotなど) を生成
function generateDetailedCalcCells(seedIndex, seeds, tableData) {
    const calcColClass = `calc-column ${showSeedColumns ? '' : 'hidden'}`;
    if (!showSeedColumns) return `<td class="${calcColClass}"></td>`.repeat(5);
    
    const firstGachaIdWithSuffix = tableGachaIds[0];
    if (!firstGachaIdWithSuffix) return `<td class="${calcColClass}">N/A</td>`.repeat(5);
    let firstId = firstGachaIdWithSuffix.replace(/[gfs]$/, '');
    const originalConfig = gachaMasterData.gachas[firstId];
    if(!originalConfig) return `<td class="${calcColClass}">N/A</td>`.repeat(5);

    const config = { ...originalConfig };
    config.pool = { ...originalConfig.pool };
    if (config.pool.uber) {
        config.pool.uber = [...config.pool.uber];
        const addCount = uberAdditionCounts[0] || 0;
        if (addCount > 0) {
            for (let k = 1; k <= addCount; k++) config.pool.uber.unshift({ id: `sim-new-${k}`, name: `新規超激${k}`, rarity: 'uber' });
        }
    }

    if (seedIndex + 10 >= seeds.length) return `<td class="${calcColClass}">End</td>`.repeat(5);
    const sNum1 = seedIndex + 1;
    const sNum2 = seedIndex + 2;
    const sVal_0 = seeds[seedIndex];
    const sVal_1 = seeds[seedIndex+1];
    const colSeed = `<td>(S${sNum1})<br>${sVal_0}</td>`;

    const rVal = sVal_0 % 10000;
    const rates = config.rarity_rates || {};
    const rareRate = rates.rare || 0, superRate = rates.super || 0, uberRate = rates.uber || 0, legendRate = rates.legend || 0;
    let rType = 'rare';
    if (rVal < rareRate) rType = 'rare';
    else if (rVal < rareRate + superRate) rType = 'super';
    else if (rVal < rareRate + superRate + uberRate) rType = 'uber';
    else if (rVal < rareRate + superRate + uberRate + legendRate) rType = 'legend';
    
    const colRarity = `<td>(S${sNum1})<br>${rVal}<br>(${rType})</td>`;
    const pool = config.pool[rType] || [];
    let colSlot = '<td>-</td>';
    let slotVal = '-';
    if (pool.length > 0) {
        slotVal = sVal_1 % pool.length;
        colSlot = `<td>(S${sNum2})<br>%${pool.length}<br>${slotVal}</td>`;
    }

    let colReRoll = '<td>-</td>';
    if (tableData[seedIndex] && tableData[seedIndex][0] && tableData[seedIndex][0].roll) {
        const roll = tableData[seedIndex][0].roll;
        if (pool.length > 0) {
            if (roll.isRerolled) {
                const finalPoolSize = roll.uniqueTotal;
                const finalVal = roll.reRollIndex;
                const finalSeedIndex = seedIndex + roll.seedsConsumed - 1;
                const sNumFinal = finalSeedIndex + 1;
                colReRoll = `<td>(S${sNumFinal})<br>%${finalPoolSize}<br>${finalVal}</td>`;
            } else {
                colReRoll = `<td>false</td>`;
            }
        }
    }

    let tempSeedIdx = seedIndex;
    let tempDraw = null;
    let validSim = true;
    for(let k=0; k<10; k++) {
        if (tempSeedIdx + 1 >= seeds.length) { validSim = false; break; }
        const rr = rollWithSeedConsumptionFixed(tempSeedIdx, config, seeds, tempDraw);
        if (rr.seedsConsumed === 0) { validSim = false; break; }
        tempSeedIdx += rr.seedsConsumed;
        tempDraw = { rarity: rr.rarity, charId: rr.charId };
    }
    let colGuar = '<td>-</td>';
    if (validSim && tempSeedIdx < seeds.length) {
        const uberPool = config.pool['uber'] || [];
        if (uberPool.length > 0) {
            const guarSeedVal = seeds[tempSeedIdx];
            const guarSlot = guarSeedVal % uberPool.length;
            const sNumGuar = tempSeedIdx + 1;
            colGuar = `<td>(S${sNumGuar})<br>%${uberPool.length}<br>${guarSlot}</td>`;
        }
    }
    return colSeed + colRarity + colSlot + colReRoll + colGuar;
}

// ガチャ結果セル (キャラ名、色分け、リンク等) を生成
function generateCell(seedIndex, id, colIndex, tableData, seeds, highlightMap, isSimulationMode) {
    if(!tableData[seedIndex] || !tableData[seedIndex][colIndex]) return `<td class="gacha-cell gacha-column">N/A</td>`;
    const fullRoll = tableData[seedIndex][colIndex].roll;
    if(!fullRoll) return `<td>N/A</td>`;
    
    const gachaConfig = gachaMasterData.gachas[id];
    const gachaName = gachaConfig ? gachaConfig.name : "";
    const isPlatOrLegend = gachaName.includes("プラチナ") || gachaName.includes("レジェンド");
    
    const charId = fullRoll.finalChar.id;
    const charIdStr = String(charId);

    // --- 限定キャラ判定 ---
    let isLimited = false;
    if (typeof limitedCats !== 'undefined' && Array.isArray(limitedCats)) {
        if (limitedCats.includes(parseInt(charId)) || limitedCats.includes(charIdStr)) {
            isLimited = true;
        }
    }

    // --- Findターゲット判定 ---
    const isAuto = isAutomaticTarget(charId);
    const isHidden = hiddenFindIds.has(charId) || (typeof charId === 'number' && hiddenFindIds.has(charId)) || hiddenFindIds.has(charIdStr);
    const isManual = userTargetIds.has(charId) || (typeof charId === 'number' && userTargetIds.has(charId));
    const isFindTarget = (isAuto && !isHidden) || isManual;

    let hlClass = '';
    let isSimRoute = false;
    let style = '';

    if (isSimulationMode) {
        if (highlightMap.get(seedIndex) === id) {
            isSimRoute = true;
            // 修正：Findターゲット、限定、伝説、超激レアがルート上にある場合は「青ハイライト＋太字赤字」
            if (isLimited || fullRoll.rarity === 'uber' || fullRoll.rarity === 'legend' || isFindTarget) {
                style = 'background-color: #32CD32;'; // view_table.jsで青色(COLOR_ROUTE_UBER)に置換
                hlClass = ' highlight highlight-uber'; // 太字・赤字クラス
            } else {
                style = 'background-color: #98FB98;'; // view_table.jsで水色(COLOR_ROUTE_HIGHLIGHT)に置換
                hlClass = ' highlight';
            }
        }
    }

    // Simルート外、またはSimモードOFFの場合の通常着色
    if (!isSimRoute) {
        if (isFindTarget) {
            style = 'background-color: #adff2f; font-weight: bold;';
        } else if (isLimited) {
            style = 'background-color: #66FFFF;';
        } else if (isPlatOrLegend) {
            style = '';
        } else {
            const sv = seeds[seedIndex] % 10000;
            if(sv >= 9970) style = 'background-color: #DDA0DD;';
            else if(sv >= 9940) style = 'background-color: #de59de;';
            else if(sv >= 9500) style = 'background-color: #FF4C4C;';
            else if(sv >= 9100) style = 'background-color: #FFB6C1;';
            else if(sv >= 6970) style = 'background-color: #ffff33;';
            else if(sv >= 6470) style = 'background-color: #FFFFcc;';
        }
    }

    // クリックイベント
    const charNameForCopy = fullRoll.finalChar.name.replace(/'/g, "\\'");
    const clickHandler = `onclick="onGachaCellClick(${seedIndex}, '${id}', '${charNameForCopy}')"`;
    style += ' cursor: pointer;';

    let content = fullRoll.finalChar.name;
    if (!isSimulationMode) {
        if (fullRoll.isRerolled) {
            const s2Val = (seedIndex + 1 < seeds.length) ? seeds[seedIndex + 1] : null;
            const s3Val = (seedIndex + 2 < seeds.length) ? seeds[seedIndex + 2] : null;
            const originalName = fullRoll.originalChar.name;
            const finalName = fullRoll.finalChar.name;
            let originalHtml = originalName;
            if (s2Val !== null) originalHtml = `<span class="char-link" style="cursor:pointer;" onclick="event.stopPropagation(); updateSeedAndRefresh(${s2Val})">${originalName}</span>`;
            let finalHtml = finalName;
            if (s3Val !== null) finalHtml = `<span class="char-link" style="cursor:pointer;" onclick="event.stopPropagation(); updateSeedAndRefresh(${s3Val})">${finalName}</span>`;
            const nextSeedIdx = seedIndex + fullRoll.seedsConsumed;
            let addr = formatAddress(nextSeedIdx);
            if (fullRoll.isForceDuplicate) addr = 'R' + addr;
            content = `${originalHtml}<br><span style="font-size:0.9em; color:#666;">${addr}</span>${finalHtml}`;
        } else {
            const slotSeedVal = (seedIndex + 1 < seeds.length) ? seeds[seedIndex + 1] : null;
            if(slotSeedVal !== null) content = `<span class="char-link" style="cursor:pointer;" onclick="event.stopPropagation(); updateSeedAndRefresh(${slotSeedVal})">${content}</span>`;
        }
    } else {
        if (fullRoll.isRerolled) {
            const nextSeedIdx = seedIndex + fullRoll.seedsConsumed;
            let addr = formatAddress(nextSeedIdx);
            if (fullRoll.isForceDuplicate) addr = 'R' + addr;
            content = `${fullRoll.originalChar.name}<br><span style="font-size:0.9em; color:#666;">${addr}</span>${fullRoll.finalChar.name}`;
        }
    }
    
    return `<td class="gacha-cell gacha-column${hlClass}" style="${style}" ${clickHandler}>${content}</td>`;
}

====================
FILE: view_forecast.js
====================
/** @file view_forecast.js @description Find（高速予報）エリアおよび操作ボタンのHTML生成を担当 @dependency logic.js, ui_target_handler.js */

function generateFastForecast(initialSeed, columnConfigs) {
    const scanRows = 2000;
    const extendedScanRows = 10000; // 2000件で見つからない場合の最大検索範囲
    const requiredSeeds = extendedScanRows * 2 + 10;
    const seeds = new Uint32Array(requiredSeeds);
    const rng = new Xorshift32(initialSeed);
    for (let i = 0; i < requiredSeeds; i++) {
        seeds[i] = rng.next();
    }

    const visibilityClass = (typeof showFindInfo !== 'undefined' && showFindInfo) ? '' : 'hidden';
    let summaryHtml = `<div id="forecast-summary-area" class="forecast-summary-container ${visibilityClass}" style="margin-bottom: 0; padding: 10px; background: #fdfdfd; border: 1px solid #ddd; border-bottom: none; border-radius: 4px 4px 0 0;">`;

    const legendSlots = [];
    const promotedSlots = []; 
    // 伝説・昇格枠の予報は2000件固定
    for (let n = 0; n < scanRows * 2; n++) {
        const val = seeds[n] % 10000;
        const row = Math.floor(n / 2) + 1;
        const side = (n % 2 === 0) ? 'A' : 'B';
        const addr = `${row}${side}`; 
        if (val >= 9970) {
            legendSlots.push(addr);
        } else if (val >= 9940) {
            promotedSlots.push(addr);
        }
    }

    const legendStr = legendSlots.length > 0 ? legendSlots.join(", ") : "なし";
    const promotedStr = promotedSlots.length > 0 ? promotedSlots.join(", ") : "なし";

    summaryHtml += `
        <div style="margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px dashed #eee; font-size: 0.85em;">
            <div style="margin-bottom: 4px;">
                <span style="font-weight:bold; color:#e91e63; background:#ffe0eb; padding:1px 4px; border-radius:3px;">伝説枠</span>
                <span style="font-family: monospace; margin-left: 5px;">${legendStr}</span>
            </div>
            <div>
                <span style="font-weight:bold; color:#9c27b0; background:#f3e5f5; padding:1px 4px; border-radius:3px;">昇格枠</span>
                <span style="font-family: monospace; margin-left: 5px;">${promotedStr}</span>
            </div>
        </div>
    `;

    const processedGachaIdsForBtn = new Set();
    let availableLegendIds = [];
    let availableLimitedIds = [];
    const limitedSet = new Set();
    if (typeof limitedCats !== 'undefined' && Array.isArray(limitedCats)) {
        limitedCats.forEach(id => { limitedSet.add(id); limitedSet.add(String(id)); });
    }

    columnConfigs.forEach((config) => {
        if (!config || processedGachaIdsForBtn.has(config.id)) return;
        processedGachaIdsForBtn.add(config.id);

        if (config.pool.legend) {
            config.pool.legend.forEach(c => availableLegendIds.push(c.id));
        }
        ['rare', 'super', 'uber'].forEach(r => {
            if (config.pool[r]) {
                config.pool[r].forEach(c => {
                    if (limitedSet.has(c.id) || limitedSet.has(String(c.id))) {
                        availableLimitedIds.push(c.id);
                    }
                });
            }
        });
    });

    const isLegendActive = (availableLegendIds.length > 0) && availableLegendIds.every(cid => userTargetIds.has(cid));
    const isLimitedActive = (availableLimitedIds.length > 0) && availableLimitedIds.every(cid => userTargetIds.has(cid));
    const isMasterActive = (typeof isMasterInfoVisible !== 'undefined') ? isMasterInfoVisible : true;

    const legendBtnClass = isLegendActive ? 'text-btn active' : 'text-btn';
    const limitedBtnClass = isLimitedActive ? 'text-btn active' : 'text-btn';
    const masterBtnClass = isMasterActive ? 'text-btn active' : 'text-btn';

    summaryHtml += `
        <div style="margin-bottom: 10px; text-align: left;">
            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                <span onclick="clearAllTargets()" class="text-btn" title="全て非表示">×</span>
                <span class="separator">|</span>
                <span onclick="toggleLegendTargets()" class="${legendBtnClass}">伝説</span>
                <span class="separator">|</span>
                <span onclick="toggleLimitedTargets()" class="${limitedBtnClass}">限定</span>
                <span class="separator">|</span>
                <span id="toggle-master-info-btn" onclick="toggleMasterInfo()" class="${masterBtnClass}">マスター</span>
                <span style="font-size: 0.8em; color: #666; margin-left: auto;">Target List</span>
            </div>
            <div style="font-size: 0.75em; color: #666; padding-left: 2px;">
                ※マスターリスト内のキャラ名をタップ（クリック）すると、そのキャラを「Find」ターゲットとして登録/解除できます。
            </div>
        </div>
    `;

    const processedGachaIds = new Set();
    const anniversarySet = new Set();
    if (typeof AnniversaryLimited !== 'undefined' && Array.isArray(AnniversaryLimited)) {
        AnniversaryLimited.forEach(id => { anniversarySet.add(id); anniversarySet.add(String(id)); });
    }

    columnConfigs.forEach((config) => {
        if (!config || processedGachaIds.has(config.id)) return;
        processedGachaIds.add(config.id);

        const targetIds = new Set();
        const poolsToCheck = { legend: false, rare: false, super: false, uber: false };

        ['legend', 'rare', 'super', 'uber'].forEach(r => {
            if (config.pool[r] && config.pool[r].length > 0) {
                config.pool[r].forEach(charObj => {
                    const cid = charObj.id;
                    const idStr = String(cid);
                    const isAuto = idStr.startsWith('sim-new-');
                    const isHidden = hiddenFindIds.has(cid) || hiddenFindIds.has(idStr);
                    const isManual = userTargetIds.has(cid) || userTargetIds.has(parseInt(cid));

                    if ((isAuto && !isHidden) || isManual) {
                        targetIds.add(cid);
                        poolsToCheck[r] = true;
                    }
                });
            }
        });

        if (targetIds.size === 0) return;

        const resultMap = new Map();
        const missingTargets = new Set(targetIds); 

        // 1. 通常検索（0-2000件）
        for (let n = 0; n < scanRows * 2; n++) {
            const s0 = seeds[n];
            const rVal = s0 % 10000;
            const rates = config.rarity_rates;
            let rarity = 'rare'; 
            if (rVal < rates.rare) rarity = 'rare';
            else if (rVal < rates.rare + rates.super) rarity = 'super';
            else if (rVal < rates.rare + rates.super + rates.uber) rarity = 'uber';
            else if (rVal < rates.rare + rates.super + rates.uber + rates.legend) rarity = 'legend';

            if (poolsToCheck[rarity]) {
                const targetPool = config.pool[rarity];
                const s1 = seeds[n + 1];
                const slot = s1 % targetPool.length;
                const charObj = targetPool[slot];
                const cid = charObj.id;
                
                if (targetIds.has(cid)) {
                    if (!resultMap.has(cid)) {
                        resultMap.set(cid, { 
                            name: charObj.name, hits: [], isLegend: (rarity === 'legend'), 
                            isNew: String(cid).startsWith('sim-new-'),
                            isLimited: limitedSet.has(cid) || limitedSet.has(String(cid)),
                            isAnniversary: anniversarySet.has(cid) || anniversarySet.has(String(cid))
                        });
                        missingTargets.delete(cid); 
                    }
                    const row = Math.floor(n / 2) + 1;
                    const side = (n % 2 === 0) ? 'A' : 'B';
                    resultMap.get(cid).hits.push(`${row}${side}`);
                }
            }
        }

        // 2. 延長検索（2000件で見つかっていないターゲットを最大1万件まで探す）
        if (missingTargets.size > 0) {
            for (let n = scanRows * 2; n < extendedScanRows * 2; n++) {
                if (missingTargets.size === 0) break;

                const s0 = seeds[n];
                const rVal = s0 % 10000;
                const rates = config.rarity_rates;
                let rarity = 'rare'; 
                if (rVal < rates.rare) rarity = 'rare';
                else if (rVal < rates.rare + rates.super) rarity = 'super';
                else if (rVal < rates.rare + rates.super + rates.uber) rarity = 'uber';
                else if (rVal < rates.rare + rates.super + rates.uber + rates.legend) rarity = 'legend';

                if (poolsToCheck[rarity]) {
                    const targetPool = config.pool[rarity];
                    const s1 = seeds[n + 1];
                    const slot = s1 % targetPool.length;
                    const charObj = targetPool[slot];
                    const cid = charObj.id;

                    if (missingTargets.has(cid)) {
                        resultMap.set(cid, { 
                            name: charObj.name, hits: [], isLegend: (rarity === 'legend'), 
                            isNew: String(cid).startsWith('sim-new-'),
                            isLimited: limitedSet.has(cid) || limitedSet.has(String(cid)),
                            isAnniversary: anniversarySet.has(cid) || anniversarySet.has(String(cid)),
                            isExtended: true 
                        });
                        const row = Math.floor(n / 2) + 1;
                        const side = (n % 2 === 0) ? 'A' : 'B';
                        resultMap.get(cid).hits.push(`${row}${side}`);
                        missingTargets.delete(cid);
                    }
                }
            }
        }

        if (resultMap.size === 0) return;

        let listItems = [];
        resultMap.forEach((data, id) => {
            data.id = id;
            listItems.push(data);
        });

        listItems.sort((a, b) => {
            const getPriority = (item) => {
                if (item.isNew) return 1;
                if (item.isLegend && item.isLimited) return 2;
                if (item.isLegend) return 3;
                if (item.isAnniversary) return 4;
                if (item.isLimited) return 5;
                return 6; 
            };
            const pA = getPriority(a);
            const pB = getPriority(b);
            if (pA !== pB) return pA - pB;
            if (pA === 1) {
                const nA = parseInt(String(a.id).replace('sim-new-', ''), 10);
                const nB = parseInt(String(b.id).replace('sim-new-', ''), 10);
                return nB - nA;
            }
            if (pA >= 2 && pA <= 5) return parseInt(b.id) - parseInt(a.id);
            const firstHitA = parseInt(a.hits[0]);
            const firstHitB = parseInt(b.hits[0]);
            return firstHitA - firstHitB;
        });

        const itemHtmls = listItems.map(data => {
            let nameStyle = 'font-weight:bold; font-size: 0.9em;'; 
            if (data.isNew) nameStyle += ' color:#007bff;'; 
            else if (data.isLegend) nameStyle += ' color:#e91e63;'; 
            else if (data.isLimited) nameStyle += ' color:#d35400;'; 
            else nameStyle += ' color:#333;'; 

            const hitLinks = data.hits.map(addr => {
                const row = parseInt(addr);
                const side = addr.endsWith('B') ? 1 : 0;
                const sIdx = (row - 1) * 2 + side;
                const escapedName = data.name.replace(/'/g, "\\'");
                
                // --- 変更箇所: 2000番を超える場合はリンクにせずテキストのみにする ---
                if (row > 2000) {
                    return `<span style="margin-right:4px; color: #999; font-size: 0.9em;">${addr}</span>`;
                } else {
                    return `<span class="char-link" style="cursor:pointer; text-decoration:underline; margin-right:4px;" 
                                 onclick="onGachaCellClick(${sIdx}, '${config.id}', '${escapedName}', null, true, '${data.id}')">${addr}</span>`;
                }
            }).join("");

            const closeBtn = `<span onclick="toggleCharVisibility('${data.id}')" style="cursor:pointer; margin-right:6px; color:#999; font-weight:bold; font-size:1em;" title="非表示にする">×</span>`;
            return `<div style="margin-bottom: 2px; line-height: 1.3;">${closeBtn}<span style="${nameStyle}">${data.name}</span>: <span style="font-size: 0.85em; color: #555;">${hitLinks}</span></div>`;
        });

        summaryHtml += `<div style="margin-bottom: 8px;">
            <div style="font-weight: bold; background: #eee; padding: 2px 5px; margin-bottom: 3px; font-size: 0.85em;">
                ${config.name} (ID:${config.id})
            </div>
            <div style="font-family: monospace; font-size: 1em;">
                ${itemHtmls.join('')}
            </div>
        </div>`;
    });

    summaryHtml += '</div>';
    return summaryHtml;
}

====================
FILE: view_header.js
====================
/** @file view_header.js @description テーブルヘッダー（固定行・操作行）のHTML生成を担当 @dependency gacha_selector.js */

// 変更: 名前行（固定表示）のHTMLを生成
function generateNameHeaderHTML() {
    let html = ``;
    
    // index引数を追加して、uberAdditionCountsにアクセスできるように変更
    tableGachaIds.forEach((idWithSuffix, index) => {
        let id = idWithSuffix;
        let suffix = '';
        if (idWithSuffix.endsWith('f')) { suffix = 'f'; id = idWithSuffix.slice(0, -1); }
        else if (idWithSuffix.endsWith('s')) { suffix = 's'; id = idWithSuffix.slice(0, -1); }
        else if (idWithSuffix.endsWith('g')) { suffix = 'g'; id = idWithSuffix.slice(0, -1); }

        const isGuaranteed = (suffix !== '');
        const gachaConfig = gachaMasterData.gachas[id];
        if (!gachaConfig) return;
        
        let selectedLabel = `${id} ${gachaConfig.name}`;
        const options = getGachaSelectorOptions(id);
        const foundOption = options.find(o => o.value == id);
        if (foundOption) selectedLabel = foundOption.label;

        // --- 追加: add情報の表示文字列を作成 ---
        const addCount = uberAdditionCounts[index] || 0;
        let addInfoStr = '';
        if (addCount > 0) {
            // 赤字で目立たせて表示 (例: add:1)
            addInfoStr = ` <span style="font-size:0.85em; color:#d9534f; font-weight:normal;">(add:${addCount})</span>`;
        }
        // ---------------------------------------

        let displayHTML = "";
        const firstSpaceIdx = selectedLabel.indexOf(' ');
    
        if (firstSpaceIdx !== -1) {
            const part1 = selectedLabel.substring(0, firstSpaceIdx);
            const part2 = selectedLabel.substring(firstSpaceIdx + 1);
            // ガチャ名の後ろにadd情報を付与
            displayHTML = `<span style="font-size:0.85em; color:#333;">${part1}</span><br><span style="font-weight:bold; font-size:0.95em;">${part2}${addInfoStr}</span>`;
        } else {
            displayHTML = `${selectedLabel}${addInfoStr}`;
        }

        const cls = isGuaranteed ? '' : 'class="gacha-column"';
        // 名前行なので ControlArea は出力しない
        html += `<th ${cls} ${isGuaranteed?'colspan="2"':''} style="vertical-align: bottom; padding-bottom: 2px;">
                    <div style="text-align: center; line-height: 1.25;">${displayHTML}</div>
                 </th>`;
    });
    return html;
}

// 変更: 操作ボタン行（スクロールと一緒に流れる）のHTMLを生成
function generateControlHeaderHTML(isInteractive) {
    let html = ``;

    tableGachaIds.forEach((idWithSuffix, index) => {
        let id = idWithSuffix;
        let suffix = '';
        if (idWithSuffix.endsWith('f')) { suffix = 'f'; id = idWithSuffix.slice(0, -1); }
        else if (idWithSuffix.endsWith('s')) { suffix = 's'; id = idWithSuffix.slice(0, -1); }
        else if (idWithSuffix.endsWith('g')) { suffix = 'g'; id = idWithSuffix.slice(0, -1); }

        const isGuaranteed = (suffix !== '');
        
        let selectorArea = '';
        let controlArea = '';

        if (isInteractive) {
            const removeBtn = `<button class="remove-btn" onclick="removeGachaColumn(${index})" style="font-size:11px; padding:2px 6px; margin-left: 5px;">x</button>`;
            let gBtnLabel = 'G';
            if (suffix === 'g') gBtnLabel = '11G';
            else if (suffix === 'f') gBtnLabel = '15G';
            else if (suffix === 's') gBtnLabel = '7G';
            
            const gBtn = `<button onclick="toggleGuaranteedColumn(${index})" style="min-width:25px; font-size:11px; padding:2px 6px;">${gBtnLabel}</button>`;
            const currentAddVal = uberAdditionCounts[index] || 0;
            const addLabelText = (currentAddVal > 0) ? `add:${currentAddVal}` : `add`;
            const triggerHtml = `<span id="add-trigger-${index}" style="font-size:12px; color:#007bff; cursor:pointer; text-decoration:underline;" onclick="showAddInput(${index})">${addLabelText}</span>`;
            
            let addSelect = `<span id="add-select-wrapper-${index}" style="display:none;">`;
            addSelect += `<select class="uber-add-select" onchange="updateUberAddition(this, ${index})" style="width: 40px; margin: 0 2px; padding: 0; font-size: 0.85em;">`;
            for(let k=0; k<=19; k++){
                addSelect += `<option value="${k}" ${k===currentAddVal ? 'selected':''}>${k}</option>`;
            }
            addSelect += `</select></span>`;
            
            // セレクター（透明）の再構築
            const options = getGachaSelectorOptions(id);
            let selector = `<select onchange="updateGachaSelection(this, ${index})" style="width: 30px; cursor: pointer; opacity: 0; position: absolute; left:0; top:0; height: 100%; width: 100%;">`;
            options.forEach(opt => {
                const selected = (opt.value == id) ? 'selected' : '';
                selector += `<option value="${opt.value}" ${selected}>${opt.label}</option>`;
            });
            selector += '</select>';
            
            const fakeSelectBtn = `<div style="width:20px; height:20px; background:#ddd; border:1px solid #999; display:flex; align-items:center; justify-content:center; border-radius:3px; font-size:10px;">▼</div>`;
            selectorArea = `<div style="position: relative; width: 20px; height: 20px;">${fakeSelectBtn}${selector}</div>`;
            
            controlArea = `<div style="display:flex; justify-content:center; align-items:center; gap:3px;">${selectorArea}${gBtn}${triggerHtml}${addSelect}${removeBtn}</div>`;
        } else {
            // Interactiveでない場合（A, Bの表示のみの箇所など）
             controlArea = `<div style="height: 20px;"></div>`;
        }
        
        const cls = isGuaranteed ? '' : 'class="gacha-column"';
        html += `<th ${cls} ${isGuaranteed?'colspan="2"':''} style="vertical-align: top; padding-top: 2px;">
                    ${controlArea}
                 </th>`;
    });
    return html;
}

====================
FILE: view_master.js
====================
/** @file view_master.js @description ガチャマスタ（キャラリスト）の詳細情報のHTML生成を担当 @dependency data_loader.js */

function generateMasterInfoHtml() {
    if (!gachaMasterData || !gachaMasterData.gachas) return '<p>データがありません</p>';
    
    // 現在選択中のユニークなガチャIDを抽出
    const uniqueIds = [...new Set(tableGachaIds.map(idStr => {
        let id = idStr;
        if (id.endsWith('f') || id.endsWith('s') || id.endsWith('g')) {
            id = id.slice(0, -1);
        }
        return id;
    }))];
    
    if (uniqueIds.length === 0) return '<p>ガチャが選択されていません</p>';

    // --- Findターゲット判定用のセットを準備 ---
    const limitedSet = new Set();
    if (typeof limitedCats !== 'undefined' && Array.isArray(limitedCats)) {
        limitedCats.forEach(id => {
            limitedSet.add(id);
            limitedSet.add(String(id));
        });
    }

    let html = '';
    uniqueIds.forEach(id => {
        const config = gachaMasterData.gachas[id];
        if (!config) return;

        // 超激レア追加設定があればプールを一時的に拡張
        const configClone = { ...config, pool: { ...config.pool } };
        if (configClone.pool.uber) configClone.pool.uber = [...configClone.pool.uber];

        const colIndex = tableGachaIds.findIndex(tid => tid.startsWith(id));
        const addCount = (colIndex >= 0 && uberAdditionCounts[colIndex]) ? uberAdditionCounts[colIndex] : 0;
        
        if (addCount > 0 && configClone.pool.uber) {
            for (let k = 1; k <= addCount; k++) {
                configClone.pool.uber.unshift({
                    id: `sim-new-${k}`,
                    name: `新規超激${k}`,
                    rarity: 'uber'
                });
            }
        }

        html += `<div style="margin-bottom: 15px; border-bottom: 1px solid #ccc; padding-bottom: 10px;">`;
        html += `<h4 style="margin: 0 0 5px 0;">${config.name} (ID: ${id})</h4>`;

        const rates = configClone.rarity_rates || {};
        const pool = configClone.pool || {};

        const rarities = [
            { key: 'legend', label: 'Legendary' },
            { key: 'uber', label: 'Uber' },
            { key: 'super', label: 'Super' },
            { key: 'rare', label: 'Rare' }
        ];

        rarities.forEach(r => {
            const rateVal = rates[r.key] || 0;
            const rateStr = (rateVal / 100) + '%';
            const charList = pool[r.key] || [];
            const count = charList.length;

            if (count === 0 && rateVal === 0) return;

            // キャラリスト生成
            const listStr = charList.map((c, idx) => {
                const cid = c.id;
                const cStr = String(cid);
                
                // --- Findターゲット判定 (自動) ---
                const isLegendRank = (r.key === 'legend');
                const isLimited = limitedSet.has(cid) || limitedSet.has(cStr);
                const isNew = cStr.startsWith('sim-new-');
                const isAuto = isAutomaticTarget(cid);

                // --- 状態チェック ---
                const isHidden = hiddenFindIds.has(cid) || (typeof cid === 'number' && hiddenFindIds.has(cid));
                const isManual = userTargetIds.has(cid) || (typeof cid === 'number' && userTargetIds.has(cid));

                // ハイライト条件:
                // 1. 自動ターゲット かつ 非表示でない
                // 2. 手動ターゲットである
                const shouldHighlight = (isAuto && !isHidden) || isManual;

                let style = '';
                if (shouldHighlight) {
                    style = 'background-color: #ffffcc; border: 1px solid #ff9800; padding: 1px 3px; border-radius: 3px; font-weight: bold;';
                }
                // 修正: 非表示状態（自動ターゲットだがisHidden=true）の場合でも、特別なスタイル（グレーアウト・取り消し線）を適用しない
                // else if (isAuto && isHidden) { ... } を削除

                // タイトル属性でアクションを示唆
                const titleText = shouldHighlight ? '非表示にする' : 'Findに追加する';

                return `<span style="cursor:pointer; ${style}" onclick="toggleCharVisibility('${cid}')" title="${titleText}">${idx}&nbsp;${c.name}</span>`;
            }).join(', ');

            html += `<div style="margin-bottom: 3px;">`;
            html += `<strong>${r.label}:</strong> ${rateStr} (${count} cats) `;
            html += `<span style="color: #555; line-height: 1.6;">${listStr}</span>`;
            html += `</div>`;
        });

        html += `</div>`;
    });

    return html;
}

====================
FILE: view_schedule_editor.js
====================
/** @file view_schedule_editor.js @description スケジュール予定の編集用UIレンダリング */

/**
 * 編集モードのテーブルを描画する
 */
function renderScheduleEditor(tsvContent, containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;

    const data = parseGachaTSV(tsvContent);

    let html = `
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; flex-wrap: wrap; gap: 10px;">
            <h3 style="margin:0;">スケジュール編集モード</h3>
            <div style="display: flex; gap: 5px;">
                <button onclick="toggleImportArea()" class="secondary" style="padding: 5px 10px;">テキストから読み取り</button>
                <button onclick="addNewScheduleRow()" class="add-gacha-btn" style="padding: 5px 10px;">＋ 予定を追加</button>
                <button onclick="applyScheduleTemporarily()" style="background-color: #007bff; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 11px;">一時反映</button>
                <button onclick="generateAndDownloadTSV()" style="background-color: #28a745; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-size: 11px;">TSV保存 (DL)</button>
                <button onclick="toggleSchedule()" class="secondary" style="padding: 5px 10px;">キャンセル</button>
            </div>
        </div>

        <div id="import-area" style="display:none; background: #f8f9fa; padding: 10px; border: 1px solid #ccc; border-radius: 4px; margin-bottom: 10px;">
            <p style="margin: 0 0 5px 0; font-size: 0.8em; font-weight: bold;">解析テキストをここに貼り付けてください:</p>
            <textarea id="import-text-input" style="width: 100%; height: 80px; font-size: 10px; font-family: monospace;" placeholder="[12月 25日 ~ 29日] クリスマスギャルズ ..."></textarea>
            <div style="text-align: right; margin-top: 5px;">
                <button onclick="processTextImport()" style="background-color: #17a2b8; color: white; font-size: 11px;">解析して追加</button>
                <button onclick="toggleImportArea()" style="font-size: 11px;" class="secondary">閉じる</button>
            </div>
        </div>

        <div style="background: #fff3cd; color: #856404; padding: 8px; border-radius: 4px; font-size: 0.8em; margin-bottom: 10px; border: 1px solid #ffeeba;">
            ※カレンダーと時刻(時)を選択して編集してください。保存時に分は自動補完されます（開始:00分、終了:59分）。
        </div>
        <div class="schedule-scroll-wrapper">
        <table class="schedule-table" id="schedule-editor-table" style="font-size: 11px;">
            <thead>
                <tr>
                    <th style="min-width:120px;">開始日 / 時</th>
                    <th style="min-width:120px;">終了日 / 時</th>
                    <th style="min-width:100px;">ID / ガチャ名選択</th>
                    <th>ガチャ詳細(TSV表示名)</th>
                    <th style="min-width:45px;">超激%</th>
                    <th style="min-width:45px;">伝説%</th>
                    <th style="min-width:30px;">確定</th>
                    <th style="min-width:30px;">操作</th>
                </tr>
            </thead>
            <tbody>
    `;

    data.forEach((item) => {
        html += createEditorRowHtml(item);
    });

    html += `</tbody></table></div>`;
    container.innerHTML = html;
}

/**
 * インポートエリアの表示・非表示切り替え
 */
function toggleImportArea() {
    const area = document.getElementById('import-area');
    if (area) {
        area.style.display = (area.style.display === 'none') ? 'block' : 'none';
    }
}

/**
 * 行のHTML生成ヘルパー
 */
function createEditorRowHtml(item = null) {
    let d;
    if (item) {
        d = item;
    } else {
        // デフォルト値
        const now = new Date();
        const y = now.getFullYear();
        const m = String(now.getMonth() + 1).padStart(2, '0');
        const day = String(now.getDate()).padStart(2, '0');
        const aft = new Date();
        aft.setDate(now.getDate() + 2);
        const ay = aft.getFullYear();
        const am = String(aft.getMonth() + 1).padStart(2, '0');
        const ad = String(aft.getDate()).padStart(2, '0');

        let defaultId = "0";
        let defaultName = "新規予定";
        if (typeof getGachaSelectorOptions === 'function') {
            const options = getGachaSelectorOptions();
            const targetGacha = options.find(opt => opt.label.includes("ネコルガ族"));
            if (targetGacha) {
                defaultId = targetGacha.value;
                const match = targetGacha.label.match(/\)\s*(.+)$/);
                defaultName = match ? match[1].replace(/\[確定\]$/, "").trim() : targetGacha.label;
            }
        }

        d = {
            rawStart: `${y}${m}${day}`, startTime: "1100", 
            rawEnd: `${ay}${am}${ad}`, endTime: "1059",
            id: defaultId, tsvName: defaultName,
            uber: "500", legend: "30", guaranteed: false
        };
    }

    const isoStart = `${d.rawStart.substring(0,4)}-${d.rawStart.substring(4,6)}-${d.rawStart.substring(6,8)}`;
    const isoEnd = `${d.rawEnd.substring(0,4)}-${d.rawEnd.substring(4,6)}-${d.rawEnd.substring(6,8)}`;
    const startHour = d.startTime.toString().padStart(4, '0').substring(0, 2);
    const endHour = d.endTime.toString().padStart(4, '0').substring(0, 2);

    const getHourOptions = (selected) => {
        let options = "";
        for (let i = 0; i < 24; i++) {
            const h = i.toString().padStart(2, '0');
            options += `<option value="${h}" ${h === selected ? 'selected' : ''}>${h}時</option>`;
        }
        return options;
    };

    const options = typeof getGachaSelectorOptions === 'function' ? getGachaSelectorOptions(d.id) : [];
    let idOptionsHtml = "";
    options.forEach(opt => {
        const selected = (opt.value == d.id) ? 'selected' : '';
        idOptionsHtml += `<option value="${opt.value}" ${selected}>${opt.label}</option>`;
    });

    const isGuaranteedChecked = d.guaranteed ? 'checked' : '';
    
    return `
        <tr>
            <td>
                <input type="date" value="${isoStart}" class="edit-start-date" style="width:115px; display:block; margin-bottom:2px;">
                <select class="edit-start-time" style="width:60px;">${getHourOptions(startHour)}</select>
            </td>
            <td>
                <input type="date" value="${isoEnd}" class="edit-end-date" style="width:115px; display:block; margin-bottom:2px;">
                <select class="edit-end-time" style="width:60px;">${getHourOptions(endHour)}</select>
            </td>
            <td>
                <select class="edit-id" style="width:100%; max-width:150px;" onchange="updateEditorNameFromId(this)">
                    ${idOptionsHtml}
                </select>
            </td>
            <td><input type="text" value="${d.tsvName}" class="edit-name" style="width:95%; min-width:140px;"></td>
            <td><input type="number" value="${d.uber}" class="edit-uber" style="width:45px;"></td>
            <td><input type="number" value="${d.legend}" class="edit-legend" style="width:40px;"></td>
            <td><input type="checkbox" ${isGuaranteedChecked} class="edit-guaranteed"></td>
            <td><button onclick="deleteEditorRow(this)" class="remove-btn" style="padding: 2px 6px;">×</button></td>
        </tr>
    `;
}

/**
 * IDプルダウン変更時にガチャ名を自動セットする補助関数
 */
function updateEditorNameFromId(selectEl) {
    const row = selectEl.closest('tr');
    const nameInput = row.querySelector('.edit-name');
    const uberInput = row.querySelector('.edit-uber');
    if (!nameInput) return;

    const selectedText = selectEl.options[selectEl.selectedIndex].text;
    const match = selectedText.match(/\)\s*(.+)$/);
    if (match && match[1]) {
        const name = match[1].replace(/\[確定\]$/, "").trim();
        nameInput.value = name;
        if (uberInput) {
            if (name.includes("超ネコ祭") || name.includes("極ネコ祭")) uberInput.value = "900";
            else if (name.includes("超極ネコ祭")) uberInput.value = "1000";
            else if (name.includes("超国王祭")) uberInput.value = "700";
            else uberInput.value = "500";
        }
    }
}

====================
FILE: view_schedule_gantt.js
====================
/** @file view_schedule_gantt.js @description ガントチャートの描画処理 */

function renderGanttChart(data) {
    const filteredData = data.filter(item => !isPlatinumOrLegend(item));
    if (filteredData.length === 0) return '<p>表示可能なスケジュールがありません。</p>';

    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    yesterday.setHours(0, 0, 0, 0);
    const yesterdayInt = getDateInt(yesterday);
    
    let activeData = filteredData.filter(item => parseInt(item.rawEnd) >= yesterdayInt);
    const now = new Date();

    // フィルタ: 終了分の非表示設定
    if (hideEndedSchedules) {
        activeData = activeData.filter(item => {
            const endDt = parseDateTime(item.rawEnd, item.endTime);
            return now <= endDt;
        });
    }

    // ソート: 開催終了分を最優先
    activeData.sort((a, b) => {
        const endA = parseDateTime(a.rawEnd, a.endTime);
        const endB = parseDateTime(b.rawEnd, b.endTime);
        const isEndedA = now > endA;
        const isEndedB = now > endB;
        if (isEndedA !== isEndedB) return isEndedA ? -1 : 1;
        return parseInt(a.rawStart) - parseInt(b.rawStart);
    });

    if (activeData.length === 0) return '<p>表示可能な開催中のスケジュールはありません。</p>';

    let minDateInt = parseInt(activeData[0].rawStart);
    let maxEndDateTime = new Date(0);
    let maxLabelTextWidth = 0;

    activeData.forEach(item => {
        const s = parseInt(item.rawStart);
        if (s < minDateInt) minDateInt = s;
        const eDt = parseDateTime(item.rawEnd, item.endTime);
        if (eDt > maxEndDateTime) maxEndDateTime = eDt;

        let displayName = item.seriesName;
        if (item.guaranteed) displayName += " [確定]";
        const textW = calcTextWidth(displayName);
        if (textW > maxLabelTextWidth) maxLabelTextWidth = textW;
    });

    let labelWidth = Math.max(160, maxLabelTextWidth + 20);
    if (labelWidth > 320) labelWidth = 320; 

    // チャートの開始日決定
    let minDate = parseDateStr(String(minDateInt));
    const viewStartDate = new Date(yesterday);
    viewStartDate.setDate(viewStartDate.getDate() - 2);
    if (minDate < viewStartDate) minDate = viewStartDate;

    // チャートの終了日決定
    let chartEnd = new Date(maxEndDateTime);
    chartEnd.setHours(0, 0, 0, 0);
    chartEnd.setDate(chartEnd.getDate() + 1);

    const totalDays = Math.ceil((chartEnd - minDate) / (1000 * 60 * 60 * 24));
    
    if (totalDays <= 0) return '';
    const dayWidth = 50; 
    const msPerDay = 1000 * 60 * 60 * 24;
    
    // 合計幅を厳密に計算
    const totalWidth = labelWidth + (totalDays * dayWidth);
    
    let currentLineHtml = '';
    if (now >= minDate && now < chartEnd) {
        const diffNowMs = now - minDate;
        const currentLineLeftPx = (diffNowMs / msPerDay) * dayWidth;
        currentLineHtml = `<div class="gantt-current-line" style="left:${currentLineLeftPx}px;"></div>`;
    }

    // ヘッダー行: ガチャ名セルに flex centering を適用し、高さを30pxで固定
    let headerHtml = `<div class="gantt-header" style="width: ${totalWidth}px; min-width: ${totalWidth}px; display: flex; flex-wrap: nowrap; background: #f9f9f9; height: 30px;">
        <div class="gantt-label-col" style="width:${labelWidth}px; min-width:${labelWidth}px; flex: none; display: flex; align-items: center; justify-content: center; height: 100%;">ガチャ名</div>`;
    for (let i = 0; i < totalDays; i++) {
        const d = new Date(minDate);
        d.setDate(d.getDate() + i);
        const dateStr = getShortDateStr(d);
        const isToday = getDateInt(d) === getDateInt(new Date());
        const isWeekend = d.getDay() === 0 || d.getDay() === 6;
        const cls = `gantt-date-cell${isToday ? ' today' : ''}${isWeekend ? ' weekend' : ''}`;
        headerHtml += `<div class="${cls}" style="width:${dayWidth}px; flex: none;">${dateStr}</div>`;
    }
    headerHtml += `</div>`;

    let bodyHtml = '';
    activeData.forEach(item => {
        const startDateTime = parseDateTime(item.rawStart, item.startTime);
        const endDateTime = parseDateTime(item.rawEnd, item.endTime);
        const diffStartMs = startDateTime - minDate;
        const durationMs = endDateTime - startDateTime;

        let offsetPx = (diffStartMs / msPerDay) * dayWidth;
        let widthPx = (durationMs / msPerDay) * dayWidth;

        if (offsetPx < 0) { widthPx += offsetPx; offsetPx = 0; }
        const maxPx = totalDays * dayWidth;
        if (offsetPx >= maxPx) return;
        if (offsetPx + widthPx > maxPx) widthPx = maxPx - offsetPx; 
        if (widthPx <= 0) return;

        let displayName = item.seriesName;
        if (item.guaranteed) displayName += " [確定]";

        let barClass = 'gantt-bar';
        if (displayName.includes("極選抜")) barClass += ' g-kyoku';
        else if (displayName.includes("超選抜")) barClass += ' g-cho';
        else if (displayName.includes("ネコ祭")) barClass += ' g-fest';
        else if (displayName.includes("コラボ")) barClass += ' g-collab';

        const durationDays = Math.max(1, Math.round(durationMs / msPerDay));
        let rowClass = 'gantt-row';
        if (now > endDateTime) rowClass += ' row-ended';
        else if (item.guaranteed) rowClass += ' row-guaranteed';

        bodyHtml += `
            <div class="${rowClass}" style="width: ${totalWidth}px; min-width: ${totalWidth}px; display: flex; flex-wrap: nowrap; height: 30px;">
                <div class="gantt-label-col" style="width:${labelWidth}px; min-width:${labelWidth}px; flex: none;"
                title="${displayName} (ID:${item.id})">${displayName}</div>
                <div class="gantt-bar-area" style="width: ${totalDays * dayWidth}px; flex: none; position: relative;">
                    ${generateGridLines(totalDays, dayWidth, minDate)}
                    <div class="${barClass}" style="left: ${offsetPx}px; width: ${widthPx}px;">
                        <span class="gantt-bar-text">${durationDays}日間</span>
                    </div>
                    ${currentLineHtml}
                </div>
            </div>
        `;
    });

    return `
        <div class="gantt-outer-wrapper" style="width: 100%; max-width: 100%; overflow: hidden;">
            <div style="margin-bottom: 5px; text-align: right;">
                <button onclick="saveGanttImage()" class="secondary" style="font-size: 11px; padding: 4px 8px;">画像として保存</button>
            </div>
            <div class="gantt-chart-container" style="width: 100%; max-width: 100%; overflow: hidden; border: 1px solid #ccc; background: #fff;">
                <div class="gantt-scroll-wrapper" style="overflow-x: auto; -webkit-overflow-scrolling: touch; width: 100%;">
                    <div style="width: ${totalWidth}px; min-width: ${totalWidth}px;">
                        ${headerHtml}
                        <div class="gantt-body">${bodyHtml}</div>
                    </div>
                </div>
            </div>
        </div>
    `;
}

function generateGridLines(days, width, startDate) {
    let html = '';
    for (let i = 0; i < days; i++) {
        const d = new Date(startDate);
        d.setDate(d.getDate() + i);
        const isWeekend = d.getDay() === 0 || d.getDay() === 6;
        const style = `left:${i * width}px; width:${width}px;`;
        const cls = isWeekend ? 'gantt-grid-line weekend' : 'gantt-grid-line';
        html += `<div class="${cls}" style="${style}"></div>`;
    }
    return html;
}

====================
FILE: view_schedule_table.js
====================
/** @file view_schedule_table.js @description リスト形式のスケジュール表描画 */

function renderScheduleTable(tsvContent, containerId) {
    const container = document.getElementById(containerId);
    if (!container) return;
    const data = parseGachaTSV(tsvContent);
    const now = new Date();
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    const yesterdayInt = getDateInt(yesterday);
    
    let filteredData = data.filter(item => parseInt(item.rawEnd) >= yesterdayInt);
    // フィルタ: 終了分の非表示設定
    if (hideEndedSchedules) {
        filteredData = filteredData.filter(item => {
            const endDt = parseDateTime(item.rawEnd, item.endTime);
            return now <= endDt;
        });
    }

    // ソート順：開催終了分を最優先 -> 通常ガチャ（日付順） -> 特別枠（日付順）
    filteredData.sort((a, b) => {
        const endA = parseDateTime(a.rawEnd, a.endTime);
        const endB = parseDateTime(b.rawEnd, b.endTime);
        const isEndedA = now > endA;
        const isEndedB = now > endB;

        if (isEndedA !== isEndedB) return isEndedA ? -1 : 1;

        const isSpecialA = isPlatinumOrLegend(a);
      
        const isSpecialB = isPlatinumOrLegend(b);
        if (isSpecialA !== isSpecialB) return isSpecialA ? 1 : -1; 

        return parseInt(a.rawStart) - parseInt(b.rawStart);
    });
    const ganttHtml = renderGanttChart(data);
    const hideBtnClass = hideEndedSchedules ? 'text-btn active' : 'text-btn';
    let html = `
        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
            <h3 style="margin:0;">開催スケジュール</h3>
            <span onclick="toggleHideEnded()" class="${hideBtnClass}" style="font-size: 0.8em;">終了分を非表示</span>
        </div>
        ${ganttHtml}
        <div style="margin-top: 20px;"></div>
        <div class="schedule-scroll-wrapper">
        <table class="schedule-table">
        
        <thead>
            <tr>
                <th style="min-width:50px;">自</th>
                <th style="min-width:50px;">至</th>
                <th>ガチャ名 / 詳細</th>
                <th>レア</th>
            
                <th>激レア</th>
    
                <th>超激</th>
                <th>伝説</th>
                <th>確定</th>
            </tr>
        </thead>
        <tbody>
    `;
    filteredData.forEach((item, index) => {
        let seriesDisplay = item.seriesName ? item.seriesName : "シリーズ不明";
        
        // 重複防止：seriesNameにすでに [確定] が含まれている場合は追加しない
        if (item.guaranteed && !seriesDisplay.includes("[確定]")) {
            seriesDisplay += " [確定]";
        }

        const startStr = `${formatDateJP(item.rawStart)}<br><span style="font-size:0.85em">${formatTime(item.startTime)}</span>`;
        const endDateFormatted = formatDateJP(item.rawEnd);
        let endStr = endDateFormatted;

        const isPlat = item.seriesName.includes("プラチナ");
        const isLeg = item.seriesName.includes("レジェンド");
        let isAppliedNextStart = false;

        if (isPlat || isLeg) {
            const nextSameType = filteredData.slice(index + 1).find(nextItem => {
                if (isPlat) return nextItem.seriesName.includes("プラチナ");
                if (isLeg) return nextItem.seriesName.includes("レジェンド");
                return false;
            });
    
            if (nextSameType) {
                if (parseInt(nextSameType.rawStart) < yesterdayInt) {
                    return;
                }

                endStr = `${formatDateJP(nextSameType.rawStart)}<br><span style="font-size:0.85em">${formatTime(nextSameType.startTime)}</span>`;
                isAppliedNextStart = true;
            }
        }

        if (!isAppliedNextStart && endDateFormatted !== '永続') {
            endStr += `<br><span style="font-size:0.85em">${formatTime(item.endTime)}</span>`;
        }
        
        const isPlatLeg = isPlatinumOrLegend(item);
        const uberRateVal = parseInt(item.uber);
        let uberStyle = ( !isPlatLeg && uberRateVal !== 500 ) ? 'color:red; font-weight:bold;' : '';
        const legendRateVal = parseInt(item.legend);
        let legendStyle = ( !isPlatLeg && legendRateVal > 30 ) ? 'color:red; font-weight:bold;' : '';
        const endDateTime = parseDateTime(item.rawEnd, item.endTime);
        let rowClass = (now > endDateTime) ? "row-ended" : (item.guaranteed ? "row-guaranteed" : "");
        html += `
            <tr class="${rowClass}">
                <td>${startStr}</td>
                <td>${endStr}</td>
                <td style="text-align:left; vertical-align: middle;">
                    <div style="font-weight:bold; color:#000;">${seriesDisplay} <span style="font-weight:normal; font-size:0.9em; color:#555; user-select: text;">(ID: ${item.id})</span></div>
     
                <div style="font-size:0.85em; color:#333; margin-top:2px;">${item.tsvName}</div>
                </td>
                <td>${fmtRate(item.rare)}</td>
                <td>${fmtRate(item.supa)}</td>
                <td style="${uberStyle}">${fmtRate(item.uber)}</td>
                
                <td style="${legendStyle}">${fmtRate(item.legend)}</td>
                <td style="text-align:center; font-size:1.2em;">
                    ${item.guaranteed ?
                '<span style="color:red;">●</span>' : '-'}
                </td>
            </tr>
        `;
    });

    html += `</tbody></table></div>`;

    // 編集モードへの移行ボタンを追加
    html += `
        <div style="margin-top: 20px; padding-bottom: 30px; text-align: center;">
            <button id="enter-edit-mode-btn" class="secondary" onclick="enterScheduleEditMode()" style="padding: 10px 20px; font-size: 14px;">
                スケジュールを編集する
            </button>
        </div>
    `;

    container.innerHTML = html;
}

====================
FILE: view_schedule_utils.js
====================
/** @file view_schedule_utils.js @description スケジュール表示の共通設定とユーティリティ */

// 表示状態管理用の変数
if (typeof hideEndedSchedules === 'undefined') {
    window.hideEndedSchedules = false;
}

/** 終了分の表示/非表示を切り替えて再描画 */
function toggleHideEnded() {
    hideEndedSchedules = !hideEndedSchedules;
    if (typeof loadedTsvContent !== 'undefined' && loadedTsvContent) {
        // 再描画を実行
        renderScheduleTable(loadedTsvContent, 'schedule-container');
    }
}

/** 文字列の表示幅を概算する関数 (動的幅調整用) */
function calcTextWidth(text) {
    let width = 0;
    for (let i = 0; i < text.length; i++) {
        const code = text.charCodeAt(i);
        // 半角文字(ASCII範囲)は約8px、それ以外(全角)は約13pxと仮定
        if ((code >= 0x00 && code < 0x81) || (code === 0xf8f0) || (code >= 0xff61 && code < 0xffa0) || (code >= 0xf8f1 && code < 0xf8f4)) {
            width += 8;
        } else {
            width += 13;
        }
    }
    return width;
}

/** 確率のフォーマット (30 -> 0.3%) */
function fmtRate(val) {
    if (!val) return "0%";
    return (parseInt(val) / 100) + "%";
}

/** ガントチャートを画像として全体保存（バーの右端でトリミングする版） */
function saveGanttImage() {
    const element = document.querySelector('.gantt-chart-container');
    const scrollWrapper = document.querySelector('.gantt-scroll-wrapper');
    if (!element || !scrollWrapper) return;
    
    // 1. 全体の要素情報を取得
    const containerRect = element.getBoundingClientRect();
    const bars = element.querySelectorAll('.gantt-bar');
    
    // 2. 最も右にあるバーの終端位置を探す
    let maxBarRightEdge = 0;
    bars.forEach(bar => {
        const rect = bar.getBoundingClientRect();
        const relativeRight = rect.right - containerRect.left;
        if (relativeRight > maxBarRightEdge) {
            maxBarRightEdge = relativeRight;
        }
    });

    // 3. 切り出し幅の決定 (バーの終端 + 20px の余白)
    // バーが一つも無い場合は要素全体の幅を使用
    const buffer = 20;
    const finalCropWidth = maxBarRightEdge > 0 ? maxBarRightEdge + buffer : element.offsetWidth;

    // 4. スタイルの保存と一時変更
    const originalOverflow = element.style.overflow;
    const originalWidth = element.style.width;
    const originalMaxWidth = element.style.maxWidth;
    const originalWrapperOverflow = scrollWrapper.style.overflow;
    const originalWrapperWidth = scrollWrapper.style.width;

    const stickyElements = element.querySelectorAll('.gantt-label-col, .gantt-header, .gantt-date-cell');
    const originalStickyStyles = [];
    stickyElements.forEach(el => {
        originalStickyStyles.push({ el: el, position: el.style.position });
        el.style.position = 'static'; // キャプチャ用に固定解除
    });

    // 全域レンダリングのために一時的に制限解除
    element.style.overflow = 'visible';
    element.style.maxWidth = 'none';
    scrollWrapper.style.overflow = 'visible';

    // 5. html2canvasで指定した幅（バーの少し右まで）をキャプチャ
    html2canvas(element, {
        width: finalCropWidth,       // ここで右側をトリミング
        windowWidth: element.scrollWidth, 
        scale: 2,                   // 高画質
        useCORS: true,
        backgroundColor: "#ffffff",
        logging: false
    }).then(canvas => {
        const link = document.createElement('a');
        link.download = `gacha_schedule_${new Date().getTime()}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
        
        restoreStyles();
    }).catch(err => {
        console.error("Image capture failed:", err);
        alert("画像の保存に失敗しました。");
        restoreStyles();
    });

    function restoreStyles() {
        element.style.overflow = originalOverflow;
        element.style.width = originalWidth;
        element.style.maxWidth = originalMaxWidth;
        scrollWrapper.style.overflow = originalWrapperOverflow;
        scrollWrapper.style.width = originalWrapperWidth;
        originalStickyStyles.forEach(item => {
            item.el.style.position = item.position;
        });
    }
}

====================
FILE: view_table.js
====================
/** @file view_table.js @description ガチャ結果テーブル全体の描画制御 */

const COLOR_ROUTE_HIGHLIGHT = '#aaddff';
const COLOR_ROUTE_UBER = '#66b2ff';

function generateRollsTable() {
    try {
        if (Object.keys(gachaMasterData.gachas).length === 0) return;
        const seedEl = document.getElementById('seed');
        if (!seedEl) return;
        
        let initialSeed = parseInt(seedEl.value, 10);
        if (isNaN(initialSeed)) { 
            initialSeed = 12345;
            seedEl.value = "12345"; 
        }
        
        const numRolls = currentRolls;
        const seeds = [];
        const rngForSeeds = new Xorshift32(initialSeed);
        for (let i = 0; i < numRolls * 15 + 100; i++) seeds.push(rngForSeeds.next());

        const columnConfigs = prepareColumnConfigs();
        const tableData = executeTableSimulation(numRolls, columnConfigs, seeds);

        // 3. ハイライト判定
        const { highlightMap, guarHighlightMap, lastSeedValue } = preparePathHighlightMaps(initialSeed, seeds, numRolls);
        finalSeedForUpdate = lastSeedValue;

        let findAreaHtml = '';
        if (typeof generateFastForecast === 'function') findAreaHtml += generateFastForecast(initialSeed, columnConfigs);
        if (typeof generateMasterInfoHtml === 'function' && showFindInfo && isMasterInfoVisible) {
            findAreaHtml += `<div id="master-info-area" style="padding: 10px; background: #fdfdfd; border: 1px solid #ddd; border-top: none; margin-top: -16px; border-radius: 0 0 4px 4px; font-size: 0.85em;">`;
            findAreaHtml += `<div style="border-top: 1px dashed #ccc; margin-bottom: 10px;"></div>`; 
            findAreaHtml += generateMasterInfoHtml();
            findAreaHtml += `</div>`;
        }

        const container = document.getElementById('rolls-table-container');
        if (!container) return;

        if (isTxtMode && isSimulationMode) {
            // テキスト表示モード
            const txtViewHtml = generateTxtRouteView(seeds, initialSeed);
            container.innerHTML = findAreaHtml + txtViewHtml;
        } else {
            // 通常テーブル表示モード
            let simNoticeHtml = '';
            if (isSimulationMode) {
                simNoticeHtml = `<div id="sim-auto-calc-notice" style="font-size: 0.75em; color: #666; padding: 5px 10px; background: #fff;">
                    ※下の表のキャラ名をタップ（クリック）するとそのセルまでのルートを自動計算します。自動計算では、超激確定・プラチナ・レジェンドは消費を避けるため使用しません。
                </div>`;
            }
            const tableHtml = buildTableDOM(numRolls, columnConfigs, tableData, seeds, highlightMap, guarHighlightMap);
            container.innerHTML = findAreaHtml + simNoticeHtml + tableHtml;
        }

        const resultDiv = document.getElementById('result');
        if (resultDiv) resultDiv.textContent = isSimulationMode ? "Simulation active..." : "Display Mode";
        updateUrlParams();
    } catch (e) {
        const container = document.getElementById('rolls-table-container');
        if (container) container.innerHTML = `<p class="error">エラー: ${e.message}</p>`;
        console.error(e);
    }
}

/** 内部関数: テーブルDOMの組み立て */
function buildTableDOM(numRolls, columnConfigs, tableData, seeds, highlightMap, guarHighlightMap) {
    const buttonHtml = `
        <div style="display: flex; flex-wrap: wrap; align-items: center; justify-content: center; gap: 3px; font-weight: normal; white-space: normal;">
            <span style="font-weight: bold; margin-right: 1px; font-size: 11px;">A</span>
            <button class="add-gacha-btn" onclick="addGachaColumn()" style="font-size: 11px; padding: 1px 4px;">＋列を追加</button>
            <button class="add-gacha-btn" style="background-color: #17a2b8; font-size: 11px; padding: 1px 4px;" onclick="addGachasFromSchedule()">skdで追加</button>
            <span id="add-id-trigger" style="cursor:pointer; text-decoration:underline; color:#007bff; font-size: 11px; font-weight:bold;" onclick="showIdInput()">IDで追加</span>
            <button class="remove-btn" onclick="resetToFirstGacha()" title="一番左の列以外を解除" style="font-size: 11px; padding: 1px 5px; margin-left: 2px;">×</button>
        </div>`;
    
    let totalGachaCols = 0;
    tableGachaIds.forEach(idWithSuffix => {
        let id = idWithSuffix.replace(/[gfs]$/, '');
        if (gachaMasterData.gachas[id]) totalGachaCols += /[gfs]$/.test(idWithSuffix) ? 2 : 1;
    });

    const calcColClass = `calc-column ${showSeedColumns ? '' : 'hidden'}`;
    const calcColSpan = showSeedColumns ? 5 : 0;
    const totalTrackSpan = calcColSpan + totalGachaCols;

    // 左端NO列（A側）を固定するためのCSSスタイル
    const stickyLeftStyle = `position: sticky; left: 0; z-index: 30; background-color: #f8f9fa; border-right: 1px solid #ddd;`;
    const stickyTopLeftStyle = `position: sticky; top: 0; left: 0; z-index: 40; background-color: #f8f9fa; border-right: 1px solid #ddd;`;

    let html = `<table style="table-layout: auto; width: 100%; border-collapse: collapse;"><thead>
        <tr>
            <th class="col-no" style="${stickyLeftStyle}"></th>
            <th colspan="${totalTrackSpan}" style="text-align: center; vertical-align: middle; padding: 4px; width: 50%;">${buttonHtml}</th>
            <th class="col-no"></th>
            <th colspan="${totalTrackSpan}" style="text-align: center; vertical-align: middle; padding: 4px; font-weight: bold; width: 50%;">B</th>
        </tr>
        <tr class="sticky-row">
            <th class="col-no" style="${stickyTopLeftStyle}">NO.</th><th class="${calcColClass}">SEED</th><th class="${calcColClass}">rarity</th><th class="${calcColClass}">slot</th><th class="${calcColClass}">ReRoll</th><th class="${calcColClass}">Guar</th>
            ${generateNameHeaderHTML()}
            <th class="col-no">NO.</th><th class="${calcColClass}">SEED</th><th class="${calcColClass}">rarity</th><th class="${calcColClass}">slot</th><th class="${calcColClass}">ReRoll</th><th class="${calcColClass}">Guar</th>
            ${generateNameHeaderHTML()}
        </tr>
        <tr class="control-row">
            <th class="col-no" style="${stickyLeftStyle}"></th><th class="${calcColClass}"></th><th class="${calcColClass}"></th><th class="${calcColClass}"></th><th class="${calcColClass}"></th><th class="${calcColClass}"></th>
            ${generateControlHeaderHTML(true)}
            <th class="col-no"></th><th class="${calcColClass}"></th><th class="${calcColClass}"></th><th class="${calcColClass}"></th><th class="${calcColClass}"></th><th class="${calcColClass}"></th>
            ${generateControlHeaderHTML(false)}
        </tr>
    </thead><tbody>`;

    for (let i = 0; i < numRolls; i++) {
        const seedIndexA = i * 2, seedIndexB = i * 2 + 1;
        html += `<tr>${renderTableRowSide(i, seedIndexA, columnConfigs, tableData, seeds, highlightMap, guarHighlightMap, true)}`;
        html += `${renderTableRowSide(i, seedIndexB, columnConfigs, tableData, seeds, highlightMap, guarHighlightMap, false)}</tr>`;
    }

    const fullColSpan = 2 + (totalTrackSpan * 2);
    html += `<tr><td colspan="${fullColSpan}" style="padding: 10px; text-align: center;">
        <button onclick="addMoreRolls()">+100行</button>
        <button id="toggle-seed-btn" class="secondary" onclick="toggleSeedColumns()">${showSeedColumns ? 'SEED非表示' : 'SEED表示'}</button>
    </td></tr></tbody></table>`;
    return html;
}

/** 内部関数: A側/B側それぞれの行レンダリング */
function renderTableRowSide(rowIndex, seedIndex, columnConfigs, tableData, seeds, highlightMap, guarHighlightMap, isLeftSide) {
    let styleNo = '';
    let bgColor = '#f8f9fa'; // デフォルトのNO列背景色

    if (RowAnalysis.isSimpleYellow(seedIndex, seeds) || RowAnalysis.isConsecutiveYellow(seedIndex, seeds)) {
        styleNo = 'background-color: #ffeb3b;';
        bgColor = '#ffeb3b';
    } else if (RowAnalysis.isSimpleOrange(seedIndex, seeds) || RowAnalysis.isConsecutiveOrange(seedIndex, seeds)) {
        styleNo = 'background-color: #ff9800;';
        bgColor = '#ff9800';
    }

    // 左側のNO列のみ sticky を適用
    let stickyStyle = isLeftSide ? `position: sticky; left: 0; z-index: 5; border-right: 1px solid #ddd; background-color: ${bgColor};` : '';

    let sideHtml = `<td class="col-no" style="${stickyStyle}${styleNo}">${rowIndex + 1}</td>`;
    sideHtml += generateDetailedCalcCells(seedIndex, seeds, tableData);

    tableGachaIds.forEach((idWithSuffix, colIndex) => {
        let id = idWithSuffix.replace(/[gfs]$/, '');
        let suffix = '';
        if (idWithSuffix.endsWith('f')) suffix = 'f';
        else if (idWithSuffix.endsWith('s')) suffix = 's';
        else if (idWithSuffix.endsWith('g')) suffix = 'g';
        const isG = (suffix !== '');

        if (!gachaMasterData.gachas[id]) return;

        let cellHtml = generateCell(seedIndex, id, colIndex, tableData, seeds, highlightMap, isSimulationMode);
        
        // セル内改行を許可。幅は自動（ヘッダーの50%指定が優先される）
        cellHtml = cellHtml.replace('style="', 'style="white-space: normal; width: auto; word-break: break-all; vertical-align: middle; ');
        
        if (isSimulationMode) {
            cellHtml = cellHtml.replace(/background-color:\s*#98FB98;/gi, `background-color: ${COLOR_ROUTE_HIGHLIGHT};`);
            cellHtml = cellHtml.replace(/background-color:\s*#32CD32;/gi, `background-color: ${COLOR_ROUTE_UBER};`);
        }
        sideHtml += cellHtml;

        if (isG) {
            let gContent = '---';
            let cellStyle = 'white-space: normal; width: auto; word-break: break-all; vertical-align: middle; ';
            if (isSimulationMode && guarHighlightMap.get(seedIndex) === id) cellStyle += `background-color: ${COLOR_ROUTE_UBER};`;
            
            const config = columnConfigs[colIndex];
            const normalRolls = config._guaranteedNormalRolls || 10;
            let lastDraw = (rowIndex > 0 && tableData[seedIndex - 2]?.[colIndex]?.roll) ?
                { rarity: tableData[seedIndex - 2][colIndex].roll.rarity, charId: tableData[seedIndex - 2][colIndex].roll.charId } : null;
            
            const gRes = calculateGuaranteedLookahead(seedIndex, config, seeds, lastDraw, normalRolls);
            const addr = formatAddress(gRes.nextRollStartSeedIndex);
            let charName = gRes.name;
            let gType = (suffix === 'g') ? '11g' : (suffix === 'f' ? '15g' : '7g');
            const escapedName = charName.replace(/'/g, "\\'");

            let gClickAction = isSimulationMode ?
                `onclick="onGachaCellClick(${seedIndex}, '${id}', '${escapedName}', '${gType}')"` :
                (gRes.nextRollStartSeedIndex > 0 ? `onclick="updateSeedAndRefresh(${seeds[gRes.nextRollStartSeedIndex - 1]})"` : "");

            let mainHtml = `<span style="font-size:0.9em; color:#666;">${addr}</span><span class="char-link" style="cursor:pointer;" ${gClickAction}>${charName}</span>`;
            let altHtml = '';
            if (gRes.alternative) {
                const altAddr = formatAddress(gRes.alternative.nextRollStartSeedIndex);
                let altCharName = gRes.alternative.name;
                const escAlt = altCharName.replace(/'/g, "\\'");
                let altClickAction = isSimulationMode ?
                    `onclick="onGachaCellClick(${seedIndex}, '${id}', '${escAlt}', '${gType}')"` :
                    (gRes.alternative.nextRollStartSeedIndex > 0 ? `onclick="updateSeedAndRefresh(${seeds[gRes.alternative.nextRollStartSeedIndex - 1]})"` : "");
                altHtml = `<span style="font-size:0.9em; color:#666;">${altAddr}</span><span class="char-link" style="cursor:pointer;" ${altClickAction}>${altCharName}</span><br>`;
            }
            gContent = altHtml + mainHtml;
            sideHtml += `<td style="${cellStyle}">${gContent}</td>`;
        }
    });
    return sideHtml;
}

/** ルートに従ったテキスト表示を生成 */
function generateTxtRouteView(seeds, initialSeed) {
    const configInput = document.getElementById('sim-config');
    const configStr = configInput ? configInput.value.trim() : "";
    if (!configStr) return "<div style='padding:20px; color:#666;'>ルートが入力されていません。</div>";

    const configs = parseSimConfig(configStr);
    let currentIdx = 0;
    let lastDraw = null;
    let outputArr = [];

    let stats = { single: 0, plat: 0, leg: 0, guar: 0, legends: {}, limiteds: {}, ubers: {} };
    const limitedSet = new Set();
    if (typeof limitedCats !== 'undefined') {
        limitedCats.forEach(id => { limitedSet.add(id); limitedSet.add(String(id)); });
    }
    const addStat = (map, name) => { map[name] = (map[name] || 0) + 1; };

    configs.forEach(sim => {
        const originalGacha = gachaMasterData.gachas[sim.id];
        if (!originalGacha) return;

        const colIdx = tableGachaIds.findIndex(tid => tid.replace(/[gfs]$/, '') === sim.id);
        const addCount = (colIdx >= 0) ? (uberAdditionCounts[colIdx] || 0) : 0;

        let gacha = JSON.parse(JSON.stringify(originalGacha));
        if (addCount > 0 && gacha.pool.uber) {
            for (let k = 1; k <= addCount; k++) {
                gacha.pool.uber.unshift({ id: `sim-new-${k}`, name: `新規超激${k}`, rarity: 'uber' });
            }
        }

        let suffixText = "";
        let normalRolls = sim.rolls;
        let isG = false;
        const isPlat = gacha.name.includes("プラチナ");
        const isLeg = gacha.name.includes("レジェンド");

        if (sim.g) {
            isG = true; stats.guar++;
            if (sim.rolls === 11) { normalRolls = 10; suffixText = "11連確定"; }
            else if (sim.rolls === 15) { normalRolls = 14; suffixText = "15連確定"; }
            else if (sim.rolls === 7) { normalRolls = 6; suffixText = "7連確定"; }
            else { normalRolls = sim.rolls; suffixText = `${sim.rolls}連確定`; }
        } else {
            suffixText = `${sim.rolls}Roll`;
        }

        if (isPlat) stats.plat += normalRolls;
        else if (isLeg) stats.leg += normalRolls;
        else stats.single += normalRolls;

        const startAddr = typeof formatAddress === 'function' ? formatAddress(currentIdx).replace(')', '') : '';
        let segmentTxt = `[${gacha.name}]（${suffixText}/${startAddr}）<br>=> `;

        let charNames = [];
        for (let k = 0; k < normalRolls; k++) {
            if (currentIdx + 1 >= seeds.length) break;
            const rr = rollWithSeedConsumptionFixed(currentIdx, gacha, seeds, lastDraw);
            const charObj = rr.finalChar;
            charNames.push(charObj.name);
            if (rr.rarity === 'legend') addStat(stats.legends, charObj.name);
            else if (limitedSet.has(charObj.id)) addStat(stats.limiteds, charObj.name);
            else if (rr.rarity === 'uber') addStat(stats.ubers, charObj.name);
            currentIdx += rr.seedsConsumed;
            lastDraw = { rarity: rr.rarity, charId: rr.charId, isRerolled: rr.isRerolled };
        }

        if (isG && currentIdx < seeds.length) {
            const gr = rollGuaranteedUber(currentIdx, gacha, seeds);
            const charObj = gr.finalChar;
            charNames.push(charObj.name);
            if (limitedSet.has(charObj.id)) addStat(stats.limiteds, charObj.name);
            else if (gr.rarity === 'uber') addStat(stats.ubers, charObj.name);
            currentIdx += gr.seedsConsumed;
            lastDraw = { rarity: gr.rarity, charId: gr.charId, isRerolled: false };
        }
        segmentTxt += charNames.join(", ");
        outputArr.push(segmentTxt);
    });

    const formatStatMap = (map) => {
        const entries = Object.entries(map);
        if (entries.length === 0) return "";
        return entries.map(([name, count]) => count >= 2 ? `${name}（${count}）` : name).join("、");
    };

    let countsHtml = "";
    if (stats.single > 0) countsHtml += `レアチケ：${stats.single}回<br>`;
    if (stats.plat > 0) countsHtml += `プラチケ：${stats.plat}回<br>`;
    if (stats.leg > 0) countsHtml += `レジェチケ：${stats.leg}回<br>`;
    if (stats.guar > 0) countsHtml += `確定：${stats.guar}回<br>`;

    let acquisitionHtml = "";
    const legendStr = formatStatMap(stats.legends), limitedStr = formatStatMap(stats.limiteds), uberStr = formatStatMap(stats.ubers);
    if (legendStr) acquisitionHtml += `伝説：${legendStr}<br>`;
    if (limitedStr) acquisitionHtml += `限定：${limitedStr}<br>`;
    if (uberStr) acquisitionHtml += `超激：${uberStr}<br>`;

    let summaryHtml = `
<div style="margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid #eee; font-family: monospace;">
【SEED】<br>実行前：${initialSeed}<br>最終：${finalSeedForUpdate || "---"}<br><br>
【回数】<br>${countsHtml}<br>
【取得】<br>${acquisitionHtml}
</div>`;

    return `<div id="txt-route-display" style="padding: 20px; background: #fff; line-height: 1.8; font-size: 14px; user-select: text; font-family: sans-serif;">
        ${summaryHtml}${outputArr.join("<br>")}<br></div>`;
}

====================
FILE: view_table_data.js
====================
/** @file view_table_data.js @description テーブル用データ（ColumnConfigおよび抽選結果）の生成 */

/** 各列のガチャ設定を構築 */
function prepareColumnConfigs() {
    return tableGachaIds.map((idWithSuffix, colIndex) => {
        let id = idWithSuffix;
        let suffix = '';
        if (idWithSuffix.endsWith('f')) { suffix = 'f'; id = idWithSuffix.slice(0, -1); }
        else if (idWithSuffix.endsWith('s')) { suffix = 's'; id = idWithSuffix.slice(0, -1); }
        else if (idWithSuffix.endsWith('g')) { suffix = 'g'; id = idWithSuffix.slice(0, -1); }

        let guaranteedNormalRolls = 0;
        if (suffix === 'g') guaranteedNormalRolls = 10;
        else if (suffix === 'f') guaranteedNormalRolls = 14;
        else if (suffix === 's') guaranteedNormalRolls = 6;

        const originalConfig = gachaMasterData.gachas[id];
        if (!originalConfig) return null;

        const config = JSON.parse(JSON.stringify(originalConfig)); // 深いコピー
        config._guaranteedNormalRolls = guaranteedNormalRolls;
        config._suffix = suffix;

        const addCount = uberAdditionCounts[colIndex] || 0;
        if (addCount > 0 && config.pool.uber) {
            for (let k = 1; k <= addCount; k++) {
                config.pool.uber.unshift({ id: `sim-new-${k}`, name: `新規超激${k}`, rarity: 'uber' });
            }
        }
        return config;
    });
}

/** 全ガチャ列のシミュレーションを実行 */
function executeTableSimulation(numRolls, columnConfigs, seeds) {
    const tableData = Array(numRolls * 2).fill(null).map(() => []);

    columnConfigs.forEach((config, colIndex) => {
        if (!config) return;
        let prevDrawA = null, prevDrawB = null;

        for (let i = 0; i < numRolls; i++) {
            const seedIndexA = i * 2;
            const seedIndexB = i * 2 + 1;

            // A側
            const rollResultA = rollWithSeedConsumptionFixed(seedIndexA, config, seeds, prevDrawA);
            const isConsecutiveA = prevDrawA && prevDrawA.isRerolled && rollResultA.isRerolled;
            tableData[seedIndexA][colIndex] = { 
                gachaId: config.id, 
                roll: rollResultA, 
                isConsecutive: isConsecutiveA 
            };
            prevDrawA = { rarity: rollResultA.rarity, charId: rollResultA.charId, isRerolled: rollResultA.isRerolled };

            // B側
            if (seedIndexB < seeds.length - 2) {
                const rollResultB = rollWithSeedConsumptionFixed(seedIndexB, config, seeds, prevDrawB);
                const isConsecutiveB = prevDrawB && prevDrawB.isRerolled && rollResultB.isRerolled;
                tableData[seedIndexB][colIndex] = { 
                    gachaId: config.id, 
                    roll: rollResultB, 
                    isConsecutive: isConsecutiveB 
                };
                prevDrawB = { rarity: rollResultB.rarity, charId: rollResultB.charId, isRerolled: rollResultB.isRerolled };
            }
        }
    });
    return tableData;
}

====================
FILE: view_table_highlight.js
====================
/** @file view_table_highlight.js @description シミュレーションモードのルートハイライト計算 */

function preparePathHighlightMaps(initialSeed, seeds, numRolls) {
    const highlightMap = new Map();
    const guarHighlightMap = new Map();
    let lastSeedValue = null;

    if (!isSimulationMode) return { highlightMap, guarHighlightMap, lastSeedValue };
    const simConfigEl = document.getElementById('sim-config');
    if (!simConfigEl || !simConfigEl.value.trim()) return { highlightMap, guarHighlightMap, lastSeedValue };

    const simConfigs = parseSimConfig(simConfigEl.value.trim());
    let rngForText = new Xorshift32(initialSeed);
    let currentSeedIndex = 0;
    let lastDrawForHighlight = { rarity: null, charId: null };

    for (const sim of simConfigs) {
        const config = gachaMasterData.gachas[sim.id];
        if (!config) continue;

        let normalRolls = sim.rolls;
        let isGuaranteedStep = false;
        if (sim.g) {
            if (sim.rolls === 15) { normalRolls = 14; isGuaranteedStep = true; }
            else if (sim.rolls === 7) { normalRolls = 6; isGuaranteedStep = true; }
            else if (sim.rolls === 11) { normalRolls = 10; isGuaranteedStep = true; }
            else { normalRolls = sim.rolls; }
        }

        if (isGuaranteedStep) {
            const startSeedIndex = currentSeedIndex;
            guarHighlightMap.set(startSeedIndex, sim.id);
            for (let k = 0; k < normalRolls; k++) {
                if (currentSeedIndex >= numRolls * 2) break;
                highlightMap.set(currentSeedIndex, sim.id);
                const rr = rollWithSeedConsumptionFixed(currentSeedIndex, config, seeds, lastDrawForHighlight);
                if (rr.seedsConsumed === 0) break;
                lastDrawForHighlight = { rarity: rr.rarity, charId: rr.charId };
                currentSeedIndex += rr.seedsConsumed;
                for (let x = 0; x < rr.seedsConsumed; x++) rngForText.next();
            }
            if (startSeedIndex < numRolls * 2) highlightMap.set(`${startSeedIndex}G`, sim.id);
            if (currentSeedIndex < seeds.length) {
                const gr = rollGuaranteedUber(currentSeedIndex, config, seeds);
                currentSeedIndex += gr.seedsConsumed;
                for (let x = 0; x < gr.seedsConsumed; x++) rngForText.next();
            }
        } else {
            for (let k = 0; k < normalRolls; k++) {
                if (currentSeedIndex >= numRolls * 2) break;
                highlightMap.set(currentSeedIndex, sim.id);
                const rr = rollWithSeedConsumptionFixed(currentSeedIndex, config, seeds, lastDrawForHighlight);
                if (rr.seedsConsumed === 0) break;
                lastDrawForHighlight = { rarity: rr.rarity, charId: rr.charId };
                currentSeedIndex += rr.seedsConsumed;
                for (let x = 0; x < rr.seedsConsumed; x++) rngForText.next();
            }
        }
    }
    lastSeedValue = rngForText.seed;
    return { highlightMap, guarHighlightMap, lastSeedValue };
}

