<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>イベントガチャロールズ</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.2;
            padding: 5px;
            max-width: 1200px;
            margin: 0 auto;
            background-color: #f4f7f9;
            color: #333;
            font-size: 9px;
        }
        .container {
            background: #fff;
            padding: 5px;
            border-radius: 12px;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.1);
        }
        h1 {
            color: #004085;
            font-size: 0.9rem;
            border-bottom: 1px solid #e9ecef;
            padding-bottom: 3px;
            margin-top: 0;
            text-align: center;
        }
        .controls {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-bottom: 10px;
            padding: 4px;
            background-color: #f9fbfd;
            border-radius: 4px;
        }
        .row {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            gap: 5px;
            align-items: center;
        }
        .control-group-left, .control-group-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .input-item {
            flex: 0 1 auto;
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 3px;
        }
        .input-item-display-only {
            flex: 0 1 auto;
            display: flex;
            align-items: center;
            font-size: 0.7rem;
            color: #555;
            padding: 0 5px;
        }
        .input-item-seed {
            display: flex;
            flex-direction: row;
            align-items: center;
            gap: 3px;
        }
        .seed-input-group {
            display: flex;
            align-items: center;
            gap: 5px;
            flex: 1 1 200px;
        }
        label {
            font-weight: 600;
            color: #555;
        }
        input[type="number"],
        select {
            padding: 3px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 0.8rem;
            width: 100%;
            box-sizing: border-box;
            transition: border-color 0.3s;
        }
        input[type="number"]:focus,
        select:focus {
            outline: none;
            border-color: #007bff;
        }
        button {
            flex-shrink: 0;
            width: auto;
            padding: 5px 10px;
            background-color: #007bff;
            color: #fff;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 0.8rem;
            font-weight: bold;
            transition: background-color 0.3s ease, transform 0.2s ease;
        }
        .hidden-control {
            display: none !important;
        }
        #showSeedInputLink {
            color: #007bff;
            text-decoration: underline;
            cursor: pointer;
            padding: 0 5px;
            font-weight: bold;
        }
        #copySeedLink {
            color: #007bff;
            text-decoration: underline;
            cursor: pointer;
            white-space: nowrap;
        }

        button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }
        #result-container {
            margin-top: 15px;
        }
        #result-table-container {
            overflow-x: auto;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 3px;
            text-align: center;
            border: 1px solid #e0e0e0;
            word-break: break-word;
            font-size: 0.8rem;
            min-width: 25px;
        }
        th {
            background-color: #f0f4f7;
            color: #444;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 1;
        }
        thead th:first-child {
            z-index: 2;
        }
        td {
            background-color: #fff;
        }
        .row-number-header {
            font-family: Arial, sans-serif;
            font-weight: bold;
            width: 25px;
            cursor: pointer;
        }
        .col-no {
            width: 25px;
        }
        
        /* アイテム装飾 */
        .featuredItem-text {
            color: #d9534f; /* 赤 */
            font-weight: bold;
        }
        .legendItem-text {
            color: #0000ff; /* 青 */
            font-weight: bold;
        }

        #result-table-container td a {
            color: inherit;
            text-decoration: none;
        }

        /* 凡例 */
        .legend-box {
            padding: 2px 5px;
            border-radius: 3px;
            margin-left: 5px;
            cursor: pointer;
            border: 1px solid transparent;
        }
        .legend-box:hover {
            border: 1px solid #999;
        }
        .legend-single { background-color: #e0f7ff; }
        .legend-multi { background-color: #ffffe0; }
        .legend-common { background-color: #dfffb0; }

        /* ハイライト用CSS */
        /* デフォルト表示用 */
        .highlight-roll { background-color: #e0f7ff !important; } /* 単発 (青) */
        .highlight-roll-10pull { background-color: #ffffe0 !important; } /* 10連 (黄) */
        .highlight-roll-overlap { background-color: #dfffb0 !important; } /* 重複 (緑) */

        /* モード別表示用 */
        .mode-single .highlight-roll { background-color: #e0f7ff !important; }
        .mode-single .highlight-roll-overlap { background-color: #e0f7ff !important; } /* 重複も青に */
        .mode-single .highlight-roll-10pull { background-color: #fff !important; } /* 消す */

        .mode-multi .highlight-roll-10pull { background-color: #ffffe0 !important; }
        .mode-multi .highlight-roll-overlap { background-color: #ffffe0 !important; } /* 重複も黄に */
        .mode-multi .highlight-roll { background-color: #fff !important; } /* 消す */
        
        #calculation-details {
            font-family: monospace;
            font-size: 11px;
            line-height: 1.4;
            margin-top: 15px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            background: #f9f9f9;
        }
        #calculation-details h2 {
            font-size: 1.1rem;
            margin-top: 20px;
            margin-bottom: 5px;
            border-bottom: 1px solid #ccc;
            padding-bottom: 3px;
        }
        #toggleDetailsBtn {
            background-color: #6c757d;
        }
        #toggleDetailsBtn:hover {
            background-color: #5a6268;
        }
        #details-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 10px;
        }
        .scroll-buttons {
            display: flex;
            gap: 10px;
        }
        .scroll-buttons button {
            font-size: 0.75rem;
            background-color: #28a745;
        }
        .scroll-buttons button:hover {
            background-color: #218838;
        }
    </style>
</head>
<body>

<div class="container">
    <h1>イベントガチャロールズ</h1>
    <div class="input-group">
        <div class="controls">
            <div class="row">
                <div class="control-group-left">
                    <div class="input-item">
                         <a id="showSeedInputLink" href="#">SEED入力</a>
                    </div>
                    <div class="input-item" id="guaranteedControl">
                        <label for="guaranteedRollsInput">next guaranteed</label>
                        <select id="guaranteedRollsInput"></select>
                    </div>
                    <div class="input-item" id="legendDisplay" style="font-size: 0.7rem;">
                        <span id="legendSingle" class="legend-box legend-single">単発ルート</span>
                        <span id="legendMulti" class="legend-box legend-multi">10連ルート</span>
                        <span id="legendCommon" class="legend-box legend-common">共通ルート</span>
                    </div>
                    <div id="lastRollDisplay" class="input-item-display-only">
                        </div>
                </div>
                <div class="control-group-right">
                    <div class="input-item">
                        <label for="featuredCompleteCheckbox">コンプ済み</label>
                        <input type="checkbox" id="featuredCompleteCheckbox">
                    </div>
                    <div class="input-item" id="stockControl">
                        <label for="featuredStockInput">目玉残数</label>
                        <select id="featuredStockInput"></select>
                    </div>
                    <a id="copySeedLink" href="#">Copy SEED</a>
                </div>
            </div>
            <div class="row hidden-control" id="seedRow">
                <div class="input-item-seed">
                    <label for="seedInput">SEED</label>
                    <div class="seed-input-group">
                        <input type="number" id="seedInput" value="123456789">
                        <button id="executeButton">更新</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div id="result-container">
        <div id="output"></div>
        <div id="result-table-container"></div>
        <div id="details-controls" style="display: none; margin-top: 10px; align-items: center; gap: 10px;">
            <button id="toggleDetailsBtn">計算過程を表示</button>
            <div class="scroll-buttons" style="display: none;">
                <button id="scrollToSingle">単発ルートへ</button>
                <button id="scrollToMulti">10連ルートへ</button>
            </div>
        </div>
        <div id="calculation-details" style="display:none;"></div>
    </div>
</div>

<script>
    // --- マスターデータ ---
    const gachaMaster = {
        '34': { name: '(旧)ハロウィン', featuredItemRate: 600, featuredItemStock: 5, guaranteedCycle: 30, uberGuaranteedFlag: false, legendGuaranteedFlag: false, rarityRates: { '0': 2000, '1': 5000, '2': 3000, '3': 0, '4': 0 }, pool: [0, 2, 3, 4, 5, 10, 11, 12, 14] },
        '42': { name: '1.1億DL記念', featuredItemRate: 500, featuredItemStock: 5, guaranteedCycle: 30, uberGuaranteedFlag: false, legendGuaranteedFlag: false, rarityRates: { '0': 1000, '1': 5000, '2': 3000, '3': 1000, '4': 0 }, pool: [0, 2, 3, 4, 5, 10, 11, 12, 14, 375, 381, 689] },
        '44': { name: 'ハロウィン', featuredItemRate: 500, featuredItemStock: 8, guaranteedCycle: 30, uberGuaranteedFlag: false, legendGuaranteedFlag: false, rarityRates: { '0': 2000, '1': 4900, '2': 3000, '3': 0, '4': 100 }, pool: [0, 2, 3, 4, 5, 10, 11, 12, 14, 18] },
        '45': { name: 'にゃんこレンジャー', featuredItemRate: 0, featuredItemStock: 0, guaranteedCycle: 10, uberGuaranteedFlag: true, legendGuaranteedFlag: false, rarityRates: { '0': 0, '1': 7000, '2': 2300, '3': 500, '4': 200 }, pool: [0,2,3,4,5,11,12,14,197,184,375,726,831] }
    };
    const itemMaster = {
        0: { name: "スピダ", rarity: 1 }, 2: { name: "ネコボン", rarity: 2 }, 3: { name: "ニャンピュ", rarity: 1 }, 4: { name: "おかめ", rarity: 2 }, 5: { name: "スニャ", rarity: 2 },
        10: { name: "5千XP", rarity: 0 }, 11: { name: "1万XP", rarity: 1 }, 12: { name: "3万XP", rarity: 1 }, 14: { name: "10万XP", rarity: 2 }, 18: { name: "200万XP", rarity: 4 },
        197: { name: "100万XP", rarity: 4 }, 184: { name: "ミスターニンジャ", rarity: 3 }, 375: { name: "記念ネコ", rarity: 3 }, 381: { name: "ねこ農家", rarity: 3 },
        689: { name: "石の上にも10年ネコ", rarity: 3 }, 726: { name: "ネコメダル王", rarity: 3 }, 831: { name: "スカーフにゃんこ", rarity: 3 }
    };

    const DEFAULT_PARAMS = {
        gacha: '45',
        seed: '123456789',
        ng: 'none',
        fs: 'none',
        lr: null,
        comp: false,
        tx: false,
        roll: 100,
        displaySeed: '0'
    };

    // ハイライト状態管理
    let currentHighlightMode = 'all'; // 'all', 'single', 'multi'

    function generateUrlQuery(p) {
        const query = new URLSearchParams();
        for (const key in p) {
            if (key === 'displaySeed' && p[key] === DEFAULT_PARAMS.displaySeed) continue;
            if (p[key] !== null && p[key] !== undefined) query.set(key, p[key]);
        }
        return '?' + query.toString();
    }
    
    function xorshift32(seed) {
        let x = seed;
        x ^= x << 13; x ^= x >>> 17; x ^= x << 15;
        return x >>> 0;
    }
    function setupGachaRarityItems() {
        for (const gachaId in gachaMaster) {
            const gacha = gachaMaster[gachaId];
            if (gacha && gacha.pool) {
                gacha.rarityItems = { '0': [], '1': [], '2': [], '3': [], '4': [] };
                for (const itemId of gacha.pool) {
                    const item = itemMaster[itemId];
                    if (item && gacha.rarityItems[item.rarity] !== undefined) {
                        gacha.rarityItems[item.rarity].push(itemId);
                    }
                }
                for (const rarity in gacha.rarityItems) gacha.rarityItems[rarity].sort((a, b) => a - b);
            }
        }
    }

    function generateMasterInfoHtml(gacha) {
        let html = `<h2>＜マスター情報＞</h2>`;
        html += `(ガチャ名称,ID) ${gacha.name}(ID:${activeGachaId})<br>`;
        html += `(目玉有無,レート,初期残数) ${gacha.featuredItemRate > 0}, ${gacha.featuredItemRate}, ${gacha.featuredItemStock}<br>`;
        html += `(確定有無) 超激:${gacha.uberGuaranteedFlag}, 伝説:${gacha.legendGuaranteedFlag}<br>`;
        
        const r = gacha.rarityRates;
        const r0 = r['0'], r1 = r0 + r['1'], r2 = r1 + r['2'], r3 = r2 + r['3'];
        html += `(レアリティレート) 0~${r0}:ノーマル, ${r0}~${r1}レア, ${r1}~${r2}激レア, ${r2}~${r3}超激レア, ${r3}~10000伝説レア<br>`;
        
        html += `(各レアリティ別アイテム総数,名称,ID)<br>`;
        const rarities = ['ノーマル', 'レア', '激レア', '超激レア', '伝説レア'];
        for (let i = 0; i <= 4; i++) {
            const pool = gacha.rarityItems[i.toString()];
            if (pool && pool.length > 0) {
                const itemsStr = pool.map(id => `${itemMaster[id].name}(ID:${id})`).join(', ');
                html += `${rarities[i]}(${pool.length}) ${itemsStr}<br>`;
            }
        }
        return html + '<br>';
    }

    function createAndDisplayCompletedSeedView(initialSeed, gacha, tableRows, thresholds, initialLastRollId, displaySeed, params, initialNg) {
        const SEED = [initialSeed];
        const maxSeedsNeeded = tableRows * 4 * 2 + 1000; 
        for (let i = 1; i < maxSeedsNeeded; i++) {
            SEED[i] = xorshift32(SEED[i - 1]);
        }

        const getRarityFromRoll = (roll) => {
            if (roll < thresholds['0']) return { id: 0, name: 'ノーマル' };
            if (roll < thresholds['1']) return { id: 1, name: 'レア' };
            if (roll < thresholds['2']) return { id: 2, name: '激レア' };
            if (roll < thresholds['3']) return { id: 3, name: '超激レア' };
            return { id: 4, name: '伝説レア' };
        };

        const getAddressString = (n) => {
            if (n <= 0) return '';
            const zeroBasedIndex = n - 1;
            const col_char = String.fromCharCode('A'.charCodeAt(0) + (zeroBasedIndex % 2));
            const row_num = Math.floor(zeroBasedIndex / 2) + 1;
            return `${row_num}${col_char}`;
        };

        const Nodes = [];
        const maxNodeIndex = tableRows * 2 + 100;
        
        let detailsHtml = generateMasterInfoHtml(gacha);
        detailsHtml += '<h2>＜ノード計算詳細 (No.1～)＞</h2>';
        detailsHtml += '<p style="margin-top: -10px; font-size: 10px;">（このデータは、特定のSEED INDEXからの計算結果を示します。実際のルートではレア被りにより消費SEED数が異なります）</p>';

        for (let i = 1; i <= maxNodeIndex; i++) {
            const node = {
                index: i,
                address: getAddressString(i),
                seed1: SEED[i],
                seed2: SEED[i+1],
                seed3: SEED[i+2]
            };

            const roll1 = node.seed1 % 10000;
            node.rarity = getRarityFromRoll(roll1);
            node.rarityId = node.rarity.id;

            const uberRate = gacha.uberGuaranteedFlag ? (gacha.rarityRates['3'] || 0) : 0;
            const legendRate = gacha.legendGuaranteedFlag ? (gacha.rarityRates['4'] || 0) : 0;
            const gDivisor = uberRate + legendRate;
            if (gDivisor > 0) {
                const gRoll = node.seed1 % gDivisor;
                node.rarityGId = (gRoll < uberRate) ? '3' : '4';
                node.rarityGName = (node.rarityGId === '3') ? '超激レア' : '伝説レア';
                node.gRoll = gRoll; node.gDivisor = gDivisor;
            } else {
                node.rarityGId = null; node.rarityGName = '-'; node.gRoll = 0; node.gDivisor = 0;
            }

            const pool = gacha.rarityItems[node.rarityId] || [];
            node.poolSize = pool.length;
            if (pool.length > 0) {
                node.slot = node.seed2 % pool.length;
                node.itemId = pool[node.slot];
                node.itemName = itemMaster[node.itemId]?.name || '---';
            } else {
                node.slot = 0; node.itemId = -1; node.itemName = '---';
            }

            const poolG = node.rarityGId ? (gacha.rarityItems[node.rarityGId] || []) : [];
            node.poolGSize = poolG.length;
            if (poolG.length > 0) {
                node.slotG = node.seed2 % poolG.length;
                node.itemGId = poolG[node.slotG];
                node.itemGName = itemMaster[node.itemGId]?.name || '---';
            } else {
                node.slotG = 0; node.itemGId = -1; node.itemGName = '---';
            }

            const prevNode = (i > 2) ? Nodes[i - 3] : null;
            const isRare = (node.rarityId === 1);
            const prevItemId = prevNode ? prevNode.itemId : -1;
            node.reRollFlag = isRare && (pool.length > 1) && (node.itemId !== -1) && (node.itemId === prevItemId);
            node.useSeeds = node.reRollFlag ? 3 : 2;

            if (isRare && pool.length > 1) {
                 const reRollPool = pool.filter(id => id !== node.itemId);
                 if (reRollPool.length > 0) {
                     node.reRollSlot = node.seed3 % reRollPool.length;
                     node.reRollItemId = reRollPool[node.reRollSlot];
                     node.reRollItemName = itemMaster[node.reRollItemId]?.name || '---';
                 } else {
                     node.reRollItemId = -1; node.reRollItemName = '---';
                 }
                 const nextIdxRe = i + 3;
                 node.reRollNextAddress = getAddressString(nextIdxRe);
            } else {
                 node.reRollItemId = -1; node.reRollItemName = '---';
                 node.reRollNextAddress = '-';
            }
            
            Nodes.push(node);

            let lines = [];
            lines.push(`(番地) address[${node.index}]=${node.address}`);
            lines.push(`(レアリティ判定) rarity[${node.index}]=S1(${node.seed1})%10000=${node.seed1%10000}→${node.rarity.name}`);
            lines.push(`(確定枠レアリティ判定) rarityG[${node.index}]=S1(${node.seed1})%${node.gDivisor}=${node.gRoll}→${node.rarityGName}`);
            lines.push(`(スロット,ID,名称判定) slot[${node.index}]=S2(${node.seed2})%${node.poolSize}=${node.slot},ItemID[${node.index}]=${node.itemId},ItemName[${node.index}]=${node.itemName}`);
            
            if (node.rarityGId) {
                lines.push(`(確定枠スロット,ID,名称判定) slotG[${node.index}]=S2(${node.seed2})%${node.poolGSize}=${node.slotG},GID[${node.index}]=${node.itemGId},GName[${node.index}]=${node.itemGName}`);
            } else {
                lines.push(`(確定枠なし)`);
            }

            lines.push(`(レア被り判定,消費SEED数) ReRollFlag[${node.index}]=${node.reRollFlag},useSeeds[${node.index}]=${node.useSeeds}`);
            if (node.reRollItemId !== -1) {
                 lines.push(`(再抽選スロット,ID,名称判定) ReRollSlot[${node.index}]=S3(${node.seed3})%(${pool.length-1})=${node.reRollSlot},ReRollItemID[${node.index}]=${node.reRollItemId},ReRollItemName[${node.index}]=${node.reRollItemName}`);
                 lines.push(`(再抽選後の遷移先番地) ReRollNextAddress[${node.index}]=${node.reRollNextAddress}`);
            }
            detailsHtml += `<strong>No.${node.index}</strong><br>` + lines.join('<br>') + '<br><br>';
        }

        const highlightInfo = new Map(); 

        let singleRouteLog = '<h2>＜単発ルート＞</h2>';
        let sIdx = 1;
        let sLastItemId = initialLastRollId || -1;
        const ngVal = parseInt(initialNg, 10);
        const hasGuaranteed = !isNaN(ngVal);

        for (let roll = 1; roll <= tableRows; roll++) {
            if (sIdx > maxNodeIndex) break;
            const node = Nodes[sIdx - 1];
            const isGuaranteedRoll = hasGuaranteed && (roll >= ngVal) && ((roll - ngVal) % 10 === 0);
            
            singleRouteLog += `<strong>Roll${roll}</strong>${isGuaranteedRoll?'(guaranteed)':''}<br>`;
            
            if (isGuaranteedRoll) {
                const addressKey = node.address + 'G';
                singleRouteLog += `(番地) address[${sIdx}]=${addressKey}(${sIdx})<br>`;
                singleRouteLog += `(当該ロール使用Seed数) 2 (固定)<br><br>`;

                const info = highlightInfo.get(addressKey) || {};
                info.single = true;
                highlightInfo.set(addressKey, info);
                
                sLastItemId = node.itemGId;
                sIdx += 2; 
            } else {
                const isRare = (node.rarityId === 1);
                const poolSize = gacha.rarityItems[1] ? gacha.rarityItems[1].length : 0;
                const isMatch = (node.itemId !== -1 && node.itemId === sLastItemId);
                const reRollFlag = isRare && isMatch && poolSize > 1;
                
                singleRouteLog += `(番地) address[${sIdx}]=${node.address}(${sIdx})<br>`;
                singleRouteLog += `(当該Rollのレアリティ) rarity[${sIdx}]=${node.rarity.name}<br>`;
                singleRouteLog += `(当該Rollの通常抽選アイテムID) Item[${sIdx}]=${node.itemId}<br>`;
                singleRouteLog += `(直前ロールアイテムID) ${sLastItemId}<br>`;
                singleRouteLog += `(レア被り判定) SingleReRollFlag[${roll}]=${reRollFlag}<br>`;
                
                singleRouteLog += `(再抽選アイテムID)<br>`;
                if (reRollFlag) {
                    singleRouteLog += `SingleReRollFlag[${roll}]=True→ ReRollItemID[${sIdx}]=${node.reRollItemId}<br>`;
                } else {
                    singleRouteLog += `SingleReRollFlag[${roll}]=False→ null<br>`;
                }
                
                singleRouteLog += `(当該Roll最終抽選アイテムID)<br>`;
                const finalId = reRollFlag ? node.reRollItemId : node.itemId;
                singleRouteLog += `SingleItemID[${roll}]=${finalId}<br>`;
                
                const useSeeds = reRollFlag ? 3 : 2;
                singleRouteLog += `(当該ロール使用Seed数)<br>`;
                singleRouteLog += `SingleReRollFlag[${roll}]=${reRollFlag}→ ${useSeeds}<br>`;
                
                const nextIdx = sIdx + useSeeds;
                const nextAddr = getAddressString(nextIdx);
                singleRouteLog += `(遷移先番地)<br>`;
                singleRouteLog += `当該ロール使用Seed数${useSeeds} → 当該番地${sIdx}+${useSeeds}＝遷移先番地${nextIdx}（${nextAddr}）<br><br>`;
                
                const info = highlightInfo.get(node.address) || {};
                info.single = true;
                info.s_reRoll = reRollFlag;
                if (reRollFlag) {
                    info.s_normalName = node.itemName;
                    info.s_reRollName = node.reRollItemName;
                    info.s_nextAddr = nextAddr;
                }
                highlightInfo.set(node.address, info);

                sLastItemId = finalId;
                sIdx += useSeeds;
            }
        }

        let tenPullRouteLog = '';
        if (hasGuaranteed) {
            tenPullRouteLog += '<h2>＜10連ルート＞</h2>';
            let tIdx = 1;
            let tLastItemId = initialLastRollId || -1;

            for (let roll = 1; roll <= tableRows; roll++) {
                if (tIdx > maxNodeIndex) break;
                
                const isCycleStart = (roll - 1) % 10 === 0;
                if (isCycleStart) {
                    const nodeG = Nodes[tIdx - 1];
                    const cycleNum = Math.floor((roll - 1) / 10) + 1;
                    tenPullRouteLog += `<strong>${cycleNum}サイクル目</strong><br>`;
                    tenPullRouteLog += `(確定枠レアリティ判定(初めの１SEEDを消費)) rarityG[${tIdx}]→${nodeG.rarityGName}<br><br>`;
                    tIdx++;
                }
                
                const node = Nodes[tIdx - 1];
                const isGuaranteedRoll = (roll >= ngVal) && ((roll - ngVal) % 10 === 0);

                tenPullRouteLog += `<strong>Roll${roll}</strong><br>`;

                if (isGuaranteedRoll) {
                    const gNode = Nodes[tIdx - 2];
                    const addressKey = gNode.address + 'G';
                    tenPullRouteLog += `(番地) address[${tIdx-1}]=${addressKey}(${tIdx-1})<br>`;
                    tenPullRouteLog += `(消費SEED数(確定枠スロット判定)) 1<br><br>`;
                    
                    const info = highlightInfo.get(addressKey) || {};
                    info.ten = true;
                    highlightInfo.set(addressKey, info);
                    tLastItemId = gNode.itemGId;
                    tIdx += 1;
                } else {
                    const isRare = (node.rarityId === 1);
                    const poolSize = gacha.rarityItems[1] ? gacha.rarityItems[1].length : 0;
                    const isMatch = (node.itemId !== -1 && node.itemId === tLastItemId);
                    const reRollFlag = isRare && isMatch && poolSize > 1;

                    tenPullRouteLog += `(番地) address[${tIdx}]=${node.address}(${tIdx})<br>`;
                    tenPullRouteLog += `(当該Rollのレアリティ) rarity[${tIdx}]=${node.rarity.name}<br>`;
                    tenPullRouteLog += `(当該Rollの通常抽選アイテムID) Item[${tIdx}]=${node.itemId}<br>`;
                    tenPullRouteLog += `(直前ロールアイテムID) ${tLastItemId}<br>`;
                    tenPullRouteLog += `(レア被り判定) TenPullReRollFlag[${roll}]=${reRollFlag}<br>`;
                    
                    const finalId = reRollFlag ? node.reRollItemId : node.itemId;
                    tenPullRouteLog += `TenPullItemID[${roll}]=${finalId}<br>`;
                    
                    const useSeeds = reRollFlag ? 3 : 2;
                    tenPullRouteLog += `(当該ロール使用Seed数) ${useSeeds}<br>`;
                    
                    const nextIdx = tIdx + useSeeds;
                    const nextAddr = getAddressString(nextIdx);
                    tenPullRouteLog += `(遷移先番地) ${nextIdx}（${nextAddr}）<br><br>`;

                    const info = highlightInfo.get(node.address) || {};
                    info.ten = true;
                    info.t_reRoll = reRollFlag;
                    if (reRollFlag) {
                        info.t_normalName = node.itemName;
                        info.t_reRollName = node.reRollItemName;
                        info.t_nextAddr = nextAddr;
                    }
                    highlightInfo.set(node.address, info);

                    tLastItemId = finalId;
                    tIdx += useSeeds;
                }
            }
        }

        detailsHtml += singleRouteLog;
        detailsHtml += tenPullRouteLog;

        let table = `<table style="table-layout: fixed;" class="${currentHighlightMode === 'single' ? 'mode-single' : (currentHighlightMode === 'multi' ? 'mode-multi' : '')}"><thead>`;
        table += `<tr><th id="forceRerollToggle" class="col-no" style="cursor: pointer;">${forceRerollMode ? '☑' : '□'}</th><th>A</th><th>AG</th><th>B</th><th>BG</th></tr>`;
        table += '</thead><tbody>';

        for (let r = 1; r <= tableRows; r++) {
            const nodeIdxA = (r - 1) * 2 + 1;
            const nodeIdxB = (r - 1) * 2 + 2;
            const nodeA = Nodes[nodeIdxA - 1];
            const nodeB = Nodes[nodeIdxB - 1];

            if (!nodeA || !nodeB) break;

            table += `<tr><td class="col-no">${r}</td>`;

            const renderCell = (node, suffix) => {
                const address = node.address + suffix;
                const info = highlightInfo.get(address);
                const isGuaranteed = (suffix === 'G');
                const itemId = isGuaranteed ? node.itemGId : node.itemId;
                const itemName = isGuaranteed ? node.itemGName : node.itemName;
                const itemRarity = itemMaster[itemId]?.rarity;
                
                let cellContent = '---';
                if (itemId !== -1) {
                    const href = generateItemLink(node.seed2, itemId, initialNg, r, true);
                    let nameHtml = `<a href="${href}">${itemName}</a>`;
                    
                    let cssClass = '';
                    if (!isGuaranteed) {
                        if (itemRarity === 4) cssClass = 'legendItem-text';
                        else if (itemRarity >= 3) cssClass = 'featuredItem-text';
                    }
                    if (cssClass) nameHtml = `<span class="${cssClass}">${nameHtml}</span>`;
                    
                    let showReRoll = false;
                    let rrNextAddr = '';
                    let rrName = '';
                    let normName = itemName;

                    if (info && !isGuaranteed) {
                        if (info.single && info.s_reRoll) {
                            showReRoll = true;
                            rrNextAddr = info.s_nextAddr;
                            rrName = info.s_reRollName;
                            normName = info.s_normalName;
                        } else if (info.ten && info.t_reRoll) {
                            showReRoll = true;
                            rrNextAddr = info.t_nextAddr;
                            rrName = info.t_reRollName;
                            normName = info.t_normalName;
                        }
                    } 
                    else if (!isGuaranteed && (node.reRollFlag || (forceRerollMode && node.rarityId === 1 && node.poolSize > 1))) {
                        showReRoll = true;
                        rrNextAddr = node.reRollNextAddress;
                        rrName = node.reRollItemName;
                        normName = node.itemName;
                    }

                    if (showReRoll) {
                         const hrefRe = generateItemLink(node.seed3, node.reRollItemId, initialNg, r, true);
                         let rrNameHtml = `<a href="${hrefRe}">${rrName}</a>`;
                         let rrCssClass = '';
                         const rrRarity = itemMaster[node.reRollItemId]?.rarity;
                         if (rrRarity === 4) rrCssClass = 'legendItem-text';
                         else if (rrRarity >= 3) rrCssClass = 'featuredItem-text';
                         if (rrCssClass) rrNameHtml = `<span class="${rrCssClass}">${rrNameHtml}</span>`;
                         const hrefNorm = generateItemLink(node.seed2, node.itemId, initialNg, r, true);
                         let normNameHtml = `<a href="${hrefNorm}">${normName}</a>`;
                         if (cssClass) normNameHtml = `<span class="${cssClass}">${normNameHtml}</span>`;
                         cellContent = `${normNameHtml}<br>${rrNextAddr})${rrNameHtml}`;
                    } else {
                         cellContent = nameHtml;
                    }
                }
                let cls = '';
                if (info) {
                    if (info.single && info.ten) cls = 'highlight-roll-overlap';
                    else if (info.single) cls = 'highlight-roll';
                    else if (info.ten) cls = 'highlight-roll-10pull';
                }
                return { html: `<td${cls ? ' class="'+cls+'"' : ''}>${cellContent}</td>` };
            };

            table += renderCell(nodeA, '').html;
            table += renderCell(nodeA, 'G').html;
            table += renderCell(nodeB, '').html;
            table += renderCell(nodeB, 'G').html;
            table += '</tr>';
        }
        table += '</tbody></table>';

        document.getElementById('result-table-container').innerHTML = table;
        const detailsDiv = document.getElementById('calculation-details');
        detailsDiv.innerHTML = detailsHtml;
        const detailsControls = document.getElementById('details-controls');
        const toggleBtn = document.getElementById('toggleDetailsBtn');
        const scrollButtons = detailsControls.querySelector('.scroll-buttons');
        detailsControls.style.display = 'flex';
        toggleBtn.onclick = () => {
            if (detailsDiv.style.display === 'none') {
                detailsDiv.style.display = 'block';
                scrollButtons.style.display = 'flex';
                toggleBtn.textContent = '計算過程を非表示';
            } else {
                detailsDiv.style.display = 'none';
                scrollButtons.style.display = 'none';
                toggleBtn.textContent = '計算過程を表示';
            }
        };
    }

    function createAndDisplayUncompletedSeedView(initialSeed, gacha, tableRows, thresholds, initialLastRollId, displaySeed, params) {
        const SEED = [initialSeed];
        const maxSeedsNeeded = tableRows * 10 + 1000; 
        for (let i = 1; i < maxSeedsNeeded; i++) {
            SEED[i] = xorshift32(SEED[i - 1]);
        }

        const getRarityFromRoll = (roll) => {
            if (roll < thresholds['0']) return { id: 0, name: 'ノーマル' };
            if (roll < thresholds['1']) return { id: 1, name: 'レア' };
            if (roll < thresholds['2']) return { id: 2, name: '激レア' };
            if (roll < thresholds['3']) return { id: 3, name: '超激レア' };
            return { id: 4, name: '伝説レア' };
        };
        const getAddressString = (n) => {
            if (n <= 0) return '';
            const zeroBasedIndex = n - 1;
            const col_char = String.fromCharCode('A'.charCodeAt(0) + (zeroBasedIndex % 3));
            const row_num = Math.floor(zeroBasedIndex / 3) + 1;
            return `${row_num}${col_char}`;
        };
        
        // --- 1. 全ノード事前計算 ---
        const Nodes = [];
        const maxNodes = tableRows * 3 + 20;
        let detailsHtml = generateMasterInfoHtml(gacha);
        detailsHtml += '<h2>＜ノード計算詳細 (No.1～)＞</h2>';
        
        for (let i = 1; i <= maxNodes; i++) {
            const seedStartIdx = (i - 1) * 3 + 1;
            const s1 = SEED[seedStartIdx];     
            const s2 = SEED[seedStartIdx + 1]; 
            const s3 = SEED[seedStartIdx + 2]; 
            const s4 = SEED[seedStartIdx + 3]; 

            const node = {
                index: i,
                address: getAddressString(i),
                seed1: s1, seed2: s2, seed3: s3, seed4: s4,
                isFeatured: (s1 % 10000) < gacha.featuredItemRate
            };

            const nextIdxFeatured = i + 1;
            node.featuredNextAddress = getAddressString(nextIdxFeatured);

            node.rarity = getRarityFromRoll(s2 % 10000);
            node.rarityId = node.rarity.id;

            const pool = gacha.rarityItems[node.rarityId] || [];
            node.poolSize = pool.length;
            if (pool.length > 0) {
                node.slot = s3 % pool.length;
                node.itemId = pool[node.slot];
                node.itemName = itemMaster[node.itemId]?.name || '---';
            } else {
                node.slot = 0; node.itemId = -1; node.itemName = '---';
            }
            
            const prevNodeIndex = i - 3;
            const prevNode = (prevNodeIndex >= 1) ? Nodes[prevNodeIndex - 1] : null;
            const prevItemId = prevNode ? prevNode.itemId : -1;
            
            const isRare = (node.rarityId === 1);
            node.reRollFlag = isRare && (pool.length > 1) && (node.itemId !== -1) && (node.itemId === prevItemId);
            
            if (isRare && pool.length > 1) {
                const reRollPool = pool.filter(id => id !== node.itemId);
                if (reRollPool.length > 0) {
                    node.reRollSlot = s4 % reRollPool.length;
                    node.reRollItemId = reRollPool[node.reRollSlot];
                    node.reRollItemName = itemMaster[node.reRollItemId]?.name || '---';
                } else {
                    node.reRollItemId = -1; node.reRollItemName = '---';
                }
            } else {
                node.reRollItemId = -1; node.reRollItemName = '---';
            }

            if (node.isFeatured) node.useSeeds = 1;
            else node.useSeeds = node.reRollFlag ? 4 : 3;

            node.reRollNextAddress = getAddressString(i + node.useSeeds);
            Nodes.push(node);

            let lines = [];
            lines.push(`(番地) ${node.index}(${node.address})`);
            lines.push(`(目玉) isFeatured[${node.index}]=(S1(${node.seed1})%10000(=${node.seed1%10000})<${gacha.featuredItemRate})=${node.isFeatured}`);
            if (node.isFeatured) {
                lines.push(`(目玉該当時の遷移先番地) FeaturedNextAddress[${node.index}]=${node.featuredNextAddress}`);
            } else {
                lines.push(`(レアリティ) rarity[${node.index}]=S2(${node.seed2})%10000(=${node.seed2%10000})→${node.rarity.name}`);
                lines.push(`(スロット,ID,名称) slot[${node.index}]=S3(${node.seed3})%${node.poolSize}=${node.slot},ItemID[${node.index}]=${node.itemId},ItemName[${node.index}]=${node.itemName}`);
                lines.push(`(レア被り判定,消費SEED数) ReRollFlag[${node.index}]=${node.reRollFlag},useSeeds[${node.index}]=${node.useSeeds}`);
                
                if (node.reRollItemId !== -1) {
                     lines.push(`(再抽選スロット,ID,名称) ReRollSlot[${node.index}]=S4(${node.seed4})%(${pool.length-1})=${node.reRollSlot},ReRollItemID[${node.index}]=${node.reRollItemId},ReRollItemName[${node.index}]=${node.reRollItemName}`);
                     lines.push(`(再抽選後の遷移先番地) ReRollNextAddress[${node.index}]=${node.reRollNextAddress}`);
                }
            }
            detailsHtml += `<strong>No.${node.index}</strong><br>` + lines.join('<br>') + '<br><br>';
        }

        // --- 2. 単発ルート計算 (Single Route Log) ---
        let singleRouteLog = '<h2>＜単発ルート＞</h2>';
        let sIdx = 1; 
        let sLastItemId = initialLastRollId || -1;
        let singleRoutePath = new Set(); // ハイライト用
        let ngVal = parseInt(params.get('ng'), 10);
        const hasGuaranteed = !isNaN(ngVal);
        let currentNg = hasGuaranteed ? ngVal : -1;
        const guaranteedCycle = gacha.guaranteedCycle || 30;

        for (let roll = 1; roll <= tableRows; roll++) {
            if (sIdx > maxNodes) break;
            const node = Nodes[sIdx - 1];
            singleRoutePath.add(sIdx);

            singleRouteLog += `<strong>Roll${roll}</strong><br>`;
            singleRouteLog += `(番地) ${sIdx}(${node.address})<br>`;
            singleRouteLog += `(目玉) isFeatured[${sIdx}]=${node.isFeatured}<br>`;

            let usedSeedsForThisRoll = 0;

            if (node.isFeatured) {
                singleRouteLog += `(次Rollのレア被り判定に用いるアイテムID) ${sLastItemId} のまま<br>`;
                usedSeedsForThisRoll = 1;
            } else {
                singleRouteLog += `(レアリティ) rarity[${sIdx}]=${node.rarity.name}<br>`;
                singleRouteLog += `(アイテムID) Item[${sIdx}]=${node.itemId}<br>`;
                singleRouteLog += `(直前ロールアイテムID) ${sLastItemId}<br>`;
                
                const isRare = (node.rarityId === 1);
                const poolSize = gacha.rarityItems[1] ? gacha.rarityItems[1].length : 0;
                const isMatch = (node.itemId !== -1 && node.itemId === sLastItemId);
                const reRollFlag = isRare && isMatch && poolSize > 1;
                
                singleRouteLog += `(レア被り) SingleReRollFlag[${sIdx}]=${reRollFlag}<br>`;
                
                let finalId = node.itemId;
                if (reRollFlag) {
                    singleRouteLog += `(再抽選アイテムID) SingleReRollFlag[${sIdx}]=True → ReRollItemID[${sIdx}]=${node.reRollItemId}<br>`;
                    finalId = node.reRollItemId;
                } else {
                    // 変更点: Falseの時は表示しない、Trueのときのみ表示とのことだが、
                    // 以前のロジックでは「SingleReRollFlag[1]=False → null」と書いてあったが、
                    // リクエストでは「SingleReRollFlag[1]=Trueのときのみ表示」とあるので非表示に
                    // singleRouteLog += `(再抽選アイテムID) SingleReRollFlag[${roll}]=False → null<br>`;
                }
                
                singleRouteLog += `(次Rollのレア被り判定に用いるアイテムID) SingleItemID[${roll}]=${finalId}<br>`;
                sLastItemId = finalId; 
                
                usedSeedsForThisRoll = reRollFlag ? 4 : 3;
                singleRouteLog += `(当該ロール使用Seed数) ${usedSeedsForThisRoll}<br>`;
            }

            const nextIdx = sIdx + usedSeedsForThisRoll;
            const nextAddr = getAddressString(nextIdx);
            singleRouteLog += `(遷移先番地) 番地+使用Seed数=${sIdx}+${usedSeedsForThisRoll}＝${nextIdx}（${nextAddr}）<br>`;
            
            // Next Guaranteed Calculation
            if (hasGuaranteed) {
                let oldNg = currentNg;
                currentNg = currentNg - 1;
                if (currentNg <= 0) {
                    currentNg = guaranteedCycle;
                }
                singleRouteLog += `(next guaranteed更新)${oldNg}→${currentNg}<br>`;
            }
            singleRouteLog += '<br>';
            sIdx = nextIdx;
        }
        detailsHtml += singleRouteLog;

        // --- 3. 10連ルート計算 (10-Pull Route Log) ---
        let tenPullRouteLog = '<h2>＜10連ルート＞</h2>';
        tenPullRouteLog += '<p>(※1サイクル目のみ表示。NextGuaranteedに該当する場合は「目玉(確定)」になるので、それ以外のRollを判定します。未コンプ時の10連は、まずNextGuaranteedを除く9～10個分のSEEDで目玉判定を一括で行い、その後残りのSEEDで中身を抽選します。)</p>';
        
        let tpNgVal = parseInt(params.get('ng'), 10);
        if (isNaN(tpNgVal)) tpNgVal = -999;

        const featuredFlags = [];
        let batchLog = '(目玉一括判定)<br>';
        
        for (let i = 1; i <= 10; i++) {
            const checkSeed = SEED[i];
            let isGuaranteedSlot = (i === tpNgVal);
            
            if (isGuaranteedSlot) {
                batchLog += `Roll${i}：NextGuaranteed!<br>`;
                featuredFlags.push({ isFeatured: false, isGuaranteed: true }); // Guaranteed overrides featured check behavior
            } else {
                const isFeatured = (checkSeed % 10000) < gacha.featuredItemRate;
                batchLog += `Roll${i}：isFeatured [${i- (featuredFlags.filter(f=>f.isGuaranteed).length)}]= ${isFeatured}<br>`;
                featuredFlags.push({ isFeatured: isFeatured, isGuaranteed: false });
            }
        }
        tenPullRouteLog += batchLog + '<br>続きのSEEDから順次SEEDを消費して、レアリティ判定、スロット判定、再抽選スロット判定を行う<br><br>';

        let currentSeedIndex = 11; 
        let tpLastItemId = initialLastRollId || -1;
        let tenPullResults = []; // G列表示用テキスト配列

        for (let r = 1; r <= 10; r++) {
            const flagData = featuredFlags[r-1];
            tenPullRouteLog += `<strong>Roll${r}</strong><br>`;
            
            if (flagData.isGuaranteed) {
                 tenPullRouteLog += `目玉(確定)<br><br>`;
                 tenPullResults.push({text: '目玉(確定)', isFeatured: true});
                 currentSeedIndex++; // 消費不明だがとりあえず進める
                 tpLastItemId = -1;
            } else if (flagData.isFeatured) {
                 tenPullRouteLog += `目玉<br><br>`;
                 tenPullResults.push({text: '目玉', isFeatured: true});
                 // No extra seed consumed
            } else {
                 const s_rarity = SEED[currentSeedIndex];
                 const s_slot = SEED[currentSeedIndex + 1];
                 const s_reroll = SEED[currentSeedIndex + 2];
                 
                 const rarityObj = getRarityFromRoll(s_rarity % 10000);
                 tenPullRouteLog += `(レアリティ) TenPullRarity[${r}]=S${currentSeedIndex}(${s_rarity})%10000(=${s_rarity%10000})→${rarityObj.name}<br>`;
                 
                 const pool = gacha.rarityItems[rarityObj.id] || [];
                 let itemVal = -1;
                 let itemName = '---';
                 let slotInfo = '';
                 if (pool.length > 0) {
                     const slot = s_slot % pool.length;
                     itemVal = pool[slot];
                     itemName = itemMaster[itemVal]?.name || '---';
                     slotInfo = `TenPullSlot[${r}]=S${currentSeedIndex+1}(${s_slot})%${pool.length}=${slot},TenPullItemID[${r}]=${itemVal},Name=${itemName}`;
                 } else {
                     slotInfo = 'Pool Empty';
                 }
                 tenPullRouteLog += `(スロット,ID,名称) ${slotInfo}<br>`;
                 tenPullRouteLog += `(直前ロールアイテムID) ${tpLastItemId}<br>`;

                 const isRare = (rarityObj.id === 1);
                 const isDupe = (itemVal !== -1 && itemVal === tpLastItemId);
                 const reRoll = isRare && isDupe && pool.length > 1;
                 
                 tenPullRouteLog += `(レア被り判定) TenPullReRollFlag[${r}]=${reRoll}<br>`;
                 
                 let finalName = itemName;
                 if (reRoll) {
                     const rePool = pool.filter(id => id !== itemVal);
                     const reSlot = s_reroll % rePool.length;
                     const reItem = rePool[reSlot];
                     const reName = itemMaster[reItem]?.name || '---';
                     tenPullRouteLog += `(再抽選スロット,ID,名称) TenPullReRollSlot[${r}]=S${currentSeedIndex+2}(${s_reroll})... ID=${reItem},Name=${reName}<br>`;
                     tpLastItemId = reItem;
                     currentSeedIndex += 3;
                     finalName = `${itemName}<br>(再)${reName}`;
                 } else {
                     tpLastItemId = itemVal;
                     currentSeedIndex += 2;
                 }
                 tenPullResults.push({text: finalName, isFeatured: false});
                 tenPullRouteLog += '<br>';
            }
        }
        detailsHtml += tenPullRouteLog;

        // --- 4. 表の構築 ---
        let table = '<table style="table-layout: fixed;"><thead>';
        let header1 = `<tr><th rowspan="${displaySeed === '1' ? 2 : 1}" id="forceRerollToggle" class="col-no" style="cursor: pointer;">${forceRerollMode ? '☑' : '□'}</th>`;
        let header2 = '<tr>';
        if (displaySeed === '1') {
            header1 += '<th colspan="5">A</th><th colspan="5">B</th><th colspan="5">C</th><th colspan="5">G</th>';
            const subHeaders = ['S1<br>Feat', 'S2<br>Rare', 'S3<br>Slot', 'S4<br>Re', 'Item'];
            for(let i=0; i<4; i++) header2 += subHeaders.map(h => `<th>${h}</th>`).join('');
        } else {
            header1 += '<th>A</th><th>B</th><th>C</th><th>G</th>';
        }
        header1 += '</tr>';
        if (displaySeed === '1') { header2 += '</tr>'; table += header1 + header2; } else { table += header1; }
        table += '</thead><tbody>';
        
        for (let r = 0; r < tableRows; r++) {
            table += `<tr><td class="col-no">${r + 1}</td>`;
            
            const nodeIndices = [r*3 + 1, r*3 + 2, r*3 + 3];
            
            nodeIndices.forEach(idx => {
                const node = Nodes[idx - 1];
                if (!node) {
                     table += displaySeed === '1' ? '<td colspan="5"></td>' : '<td></td>';
                     return;
                }
                
                let cellHtml = '';
                let sub5 = ''; 
                
                if (node.isFeatured) {
                    const href = generateItemLink(node.seed1, -2, params.get('ng'), 0, false);
                    sub5 = `${node.featuredNextAddress})<span class="featuredItem-text"><a href="${href}">目玉</a></span>`;
                } else {
                    const href = generateItemLink(node.seed3, node.itemId, params.get('ng'), 0, false);
                    let nameHtml = `<a href="${href}">${node.itemName}</a>`;
                    if (itemMaster[node.itemId]?.rarity >= 3) {
                         nameHtml = `<span class="featuredItem-text">${nameHtml}</span>`;
                    }
                    
                    let reRollHtml = '';
                    if (node.reRollItemId !== -1) {
                        const rrHref = generateItemLink(node.seed4, node.reRollItemId, params.get('ng'), 0, false);
                        let rrName = `<a href="${rrHref}">${node.reRollItemName}</a>`;
                        if (itemMaster[node.reRollItemId]?.rarity >= 3) rrName = `<span class="featuredItem-text">${rrName}</span>`;
                        reRollHtml = `<br>${node.reRollNextAddress})${rrName}`;
                    }
                    sub5 = nameHtml + reRollHtml;
                }

                // ハイライト判定: 単発ルートに含まれるノードか？
                let cls = '';
                if (singleRoutePath.has(idx)) {
                    cls = 'highlight-roll';
                }

                if (displaySeed === '1') {
                    const sub1 = `(S${(idx-1)*3+1})${node.seed1}<br>${node.seed1%10000}<br>${node.isFeatured}`;
                    const sub2 = `(S${(idx-1)*3+2})${node.seed2}<br>${node.seed2%10000}<br>${node.rarity.name}`;
                    const sub3 = `(S${(idx-1)*3+3})${node.seed3}<br>${node.poolSize}<br>${node.slot}`;
                    let sub4 = '---';
                    if (!node.isFeatured && node.reRollItemId !== -1) {
                        sub4 = `(S${(idx-1)*3+4})${node.seed4}<br>ReRoll`;
                    }
                    cellHtml = `<td${cls ? ' class="'+cls+'"' : ''}>${sub1}</td><td${cls ? ' class="'+cls+'"' : ''}>${sub2}</td><td${cls ? ' class="'+cls+'"' : ''}>${sub3}</td><td${cls ? ' class="'+cls+'"' : ''}>${sub4}</td><td${cls ? ' class="'+cls+'"' : ''}>${sub5}</td>`;
                } else {
                    cellHtml = `<td${cls ? ' class="'+cls+'"' : ''}>${sub5}</td>`;
                }
                table += cellHtml;
            });

            // G Column (10連結果表示エリア)
            let gContent = '---';
            let gCls = '';
            if (r < 10 && tenPullResults[r]) {
                gContent = tenPullResults[r].text;
                if (tenPullResults[r].isFeatured) {
                    gContent = `<span class="featuredItem-text">${gContent}</span>`;
                }
                gCls = 'highlight-roll-10pull';
            }

            if (displaySeed === '1') {
                table += `<td colspan="5" class="${gCls}">${gContent}</td>`;
            } else {
                table += `<td class="${gCls}">${gContent}</td>`;
            }
            table += '</tr>';
        }
        table += '</tbody></table>';
        
        document.getElementById('result-table-container').innerHTML = table;
        
        // Setup Details
        const detailsDiv = document.getElementById('calculation-details');
        detailsDiv.innerHTML = detailsHtml;
        const detailsControls = document.getElementById('details-controls');
        const toggleBtn = document.getElementById('toggleDetailsBtn');
        const scrollButtons = detailsControls.querySelector('.scroll-buttons');
        
        detailsControls.style.display = 'flex';
        toggleBtn.style.display = 'inline-block'; 

        toggleBtn.onclick = () => {
            if (detailsDiv.style.display === 'none') {
                detailsDiv.style.display = 'block';
                scrollButtons.style.display = 'flex';
                toggleBtn.textContent = '計算過程を非表示';
            } else {
                detailsDiv.style.display = 'none';
                scrollButtons.style.display = 'none';
                toggleBtn.textContent = '計算過程を表示';
            }
        };
    }

    // --- ディスパッチャー & メイン ---
    let activeGachaId;
    let forceRerollMode = false;

    function runSimulationAndDisplay(options = {}) {
        const { hideSeedInput = false, uiOverrides = {} } = options;
        const params = new URLSearchParams(window.location.search);
        const latestGachaId = Object.keys(gachaMaster).reduce((a, b) => parseInt(a) > parseInt(b) ? a : b);
        
        const p = {};
        ['gacha', 'seed', 'ng', 'fs', 'lr', 'comp', 'tx', 'roll', 'displaySeed'].forEach(k => {
            p[k] = params.get(k);
        });
        if (!p.gacha || !gachaMaster[p.gacha]) p.gacha = latestGachaId;
        if (!p.seed) p.seed = DEFAULT_PARAMS.seed;
        if (!p.roll) p.roll = DEFAULT_PARAMS.roll;
        if (!p.ng) p.ng = DEFAULT_PARAMS.ng;
        if (p.tx === 'true') p.tx = '1'; else if (p.tx === 'false') p.tx = '0';
        if (!p.tx && DEFAULT_PARAMS.tx) p.tx = '1';
        if (p.comp === '1') p.comp = 'true'; else if (p.comp === '0') p.comp = 'false';
        
        if (uiOverrides.seed !== undefined) p.seed = uiOverrides.seed;
        if (uiOverrides.guaranteedRolls !== undefined) p.ng = uiOverrides.guaranteedRolls;
        if (uiOverrides.featuredStock !== undefined) p.fs = uiOverrides.featuredStock;
        if (uiOverrides.isComplete !== undefined) p.comp = uiOverrides.isComplete ? 'true' : 'false';
        
        activeGachaId = p.gacha;
        const gacha = gachaMaster[p.gacha];
        
        document.getElementById('seedInput').value = p.seed;
        const isComplete = (p.comp === 'true');
        document.getElementById('featuredCompleteCheckbox').checked = isComplete;
        
        if (gacha.featuredItemStock === 0) {
            document.getElementById('featuredCompleteCheckbox').checked = true;
            document.getElementById('featuredCompleteCheckbox').parentElement.classList.add('hidden-control');
        } else {
            document.getElementById('featuredCompleteCheckbox').parentElement.classList.remove('hidden-control');
        }
        
        const isComp = document.getElementById('featuredCompleteCheckbox').checked;
        const stockControl = document.getElementById('stockControl');
        const guaranteedControl = document.getElementById('guaranteedControl');
        const legendDisplay = document.getElementById('legendDisplay');

        populateFeaturedStockInput(p.gacha, p.fs);

        // 凡例表示制御
        const legendCommon = document.getElementById('legendCommon');
        if (isComp) {
            stockControl.classList.add('hidden-control');
            if (gacha.uberGuaranteedFlag || gacha.legendGuaranteedFlag) {
                guaranteedControl.classList.remove('hidden-control');
                legendDisplay.classList.remove('hidden-control');
                populateGuaranteedRolls(10, p.ng);
            } else {
                guaranteedControl.classList.add('hidden-control');
                legendDisplay.classList.add('hidden-control');
            }
            legendCommon.style.display = 'inline-block';
        } else {
            stockControl.classList.remove('hidden-control');
            guaranteedControl.classList.remove('hidden-control');
            legendDisplay.classList.remove('hidden-control');
            populateGuaranteedRolls(gacha.guaranteedCycle || 30, p.ng);
            legendCommon.style.display = 'none'; // 未コンプ時は共通ルート非表示
        }

        const lastRollDisplay = document.getElementById('lastRollDisplay');
        if (p.lr && itemMaster[p.lr]) {
            lastRollDisplay.textContent = `LastRoll: ${itemMaster[p.lr].name}`;
        } else {
            lastRollDisplay.textContent = '';
        }

        const newParams = {
            gacha: p.gacha, seed: p.seed, ng: p.ng, fs: p.fs, lr: p.lr,
            comp: isComp ? 'true' : 'false',
            tx: (p.tx === '1' || (!hideSeedInput && document.getElementById('seedRow').classList.contains('hidden-control') === false)) ? '1' : '0',
            roll: p.roll, displaySeed: p.displaySeed
        };
        // リンククリック等でSeed入力表示状態を維持するためのロジック修正
        if (!hideSeedInput && document.getElementById('seedRow').style.display === 'flex') newParams.tx = '1';

        const newQuery = generateUrlQuery(newParams);
        window.history.replaceState({ path: newQuery }, '', `${window.location.pathname}${newQuery}`);

        const seedValue = parseInt(p.seed, 10);
        const lastRollId = p.lr ? parseInt(p.lr, 10) : null;
        const rows = parseInt(p.roll, 10);
        const thresholds = {
            '0': gacha.rarityRates['0'],
            '1': gacha.rarityRates['0'] + gacha.rarityRates['1'],
            '2': gacha.rarityRates['0'] + gacha.rarityRates['1'] + gacha.rarityRates['2'],
            '3': gacha.rarityRates['0'] + gacha.rarityRates['1'] + gacha.rarityRates['2'] + gacha.rarityRates['3'],
            '4': 10000
        };

        if (isComp) {
            createAndDisplayCompletedSeedView(seedValue, gacha, rows, thresholds, lastRollId, p.displaySeed, new URLSearchParams(newQuery), p.ng);
        } else {
            createAndDisplayUncompletedSeedView(seedValue, gacha, rows, thresholds, lastRollId, p.displaySeed, new URLSearchParams(newQuery));
        }
    }

    function populateGuaranteedRolls(max, currentVal) {
        const input = document.getElementById('guaranteedRollsInput');
        input.innerHTML = '';
        const unsetOption = document.createElement('option');
        unsetOption.value = 'none'; unsetOption.textContent = '未設定'; input.appendChild(unsetOption);
        for (let i = 1; i <= max; i++) {
            const option = document.createElement('option'); option.value = i; option.textContent = i; input.appendChild(option);
        }
        if (currentVal && input.querySelector(`option[value="${currentVal}"]`)) {
            input.value = currentVal;
        } else {
            input.value = 'none';
        }
    }
    function populateFeaturedStockInput(gachaId, preferredValue) {
        const gacha = gachaMaster[gachaId];
        const input = document.getElementById('featuredStockInput');
        if (!gacha) return;
        input.innerHTML = '';
        const unsetOption = document.createElement('option');
        unsetOption.value = 'none'; unsetOption.textContent = '-'; input.appendChild(unsetOption);
        for (let i = 1; i <= gacha.featuredItemStock; i++) {
            const option = document.createElement('option'); option.value = i; option.textContent = i; input.appendChild(option);
        }
        if (preferredValue && preferredValue !== 'none' && input.querySelector(`option[value="${preferredValue}"]`)) {
            input.value = preferredValue;
        } else {
            input.value = 'none';
        }
    }

    function generateItemLink(newSeed, newItemId, initialInputNg, rollNumberInSequence, isCompleted) {
        const currentParams = new URLSearchParams(window.location.search);
        const paramsForQuery = {};
        for (const [key, value] of currentParams.entries()) paramsForQuery[key] = value;
        if (!paramsForQuery.gacha) paramsForQuery.gacha = activeGachaId;

        paramsForQuery.seed = newSeed;
        if (newItemId !== undefined) paramsForQuery.lr = newItemId;

        const initialInputNgInt = parseInt(initialInputNg, 10);
        if (initialInputNg !== 'none' && !isNaN(initialInputNgInt) && rollNumberInSequence) {
            if (isCompleted) {
                const rollInCycle = (rollNumberInSequence - 1) % 10;
                let ngValue = initialInputNgInt - 1 - rollInCycle;
                if (ngValue <= 0) ngValue += 10;
                paramsForQuery.ng = ngValue.toString();
            } else {
                const gacha = gachaMaster[activeGachaId];
                const periodicity = gacha.guaranteedCycle || 30;
                // 未コンプ時の更新ロジック: rollNumberInSequence回分進める
                // 単発の場合、1回ずつ消費されると仮定して計算
                let ngValue = initialInputNgInt;
                // 単発の場合、1回引くとNGは1減る（ただしサイクルで戻る）
                // 実際にはリンク先は「1回引いた後」の状態なので、1減らす
                ngValue = ngValue - 1;
                if (ngValue <= 0) ngValue = periodicity;
                paramsForQuery.ng = ngValue.toString();
            }
        } else {
            paramsForQuery.ng = 'none';
        }
        return generateUrlQuery(paramsForQuery);
    }
    
    function toggleSeedInput() {
        const seedRow = document.getElementById('seedRow');
        const linkContainer = document.getElementById('seedLinkContainer');
        if (seedRow.classList.contains('hidden-control')) {
            seedRow.classList.remove('hidden-control');
            // linkContainer.classList.add('hidden-control'); // リンクは表示したままにする（トグル動作のため）
        } else {
            seedRow.classList.add('hidden-control');
            // linkContainer.classList.remove('hidden-control');
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        setupGachaRarityItems();
        document.getElementById('executeButton').addEventListener('click', () => runSimulationAndDisplay({ hideSeedInput: true, uiOverrides: { seed: document.getElementById('seedInput').value } }));
        document.getElementById('guaranteedRollsInput').addEventListener('change', (e) => runSimulationAndDisplay({ uiOverrides: { guaranteedRolls: e.target.value } }));
        document.getElementById('featuredStockInput').addEventListener('change', (e) => runSimulationAndDisplay({ uiOverrides: { featuredStock: e.target.value } }));
        document.getElementById('featuredCompleteCheckbox').addEventListener('change', () => runSimulationAndDisplay({ uiOverrides: { isComplete: document.getElementById('featuredCompleteCheckbox').checked } }));
        document.getElementById('copySeedLink').addEventListener('click', (event) => {
            event.preventDefault();
            const seedToCopy = new URLSearchParams(window.location.search).get('seed');
            if (seedToCopy && navigator.clipboard) {
                navigator.clipboard.writeText(seedToCopy).then(() => {
                    const originalText = event.target.textContent;
                    event.target.textContent = 'Copied!';
                    setTimeout(() => { event.target.textContent = originalText; }, 1500);
                });
            }
        });
        document.getElementById('result-table-container').addEventListener('click', (event) => {
            if (event.target.id === 'forceRerollToggle') {
                forceRerollMode = !forceRerollMode;
                runSimulationAndDisplay();
            }
        });

        // SEED入力表示切り替え
        document.getElementById('showSeedInputLink').addEventListener('click', (e) => {
            e.preventDefault();
            toggleSeedInput();
        });

        // 凡例クリックイベント (コンプ済み用)
        const applyHighlightMode = () => {
             const table = document.querySelector('#result-table-container table');
             if (!table) return;
             table.classList.remove('mode-single', 'mode-multi');
             if (currentHighlightMode === 'single') table.classList.add('mode-single');
             if (currentHighlightMode === 'multi') table.classList.add('mode-multi');
        };

        document.getElementById('legendSingle').addEventListener('click', () => {
            if (document.getElementById('featuredCompleteCheckbox').checked) {
                currentHighlightMode = (currentHighlightMode === 'single') ? 'all' : 'single';
                applyHighlightMode();
            }
        });
        document.getElementById('legendMulti').addEventListener('click', () => {
            if (document.getElementById('featuredCompleteCheckbox').checked) {
                currentHighlightMode = (currentHighlightMode === 'multi') ? 'all' : 'multi';
                applyHighlightMode();
            }
        });

        document.getElementById('scrollToSingle').addEventListener('click', () => {
            const h2s = document.querySelectorAll('#calculation-details h2');
            for (const h2 of h2s) {
                if (h2.textContent.includes('＜単発ルート＞')) {
                    h2.scrollIntoView({ behavior: 'smooth' });
                    break;
                }
            }
        });

        document.getElementById('scrollToMulti').addEventListener('click', () => {
            const h2s = document.querySelectorAll('#calculation-details h2');
            for (const h2 of h2s) {
                if (h2.textContent.includes('＜10連ルート＞')) {
                    h2.scrollIntoView({ behavior: 'smooth' });
                    break;
                }
            }
        });

        runSimulationAndDisplay();
    });
</script>
</body>
</html>